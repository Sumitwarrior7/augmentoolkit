AsyncAPI Blogs Data

================================================================================

Post 1
ID: https://www.asyncapi.com/blog/conference-2024-summary?utm_source=rss
Title: AsyncAPI Conference 2024 Report
Link: https://www.asyncapi.com/blog/conference-2024-summary?utm_source=rss
Summary: AsyncAPI Conference Summary for 2024
Content:
"""
As the saying goes,"The second time is a charm."AsyncAPI Conf on Tour returned in 2024 for a set of events across different locations. Not only did we run in-person conferences, but we also brought back our beloved online conference this time around, making the whole experience complete.In the AsyncAPI Conf on Tour 2023, I mentioned a few things I would love to improve; let's see what we changed, the challenges we faced, and what we are changing as we advance.Planning ProcessAfter a successful partnership with the APIdays Paris event, they offered to sponsor a track at other events they were hosting. Given the positive outcome in Paris, we were eager to explore the options. We decided to hold three in-person events with APIdays as our venue and host sponsor.Later in the year, I thought it would be a great idea to bring back the online conference to provide an opportunity for those who can't travel but still want to speak and share their expertise. This idea completed the entire experience, bringing the total number of events to four.For a detailed summary of what happened at each event, please read the following summaries:AsyncAPI Conference HelsinkiAsyncAPI Conference LondonAsyncAPI Online ConferenceAsyncAPI Conf in ParisChallengesThe first challenge we faced was that most of the conferences were held in Europe this time, and for many, obtaining a Schengen visa isn't an easy process.Secondly, although we have a venue and host sponsor, we still need financial support to cover costs such as shipping swags and providing travel funding for speakers.AttendanceWe had an incredible turnout for all our in-person events. The highlight was networking with community members, ambassadors, and friends at the APIs Standards booth. This booth became a hub for discussions with various companies and experts while maintaining vendor neutrality.Over580people attended our in-person conference, and we had more than450views during our AsyncAPI Online Conference livestream. Additionally, the recorded sessions received over446views after the conference.You can also catch up on therecordings from the AsyncAPI Online Conference.Conference SponsorsAACoT'24 was possible thanks toAPIdays, our Event Host and Sponsor. They not only provided a venue to host the conferences and sponsored us for lunch, breakfast, and refreshments, but we also had anAPI Standardsbooth.I want to thank our financial sponsors,Gravitee.ioandPostman, for supporting the conference. Thanks to their sponsorship, I traveled to London to support the event in person.
Additionally, we were able to provide partial assistance to speakers at the Paris conference and covered the logistics of swag shipment.Special Shout OutFirstly, my gratitude goes out to all the speakers for dedicating their time to share their expertise and provide valuable insights to the community.Secondly, I want to thank all the community members who volunteered at the API Standards booth during the conference. Your commitment to sharing knowledge with attendees is greatly appreciated and does not go unnoticed.Lastly, I am genuinely thankful for their hard work and commitment to assisting me behind the scenes. They led and contributed to the aspects that made the conference successful and even being a courier so that we could have materials and set up the booth tables.Lukasz GornickiAzeez ElegbedeBarbara CzyżKhuda Dad NomaniAishat MuibudeenOluwabamikemi KayodeAshmit JagtapWhere To In 2025?For AsyncAPI Conference 2025, we are excited to announce thatAPIdayswill be hosting us in:Singapore onthe 15th - 16th of April.Munich onthe 2nd - 3rd of July.London onthe 22nd - 24th of September.Paris onthe 9th -11th of December.APIConf Lagoswill be hosting us in Lagos, Nigeria, onthe 18th - 19th of July.We will also have our annual AsyncAPI Online Conference onthe 29th of October.We are looking for financial sponsors, and if you know any company that will be interested,please download and share our conference sponsorship prospectus.
You can also check out ourOpen Collective Pageto explore sponsorship tiers.Alternatively, for more details on partnerships, please email us atinfo@asyncapi.io.Call for Speakers, SingaporeThe call for speakers for AsyncAPI Conf Singapore is now open! Send those proposals and share your knowledge and expertise with the community. The submission deadline is on the 23rd of February, so don't miss out.When submitting your proposal, please follow these simple steps to ensure you choose the correct track:Click on the link and select "Start."Choose option A, "apidays Singapore 2025," and click "OK."In the conference track selection, choose option I, "AsyncAPI."After that, you can submit your details!Looking forward to receiving your submissions!
"""
--------------------------------------------------------------------------------


Post 2
ID: https://www.asyncapi.com/blog/2024-annual-summary?utm_source=rss
Title: Annual Review: State of AsyncAPI Initiative 2024
Link: https://www.asyncapi.com/blog/2024-annual-summary?utm_source=rss
Summary: State of AsyncAPI 2024 in Numbers
Content:
"""
Happy 2025, AsyncAPI Community💜!What better way to start the year than by reflecting on the community's growth over the past year? Let's take a deep dive into the state of our community through data and see how far we have come, where we fell short, and what we can improve in the coming year. Analyzing our metrics is the most effective way to gauge our growth and measure our impact.If you are curious about our past achievements,please read the previous Project Status updates.SlackWe currently have a total of6,124members in the AsyncAPI workspace. Slack is our primary communication channel for sharing updates, assisting contributors and adopters who want to understand and use the AsyncAPI specification and toolings.We welcomed1,505new members in 2024.New members joining Slack each yearAmong this year's new joiners, we have our top five members, including our community marketing specialist, who leads the marketing efforts in the community.Top 5 new members on SlackOur weekly activity slightly dropped this year due to changes that affected some of our core maintainers after the layoffs.Slack weekly activity over the past yearsSocial MediaOur social media platforms help us communicate community news, share updates, and make announcements.
Let's dive into the numbers:LinkedInWe gained995followers on LinkedIn in 2024, bringing a total to3,983overall followers.Yearly followers on LinkedInCompared to 2023, the number of visits from users and new users toasyncapi.com, referred by LinkedIn, decreased by 40% in 2024. However, on a positive note, we received a significant increase in sessions, which kept users more engaged.Website visits referred by LinkedInWe don't use any premium or paid marketing services!X/TwitterWe gained309followers in 2024, reaching a total of4709followers overall. Website referrals declined 42% compared to the previous years, but sessions on the website increased significantly.Website visits referred by TwitterWe don't consider the X/Twitter platform worth investment; it's time to consider another platform like Bluesky to expand our reach.YouTubeOur YouTube channel continues to grow as we gain269new subscribers, having1.72ksubscribers in total. We hosted fewer community live streams in 2024, but also brought back the AsyncAPI Online Conference, increasing the total watch time.YouTube AnalyticsNewsletterIt's been a year since we sent out our first newsletter, and I'm pleased with the growth and impact it has achieved. Many community members often don't have the time to read through the entire article, so having a simple summary delivered straight to your inbox is a convenient way to stay updated on community happenings. The April edition was one of the most popular.Totals Newletter opens per each monthAdditionally, we've seen some growth in newsletter website referrals, with an increase in users and sessions.Website referral from NewsletterGoogle AnalyticsDocs continue to be our main metrics contributor, and blogs have performed quite well this past year.
The AsyncAPI website received over 1.1 million page views, while users and sessions have remained consistent.Website visits each yearGoogle Search ConsoleCompared to 2023, there has been a slight 15% decrease in website impressions and clicks recorded on Google Search Console.Website perfomance from Google Search ConsoleGitHubWe continue to see an increase in the number of active contributors who perform tasks such as commits, issues, or pull requests. In 2024, we had over2,780contributors overall.Total contributorsWe still do our very best to resolve and close issues. There have been some improvements because of programs such as the AsyncAPI Bounty Program and the Maintainership Program. We are still committed to growing the number of maintainers.Total number of issues closedNPMThe most controversial part of the review is the number of downloads from AsyncAPI's top packages, which are hosted under the Node Package Manager. Theasyncapi/specspackage continues to soar, with over34Mdownloads in the past year.Total downloads of AsyncAPI top packagesCommunity AchievementsDespite the challenges, we achieved some milestones, and here are some of the highlights from the AsyncAPI community in 2024!We had our second community hire,Oluwabamikemi Kayode, to work full-time as the project's Community Marketing Specialist.TheAmbassador Programincreased this year from having five ambassadors to ten.TheAsyncAPI Bounty Programturned 1, and we have51 issues completedso far under the program.We got accepted into GSoC'24for the first time as an independent organization.Published our second case studyfrom HDI Global.Brought back theAsyncAPI Online Conference.Closed down the AsyncAPI Store.These are some of the few highlights for 2024, and we have more planned for 2025.We are starting the year withan open discussion on establishing our first AsyncAPI Governance Board, so please join the conversation.You can also check out the2025 AsyncAPI Community Building Goalsto see what's in store for this year.Image by Canva
"""
--------------------------------------------------------------------------------


Post 3
ID: https://www.asyncapi.com/blog/release-notes-3.0.0?utm_source=rss
Title: AsyncAPI 3.0.0 Release Notes
Link: https://www.asyncapi.com/blog/release-notes-3.0.0?utm_source=rss
Summary: The release of AsyncAPI v3 is packed with changes such as request/reply, reusable channels, and more!
Content:
"""
The new version of the AsyncAPI specification - 3.0.0 - is now available and is packed with goodies! Some clear up confusion, some add features, and others improve maintainability.To make the information as clear as possible, we have split up the information into digestible chunks.If you want to get an overview of:All the changes done in v3, you are in the right place!Migration guide for all the breaking changes between v2 and v3OverviewThis post will give you an overview of all the changes done in v3.Operation, channel, and message decouplingIn v2, it has never been possible to re-use channels, because it was directly coupled with operations of an application.In v3, this is now possible, with the mindset that a channel and message should be detached from the operations performed. This means for any message broker, for example, for Kafka, channels now ONLY define topics and the messages it contains. For REST interfaces, it's all the paths and corresponding messages across all request types. For WebSocket, it's all the messages flowing through the WebSocket server. For Socket.Io, it defines all the rooms and messages therein.This change makes the channels reusable across multiple AsyncAPI documents.1asyncapi:3.0.02...3channels:4UserSignup:5address:user/signedup6messages:7UserMessage:8payload:9type:object10properties:11displayName:12type:string13description:Nameoftheuser14operations:15ConsumeUserSignups:16action:receive17channel:18$ref:"#/channels/UserSignup"Issue(s)PR(s)Migration Guide#618,#663#806,#827Operation, channel, and message decouplingMessages instead of messageAs you probably noticed above, messages in channels are no longer singular, and withoneOf, instead, messages are defined as key/value pairs in theMessages Object. This was part of the request-reply feature to enable easier referencing of messages.1asyncapi:3.0.02...3channels:4UserSignup:5address:user/signedup6messages:7UserMessage:8...Issue(s)PR(s)Migration Guide#94#827Messages instead of messagePublish and subscribe confusionIn v2, thepublishandsubscribeoperation keywords have always been confusing. Does it mean my application is published to the channel? Does it mean you publish for me? Who are you in this context?In v3, we try to clear this up. You only need to worry about your application's behavior. No more confusion about what and who does what. We achieve this through two newOperation Objectkeywords,sendandreceive, i.e. your application either sends or receives something.This description, of course, alters slightly based on protocol; for the generic message brokers, you produce or consume messages, but in the abstract AsyncAPI perspective, you still send or receive messages.1asyncapi:3.0.02...3operations:4SendUserSignedUp:5action:send6ReceiveUserSignedUp:7action:receiveIssue(s)PR(s)Migration Guide#829#847Operation keywordsRequest/ReplyOne of the longest requested features is request and reply... and it's finally here!One thorn in the eye of this feature has always been the publish and subscribe confusion, which complicated any efforts to achieve a workable solution. However, we now have a solution with that out of the way.🔥This feature has been designed with the following use cases in mind:Broker-based messaging with well-defined response topic + "correlationId".Broker-based messaging with per process individual inbox aka "replyTopic" + "correlationId".Broker-based messaging with a temporary reply topic for an individual response.WebSocket, which has no topics, where the channel is a TCP connection where messages flow.1...2action:send|receive3reply:4address:5location:'$message.header#/replyTo'6channel:7$ref:'#/channels/userSignupReply'8messages:9-$ref:'#/components/messages/userSignedUpReply'Read more about theOperation Reply Object here.Issue(s)PR(s)#94,#558#847Optional channelsWe have seen many use cases where an AsyncAPI document has been used as a form of menu or collection of definitions. To do this in v2 would require a bit of a hack. But in v3, channels are now entirely optional. This means that it's now possible to have a valid AsyncAPI document as such:1asyncapi:3.0.02...3components:4...Issue(s)PR(s)#829#847Unified referencing behaviorsIn v2, there were two instances where we used implicit references; server security configuration, by name referencing security requirement object in components, for channels to reference global servers by name. To stay as consistent as possible, we wanted to unify how references were used, which means that in v3, we ONLY use explicit references.Thescopesinformation in theSecurity Schema Objectis also now an array instead of an object.1asyncapi:3.0.02...3servers:4SomeServer:5security:6-$ref:'#/components/securitySchemes/SomeSecurity'7channels:8SomeChannel:9servers:10-$ref:'#/servers/SomeServer'11components:12securitySchemes:13SomeSecurity:14...15scopes:[...]Issue(s)PR(s)Migration Guide#829#852Unifying explicit and implicit referencesCommon metadata fieldsThere has been some inconsistency between which metadata fields are available in the different objects. Now we have added a few extra fields:addedtitle,summary, andexternalDocsfields in theServer Objectaddedtitleandsummaryfields in theChannel Objectaddedtitlefield in theOperation ObjectandOperation Trait Object1asyncapi:3.0.02...3servers:4SomeServer:5title:SomeServertitle6summary:Thissomeserverisforsomething7externalDocs:8...9channels:10SomeChannel:11title:Somechanneltitle12summary:Somechannelsummary13operations:14SomeOperation:15title:Someoperationtitle16traits:17-title:SomeoperationtraitstitleIssue(s)PR(s)#795#796Cleaning up the root objectThere was two meta information lingering in the root of the AsyncAPI object, which did not make much sense since we have theinfoobject for all the meta information.Therefore the roottagsandexternalDocshave been moved to theInfo Object.1asyncapi:3.0.02...3info:4...5externalDocs:6description:Findmoreinfohere7url:https://www.asyncapi.org8tags:9-name:e-commerce10...PR(s)Migration Guide#794Moved metadataSplitting out server URL into host and pathnameThere has been some confusion about what theurlof a server should contain; is it both protocol + host + path? What about the protocol field, then? Therefore each field now has its field for the host, path, and protocol in theServer Object.1asyncapi:3.0.02...3servers:4localhost:5host:localhost6path:/api/v1,7protocol:mqttIssue(s)PR(s)Migration Guide#547,#274#888Server URL splitting upMore reusable objects in componentsThis is a bit of a mixture between some of the features, that all added a little to this. It's now possible to add more stuff under theComponents Object:RepliesReply addressesTagsExternal docsOperationsChannels1asyncapi:3.0.02...3components:4...5replies:6...7replyAddresses:8...9tags:10...11externalDocs:12...13operations:14...15channels:16...Issue(s)PR(s)#829#847,#792,#806,#827New trait behaviorTraits in v2 always replaced any duplicate properties that were defined both in traits and the associated object. This meant, for example, if the message traits defined headers and the message object did as well, only the message trait headers would be applied because it overwrote anything you wrote in the message object.In v3, this has now been changed so thata property on a trait MUST NOT override the same property on the target object.For example, take a look at this message:1messageId:userSignup2description:Alongerdescription.3payload:4$ref:'#/components/schemas/userSignupPayload'5traits:6-name:UserSignup7title:Usersignup8summary:Actiontosignauserup.9description:Descriptionfromtrait.Take notice of howdescriptionis not overwritten by the traits:1messageId:userSignup2name:UserSignup3title:Usersignup4summary:Actiontosignauserup.5description:Alongerdescription.# it's still description from "main" object6payload:7$ref:'#/components/schemas/userSignupPayload'Issue(s)PR(s)Migration Guide#505#517,#532,#907New trait behaviorSchema format and payload definitionWith schemas, one thing that has always been impossible was reusing schemas with different schema formats. That's because the schema format information is part of the message object. That means that if you reference a Schema object, it has no information about the schema format because it's not located together.In v3, schemaFormat has been removed from theMessage ObjectandMessage Trait Object, and a newschema Object calledMulti Format Schema Objecthas been introduced, which pairs a schema together with its schema format. Which now enables much better reusability:1asyncapi:3.0.02...3components:4schemas:5avroSchema:6schemaFormat:'application/vnd.apache.avro+yaml;version=1.9.0'7schema:8type:record9name:User10namespace:com.company11doc:Userinformation12fields:13-name:displayName14type:stringIssue(s)PR(s)Migration Guide#622#797,#910Schema format and schemasSimplified ParametersIn v2, it was possible to use the full power of JSON Schema to define parameters, however, it introduced a lot of complexity to parameters, so for v3 it was dialed way down to only allow a very small set of properties.In v3, the newParameter objectcan now only have the following properties:enum,default,description,examples, andlocation.1asyncapi:3.0.02...3channels:4userSignup:5address:user/{userId}/signedup6parameters:7userId:8description:Idoftheuser.By default this means that any parameter is of typestring.Issue(s)PR(s)Migration Guide#583#935Restricted parameters objectEditorial ChangesWe haveremoved the note that stated we strived to be compatible with OpenAPI where possiblebecause, with the recent changes, this is no longer the case. That said, we still strive to make the different specs as interoperable as possible i.e., with Avro, RAML, OpenAPI Schema, etc.AcknowledgementsSpec 3.0 have been a massive undertaking, so I would like to say a huge "thank you!" to everyone who has been involved; maybe you commented on your views, added to discussions, joined the live meetings, championed changes, or reviewed proposed changes; this section is for you!Thank you,Simon Heimler,Vladimír Gorej,Fran Méndez,Lukasz Gornicki,Sergio Moya,Michael Davis,Maciej Urbańczyk,Jesse Menning,Heiko Henning,Gerald Loeffler,c-pius,Ian Cooper,Dale Lane,Jörg Walter,Nic Townsend,Laurent Broudoux,olamiral,Iván García Sainz-Aja,Fabian Bühler,John Fallows,Adrian Hope-Bailie,Christian (prdatur),Karl Morrison,Javier Jiménez Roda,Marek Sebera,Nathanaël Lécaudé,Jeremy Whitlock,souvik,Animesh Kumar,Samir AMZANI,Quetzalli Writes,Vaishnavi,Mahfuza,Bhaswati,Cynthia Peter,Arya Gupta,Joy Almeida,Hridyesh,Rohit,Ashish Padhy,Al Amin Muhammad,nickshoe,Khuda Dad Nomani,V Thulisile Sibanda,Ace,Mihael Bosnjak,Sambhav Gupta,Jonas Lagoni,Afzal Ansari
"""
--------------------------------------------------------------------------------


Post 4
ID: https://www.asyncapi.com/blog/hdi-global-interview?utm_source=rss
Title: Interview with Manuel Ottlik, Product Owner at HDI Global SE: Leveraging AsyncAPI for Integration Transparency!
Link: https://www.asyncapi.com/blog/hdi-global-interview?utm_source=rss
Summary: Learn how HDI Global SE, our first end-user and silver sponsor, leverages AsyncAPI for integration transparency. Manuel Ottlik shares insights on merging enterprise service buses with modern API management and event-driven architectures.
Content:
"""
HDI Global SE, a leading player in the insurance industry, has become our first end-user, a non-software vendor company that not only openly admits it uses AsyncAPI and shares its use case, but also became an official sponsor and a valuable partner of the AsyncAPI Initiative.
Their commitment to open source is evident through financial support, active contributions, and adoption of AsyncAPI to enhance transparency in their integration platform. We are ecstatic to haveManuel Ottlik, Product Owner of the Global Integration Platform at HDI Global SE, as one of our dedicated AsyncAPI ambassadors. Manuel has played a key role in driving the adoption of AsyncAPI at HDI, transforming our partnership into a meaningful use case.We recently had the opportunity to speak with Manuel, who shared insights into HDI's evolving integration strategies, the role of open source in their journey, and how AsyncAPI fits into their future plans. Here’s a glimpse of our conversation:About the Company and Your RoleWe began by exploring how HDI Global SE, with its long history in the insurance industry, has evolved its approach to integration and API management.Bami: HDI Global SE has a strong background in the insurance industry. How has the company’s approach to integration and API management evolved over the years?Manuel:When we were discussing the integration layer, it's not just the insurance industry but most enterprises, particularly in financial services, that initially relied on enterprise service buses. Over time, many of them, including HDI, introduced API management to leverage REST APIs. We did the same here—implementing API management alongside our enterprise service bus. Now, we're focusing our development efforts exclusively on API management.However, we realized that to fully phase out the enterprise service bus, we’d need both synchronous and asynchronous communication capabilities. This led us to incorporate asynchronous services through an event broker, ensuring comprehensive integration support.Key Challenges in Merging TechnologiesWe delved deeper into the complexities of integrating various technologies.Bami: As Product Owner of the Global Integration Platform, what key challenges have you faced in merging technologies like a service bus, API management, and an event broker into a unified platform?Manuel:One of the key challenges is that these technologies are often introduced at different times. For example, most companies start with API management and later realize the need for asynchronous capabilities. As a result, you end up with distinct interfaces for asynchronous and synchronous communication, even though they represent the same business entities.The challenge is merging these technologies and their interfaces cohesively. At HDI, we manage the platform, not the interfaces, but we issue guidance on building interfaces. We aim to have a consistent view of business objects, regardless of the integration product being used. The schemas of these business objects should align, whether they’re using OpenAPI or AsyncAPI.Goals for HDI Global SE’s Integration PlatformBami: What are the main goals HDI Global SE hopes to achieve with its integration platform, especially regarding cloud adoption?Manuel:Our primary goal isn’t tied to cloud adoption, but rather to achieving transparency for the interfaces created. We want a central point of observability, ensuring that security and architecture are aligned. It’s about reducing complexity and establishing standards.Open Source at HDI Global SEWe shifted focus to the role of open source in HDI’s strategy.Bami: Open source has transformed many industries. How has it impacted HDI Global SE’s approach to software development and integration?Manuel:One major benefit of open source over the past decade has been the standards that come with it, providing vendor independence when those standards are adhered to. We rely heavily on open source, including AsyncAPI, and many projects from the Cloud Native Computing Foundation (CNCF), which has been particularly influential.HDI’s Contributions to Open SourceBami: How does HDI Global SE contribute to the open-source community, and what benefits has the company seen from these contributions?Manuel:We contribute in various ways. I participate in the CNCF Serverless Working Group that is building CloudEvents and xRegistry, attend meetings, and we have created a case study for AsyncAPI. We’ve also sponsored your project and actively participate in open source projects through code contributions when needed.HDI Global SE’s Interest in AsyncAPIWe then discussed HDI’s interest in AsyncAPI.Bami: What sparked HDI Global SE’s interest in AsyncAPI?Manuel:Our interest in AsyncAPI stems from our goal of transparency. We maintain an API catalog for synchronous and asynchronous communication, with OpenAPI covering the former. AsyncAPI fills the gap for the asynchronous world, providing the same transparency for service-based topics and messages.Bami: How do you see AsyncAPI playing a role in HDI Global SE’s integration strategy, especially as the company continues its cloud adoption?Manuel:It's the same reason; it will be the part that enables transparency over asynchronous interfaces, service bus topics and messages in them, event brokers and events that are transmitted through these channels.Wrapping up, we explored Manuel’s thoughts on broader industry trends.Bami: What emerging trends in API management and cloud integration are you most excited about?Manuel:Asynchronous communication is still developing but will eventually be on par with synchronous communication in enterprise integration. I’m particularly excited about xRegistry, which will bridge the gap between synchronous and asynchronous communication by providing a standard for schema registries that can then host all business objects and their schemas, as well as the interface descriptions that are built upon those schemas.Through our conversation, it’s clear that HDI Global SE is not only adopting AsyncAPI but also actively contributing to its development. Manuel has been a driving force behind this partnership, and we’re excited to continue building towards a future of open, transparent, and efficient integration practices.We’re thrilled to welcome HDI Global SE as not only a Silver Sponsor but also our first end-user!🎉We’re excited about this collaboration and the shared journey to advance the AsyncAPI ecosystem together.Read more about HDI Global SE's AsyncAPI implementation case studyHave questions aboutHDI Global SE'sjourney with AsyncAPI or want to share your own experience? Join our vibrant community onSlackand let's continue the conversation!
"""
--------------------------------------------------------------------------------


Post 5
ID: https://www.asyncapi.com/blog/2024-marketing-report?utm_source=rss
Title: Marketing Report: December 2024
Link: https://www.asyncapi.com/blog/2024-marketing-report?utm_source=rss
Summary: A comprehensive review of AsyncAPI Marketing Working Group achievements in 2024, including social media growth, store closure updates, and future initiatives like the Student Ambassador Program
Content:
"""
Hello, everyone! I'm Bami, I’m the Community Marketing Specialist at the AsyncAPI Initiative, and I'm honored to serve as the Chair of the AsyncAPI Marketing Working Group. This role has allowed me to develop a unique perspective on how we can connect and inspire our community, build awareness for AsyncAPI, and further enhance our presence in the ecosystem. I’d like to share an overview of what we’ve been working on for the past six months, the initiatives currently underway, and our plans for the future.Overview of the Marketing Working GroupThe Marketing Working Group (MWG) is the driving force behind the AsyncAPI Initiative’s external engagement, community growth, and brand awareness efforts. Our mission is to encourage an active, informed, and passionate community by promoting the tools, resources, and stories that make AsyncAPI unique.
Some of the things we aim to accomplish:Increase Awareness:Develop and implement targeted campaigns to introduce AsyncAPI to a broader audience and create a clear understanding of our mission.Build Engagement:Design strategies to strengthen our community’s connection, enhance involvement, and showcase the powerful contributions of our members.Highlight Impact:Share stories, case studies, and successes from the community to inspire and inform potential contributors, users, and partners.Drive Growth:Attract new users, contributors, and partners through partnerships, events, and online activities that underscore AsyncAPI’s value in the tech landscape.
By aligning our goals with AsyncAPI’s mission, the MWG seeks to empower both seasoned and new members to engage deeply with the initiative.Below is a summary of what we’ve accomplished this year and our priorities moving forward.Accomplishments and MilestonesWe’ve focused on laying the groundwork for long-term growth and engagement for the last six months. Our marketing initiatives have been designed to elevate AsyncAPI’s visibility, simplify our communication strategy, and ensure we’re prepared to grow alongside our community.Here’s a summary of what we’ve done so far:Launched targeted social media campaigns that reached 5,031 impressions, supported by our community of designers:#AsyncAPIParis2024 campaign#YourAsyncAPIStory celebrating AsyncAPI at 8Held successfulonline eventthat engaged and informed over 350 community members and prospective contributorsImplemented regular content updates on our platforms to keep followers informed and engagedProposed the Student Ambassador Program initiative that aims to bring more attention to AsyncAPI's mission and tools, further building our presence and strengthening community tiesImplementing Buffer for Social Media ManagementTo improve the efficiency and security of our social media management, we’ve introduced a paid version of Buffer for posting content across our platforms. This change enables us to streamline content scheduling, ensuring consistent, professional updates without compromising security. Importantly, using Buffer restricts access to the main social media accounts, adding a layer of protection and allowing us to manage permissions efficiently.Here are some of the benefits of using the Buffer subscriptionCentralized Dashboard:Manage all social media platforms from a single interface, making tracking and organizing content easier.Improved Security:No need for multiple people to log into the actual social media accounts. This minimizes the risks of unauthorized changes or breaches.Better Analytics and Insights:Access in-depth analytics to understand which posts perform and engagement metrics best and adjust strategies accordingly.Content Approval Workflow:Allow team members to draft posts for review, ensuring high-quality content that aligns with AsyncAPI’s voice.Please note that I currently do not have direct access to AsyncAPI’s social media accounts. Buffer provides an effective solution for posting content, monitoring performance, and maintaining the high standards of AsyncAPI's public presence without broad access.As part of the benefit of using Buffer, we have access to our social media analytics. Below are the analytics for LinkedIn from January 1st to December 12th, 2024.AsyncAPI LinkedIn follower growth trends showing 48% increase from January to December 2024AsyncAPI LinkedIn performance dashboard showing key metrics from Buffer analytics for 2024In 2024, our LinkedIn performance saw impressive growth: a 48% increase in followers (3,910 total), 104% more impressions (100,328), and 91% more new followers (911). Engagement soared with a 219% rise in clicks (4,295 total) and a 9% improved engagement rate (5.32%). We also published 44% more posts (233), highlighting consistent content efforts.Tracking our performance on X (formally Twitter) has not been easy. Buffer does not have access to historical data. We can see numbers that show our performance since we connected Buffer in September, but we do not have historical data to demonstrate performance improvements.Closing the Online StoreOne significant change is the closure of our online store. After reviewing our budget allocations, it was clear that the store was not generating sufficient activity to justify its expenses. This decision allows us to redirect funds towards initiatives that better serve the community and our core goals. We’re considering alternative ways to share AsyncAPI merchandise in the future that are more cost-effective and in line with our community needs.As of June 2024, the items in the store were 2383. The goal was to disburse all of the items by December 2024.Chart showing breakdown of AsyncAPI merchandise inventory as of June 2024.Below is the breakdown of the item distribution and what we have left in the store.Paris Conference:1518 items sent to Paris as part of conference giveaways, speakers package, and the rest to be given to the ambassadors to help them promote AsyncAPI in their communities.London Conference:335 items shared with attendees and speakersTSC Members:40 items packed for the TSC members to acknowledge their contributions to the community.Mentors and Mentees:30 items distributed to mentors and mentees as tokens of appreciation for their participation in the mentorship programAmbassadors:2 packages were sent to two new ambassadors, each containing 11 items.Community Events and Giveaways:25 items for various online and offline events throughout the year.So far, $8,264.37 has been spent on maintaining the store and logistics. As part of the benefit of closing the store, merchandise will be made locally at the event location, and others will be made as per request.You can find all the information on the distribution board.Graph showing monthly expenditure breakdown for the AsyncAPI merchandise store.For more details on the store expenses, please go through our Open Collective pageMarketing Strategy Document and Student Ambassador ProgramTo guide our efforts, we're currently developing a comprehensive Strategy Document (PR#1358) that will outline our objectives, priorities, and target initiatives. Once finalized, the document will guide our upcoming campaigns, events, and community engagement efforts.Additionally, we are planning to introduce theStudent Ambassador Program, which aims to nurture future AsyncAPI advocates and contributors at the student level. The program will offer students guidance, resources, and community connections to help them grow within the AsyncAPI ecosystem. We believe this will strengthen our community and ensure that AsyncAPI remains a go-to resource for emerging talent.Community Growth and Future Focus AreasOur community has continued to grow steadily, with increasing participation in events, discussions, and open-source contributions. This growth underscores the need for a well-coordinated strategy that both attracts new members and retains existing contributors.
Looking forward, we’ll focus on:Implementing the Strategy Document:Utilizing our strategic roadmap to guide all our activities and initiativesLaunching the Student Ambassador Program:Engaging students worldwide to represent and support AsyncAPI within their schools and networksPromotions and Partnerships:Expanding AsyncAPI’s reach through strategic partnerships and new promotional effortsEnhanced Engagement with the Community:Creating more opportunities for community members to participate, share ideas, and grow their skillsWith these focus areas, we’re confident that AsyncAPI will continue to expand its influence and provide valuable support to both seasoned and new community members.Sponsor Involvement in the Marketing Working GroupThe Marketing Working Group thrives on collaboration, and we’re fortunate to have active participation from representatives of our sponsors, includingChristophe DujarricfromBump.shandGeorgie BurrowsfromGravitee.io. Their insights, ideas, and expertise are invaluable in shaping the group’s direction and ensuring that AsyncAPI’s marketing strategies align with the broader goals of our sponsors and the community.Who can Join the Marketing Working Group?The working group is designed to be inclusive and welcoming, not just for sponsor representatives, but also for any community members who wish to contribute.This collaborative approach ensures that diverse perspectives guide our efforts and allows the Marketing Working Group to act as a bridge between AsyncAPI’s community and its stakeholders. We'd love to hear from you if you have ideas or want to contribute!ConclusionThis report highlights the strides made by the AsyncAPI Marketing Working Group, including targeted campaigns, streamlined social media management with Buffer, impactful merchandise distribution, the development of a comprehensive strategy document, and the proposal of a Student Ambassador Program. We've also made strategic decisions, such as closing the online store, to optimize our budget for initiatives that deliver greater value to the community.Looking ahead, our focus will be on implementing the strategy document, fostering community growth, launching the Student Ambassador Program, and driving impactful promotions and partnerships. These efforts aim to strengthen the AsyncAPI ecosystem and create meaningful opportunities for collaboration and engagement.If you have any questions, suggestions, or ideas, please feel free to reach out to me on SlackAtinuke (Bami) Kayode.
"""
--------------------------------------------------------------------------------


Post 6
ID: https://www.asyncapi.com/blog/2024-gsoc-wrap?utm_source=rss
Title: 2024 Google Summer Of Code Wrap Up
Link: https://www.asyncapi.com/blog/2024-gsoc-wrap?utm_source=rss
Summary: For the first time in our history with Google Summer of Code (GSoC), AsyncAPI proudly participated as an independent organization. In previous years, we had joined the program under Postman’s umbrella
Content:
"""
For the first time in our history with Google Summer of Code (GSoC), AsyncAPI proudly participated as an independent organization. In previous years, we had joined the program under Postman’s umbrella due to the challenges of being selected as a participating organization. With Postman’s higher chances of acceptance, they graciously allowed us to include some of our projects under their organization. This year, however, marked a significant milestone as AsyncAPI stepped into the spotlight on its own.The goal of this post is to share our GSoC journey and offer valuable insights for future organizations and contributors. By reflecting on what went well, the challenges we encountered, and the lessons learned, we hope to help others make the most of this incredible program.Now, let’s dive into the key achievements and challenges of our participation this year.Key AchievementsWithout a doubt, our biggest achievement this year has been participating in GSoC as an individual organization. For several years, AsyncAPI applied as a standalone organization but was never selected.So, what changed this time? We took a step back to analyse potential reasons for our previous rejections and used those insights to refine our approach. One significant change was starting our preparation well ahead of the deadline. Special thanks go toAzeez Elegbede, who led the effort by curating project ideas, crafting our organization application, reaching out to potential mentors, and engaging with interested contributors. Azeez worked closely with the incredibleQuetzalli, whose expertise played a significant role in reviewing the application and project ideas, providing valuable guidance and support throughout the process.To showcase the impact of this year’s participation, let’s look at some key community accomplishments achieved during GSoC 2024.This year, we achieved our highest number of project idea slots in the history of our GSoC participation, with a total of7 slots.For the first time, we had4 ex-GSoC participantsreturn to the program as mentors, marking a significant milestone in building a cycle of mentorship and growth within our community.We received an impressive77 project proposals, the most we've ever had in our GSoC journey.Over100 new contributorsjoined our community from GSoC, showcasing the growing interest and engagement with AsyncAPI.AsyncAPI proudly participated as an organization at theGSoC Summit in San Francisco, whereLukasz Gornicki, one of our community members, delivered a lightning talk. His presentation focused on fostering a system that guides GSoC contributors toward becoming maintainers with mentor support, showcasing our commitment to strengthening the open-source ecosystem.We had a range of successful contributions that significantly advanced AsyncAPI projects such as:Ashmit Jagtapwho contributed extensively to the AsyncAPI Conference website by addressing existing issues and bugs, adding testing capabilities with Cypress to improve the contributor experience, and implementing support for call for speakers registration for the online edition of the conference. Additionally, Ashmit reviewed pull requests, mentored potential contributors, and ultimately became a project maintainer.Vishvamsinh Vaghelaenhanced the stability of scripts on the AsyncAPI website by ensuring all scripts functioned as expected and writing comprehensive unit tests to ensure smooth operations on the website, particularly as the number of contributors grew and more people worked on critical parts of the website.Ankit Dashadded dynamic preview image generation for AsyncAPI documents shared via the AsyncAPI Studio website. Ankit also shared his GSoC journey and contributions during the online edition of theAsyncAPI Conference.Mintu GogoiandYuan Yuanfocused on the AsyncAPI Generator project, resolving existing issues and bugs, triaging new ones, improving code through refactoring, and writing tests. Yuan shared their GSoC experience during the online edition of theAsyncAPI Conference.Ashmit JaiSarita Guptadeveloped a UI kit for the AsyncAPI website, based on the stunning designs byAishat Muibudeen. By using Storybook, Ashmit ensured brand visual consistency and created a modular, easy-to-maintain design system that streamlined further development.Esther Xiaois making significant improvements to the AsyncAPI VS Code extension by introducing an autofix feature. This enhancement helps streamline the editing process by automatically resolving common Spectral linting errors directly within the IDE.Each of these project ideas tackles key challenges within their respective repositories, bringing the initiative closer to its mission of fostering exponential community growth.We’re also beginning to see promising signs of these projects attracting long-term contributors, not only from this year’s GSoC participants but also from the broader AsyncAPI community.An Unexpected Turn of EventSometimes, things happen that are beyond your control, and that’s exactly what happened during the final phase of this year’s program.At AsyncAPI, we recognize that a project's final pull request may not always be merged within the program’s duration. This often serves as an opportunity to encourage participants to stay engaged and contribute beyond the program timeline.Here’s what happened: after successfully passing the final evaluation, one of our contributors announced on social media that their project was complete. However, their pull request was still under review by the mentor. While the mentor had passed the contributor during the evaluation due to the program’s deadlines and acknowledged their consistent hard work, they found the announcement to be unprofessional.Thanks to the mentor’s awareness, the contributor quickly removed the post and issued a heartfelt apology to both the mentor and the organizers.In light of this, we’d like to remind future GSoC participants and contributors in similar programs to avoid declaring your project “complete” until your final pull request has been merged and your mentor has confirmed the project’s completion. Let’s strive for professionalism and clarity in our contributions.The Sad StoryEvery year, when applying for GSoC, we’ve taken a two-way approach which is, applying as an independent organization while also submitting some AsyncAPI project ideas under Postman’s application just in case we weren’t selected. This year was no different, but we were fortunate enough to have both organizations accepted, giving us the flexibility to push all seven of our project ideas forward.Now, you might be wondering how is this even possible. Well, a few of us were employed by Postman specifically to work on AsyncAPI, which allowed us to coordinate participation for both organizations. With Postman’s higher likelihood of being selected, it made sense to submit some AsyncAPI ideas under their umbrella.What we didn’t foresee, however, was the sudden change of things. Postman unexpectedly laid off the entire AsyncAPI team, which not only marked the end of our roles there but also brought Postman’s participation in GSoC to a halt(possibly for future years as well). In light of this, GSoC organizers transferred all AsyncAPI-related projects from Postman to AsyncAPI, ensuring they continued under our banner.This turn of events means that moving forward, our participation in GSoC rests entirely on our ability to be selected as an independent organization. What if we don’t get selected next year? While that’s a possibility, I choose to remain optimistic. If we make it this year, we can do it again. And even if we aren’t selected, we have the AsyncAPI Mentorship Program, a program we created for moments like this. You can read more about why we started our mentorship programhere.This sudden change has made us face unexpected challenges as individuals, but we’re stronger, more determined, and deeply committed to our mission of fostering growth in the AsyncAPI community.Tips for further participantsWhile I believe that reaching for the stars is just the beginning for us as an open-source community, and with even more exciting project ideas lined up for future GSoC programs at AsyncAPI, here are some valuable tips for contributors aspiring to participate in GSoC with us:Start Early and Engage with the Community:Over the years, contributors who actively engage with the AsyncAPI community before GSoC even begins tend to have better chances of being selected. Early engagement allows you to build connections, understand the community’s needs, and showcase your commitment. It also helps you stand out to potential mentors and other contributors.Respect Maintainers’ Time:Remember, maintainers and mentors are often juggling multiple responsibilities, including their professional roles. Be mindful of their time by doing your homework before asking questions. Read available documentation, search for existing discussions, and ask clear questions when you need help. This respectful approach makes a strong impression.Focus on Quality Over Quantity:Avoid making superficial contributions just to show activity. Mentors value meaningful, impactful contributions over sheer numbers. It doesn’t matter if you’ve only contributed to the website repo instead of the generator repo, what counts is the thoughtfulness and effort behind your work.Participate Beyond Code Contributions:Being a successful GSoC contributor isn’t just about writing code. Engage in discussions, provide feedback on other contributions, and help answer questions from community members. Demonstrating your willingness to contribute in diverse ways shows your dedication to the community.Set Clear Project Timelines and Deliverables:When preparing your GSoC proposal, ensure your timeline is realistic and achievable. Break your project into smaller milestones with clear deliverables for each phase. This demonstrates your organizational skills and helps mentors see your plan for success.Communicate Clearly and Effectively:Good communication is key. Keep your mentors and the community updated on your progress, ask thoughtful questions, and don’t hesitate to seek guidance. Be proactive in addressing issues and responsive to feedback. Helping others in the community can also set you apart as a standout contributor.Seek and Act on Feedback:Throughout the program, regularly request feedback from mentors and implement it into your work. Showing that you can learn, adapt, and improve is a critical skill that mentors highly value.By following these tips, you’ll not only increase your chances of being selected but also leave a lasting positive impact on the AsyncAPI community.Special ShoutoutsPavel BodiachevskiiSambhav GuptaAnsh GoyalLukasz GornickiIván García Sainz-AjaAishat MuibudeenAkshat NemaThulisile SibandaSergio MoyaAzeez ElegbedeWe want to take a moment to extend our gratitude to the mentors above, whose dedication to the program made them go above and beyond to support and pass on their knowledge and forge meaningful relationships with our mentees. This program would not be possible without their unwavering support.A special shoutout goes to Postman, who has always allowed us to push some of our project ideas under their umbrella over the last few years, while it's sad to see this come to an end, we love and appreciate the opportunities, and the community as a whole will never take it for granted.A special thanks to Google for their belief in Free and Open Source Software (FOSS), for making this program possible every year as a show of their support to the open source ecosystem, and for allowing organizations like ours to bring passionate contributors and mentors to collaborate on a project all for the love of opensource.Finally, a wonderful shout toStephanie Taylor, the incredible program manager of Google Summer of Code, for her unwavering support during the transition of our projects after Postman’s departure. Her assistance with transferring mentor stipends to our preferred account was phenomena, and we truly appreciate her dedication and guidance!Closing RemarkIf you’re considering joining GSoC with AsyncAPI next year, we encourage you to hop into ourSlack communityand say hello in the#mentorshipchannel. We’re always excited to welcome new contributors and mentors into our growing family.We’re already looking forward to next year’s program and are committed to using this year’s lessons to make the experience even better.Until then, see you all next year, and stay connected!✌🏾
"""
--------------------------------------------------------------------------------


Post 7
ID: https://www.asyncapi.com/blog/2024-december-and-paris?utm_source=rss
Title: November and December Community Update And AsyncAPI Conf in Paris 2024
Link: https://www.asyncapi.com/blog/2024-december-and-paris?utm_source=rss
Summary: November and December Community Update And Paris Conference Summary
Content:
"""
I can't believe we are in the final weeks of the year, and it has been an eventful one. As a community, we have experienced both proud and painful moments, celebrated our victories, and faced challenges and losses. However, in the end, we overcame those difficulties and emerged stronger and better.Although this summary is a bit later than usual, I am excited to share the details of what happened in November and December and the highlights from the last conference of the year, which took place in Paris.AsyncAPI Community Building and Maintenance Goals Proposal 2025The 2025 community building and maintenance goals proposal is currently open for discussion and will soon be put to a vote for TSC members. We would love your thoughts and suggestions, particularly when solving our community's challenges.Please take a moment to review the open PR related to the AsyncAPI Community Building Goals for 2025to participate in the discussion and share your ideas and solutions.AsyncAPI Conf in Paris 2024The AsyncAPI Conf was back again in Paris this December, thanks toMehdi Medjaouiand the amazing team atAPIdaysfor hosting and sponsoring the venue. We participated in the three-day event, celebrating a year of theAPI Standardsbooth alongside friends from OpenAPI, JSON Schema, and GraphQL. Special thanks to all the members of the AsyncAPI community who could join the conference and help at the booth:Hugo Guerrero,Fran Méndez,Richard Coppen,Hari Krishnan, andLukasz Gornicki.The AsyncAPI Conf track took place on the 3rd day of the conference, featuring an impressive lineup of sessions that attracted a diverse audience. The event was consistently packed, with attendees engaged throughout the day.Attendees engaged through the sessions.Fran MéndezandLukasz Gornickistarted the track with a welcome speech and mentioned that AsyncAPI recently celebrated its 8th anniversary in November.Fran and Lukasz during the welcome speech.Naresh JainandPierre Gauthierpresented their keynote onTMForum's AsyncAPI for a New Era of Event-Driven Architecture. During the session, Pierre announced TMForum adopts AsyncAPI as a standard, with over 120 telco APIs already in production. TMForum has around 800 telco companies, and they will implement all APIs in an async manner, extensively utilizing the request-reply pattern.Naresh and Pierre presenting their keynote.Frank Kilcomminsdemonstrated how treating API governance as an enabler unlocks the ability to deliver compelling developer experiences for producers and consumers in event-driven architecture (EDA).Frank presenting on API Governance for EDA: Unlocking Developer Experience with AsyncAPI.Leonid Lukyanovshared how EDAs introduce new data models, protocols, and APIs not found in the traditional REST/CRUD application stack. And how one can abstract these elements to make them feel familiar to application developers, allowing them to create streaming applications seamlessly.Leonid presenting on Reimagining Streaming Apps with AsyncAPI and Postgres.Hugo Guerrerothen shared how the AsyncAPI Initiative is not only in charge of the specification but has created open-source projects to make it easier for developers to work with the specification documents.Hugo presenting on Using the AsyncAPI Ecosystem for Your Event-Driven Architecture.Julien TestutandAlessandro Cagnettishared how organizations can harness the full potential of event-driven integration by leveraging GoldenGate Data Streams, AsyncAPI, and Solace PubSub+ Event Mesh. They shared a great use case for AI and how it can be trained real-time and standardized with AsyncAPI.Julien and Alessandro presenting on Streaming Data Events Into An AI Cognitive Event Mesh Using AsyncAPI.Annegret Junkerexplained how to design effective asynchronous APIs by using an API-first approach. The importance of defining Kafka topics and structuring your definitions.Annegret presenting on AsyncAPI for Kafka.Jonathan Michauxspoke on how leveraging AI agents with AsyncAPI can create conversational interfaces that dynamically interact with event streams and asynchronous messaging systems.Jonathan presenting on AI Agents Meet AsyncAPI: Conversational Interfaces for Event Streams.Hari KrishnanandJoel Rosariotouched on leveraging the AsyncAPI specification as an executable contract and how to isolate and test each component within an EDA.Hari and Joel presenting on Contract-Driven Development for Event-Driven Architectures.Laurent BroudouxandHugo Guerreroended the day by explaining how to use Microcks to provide a solution for mocking and contract-testing your async APIs without extensive coding and empowering you to build extensive and reliable integration tests.Laurent and Hugo presenting From Nightmares to Sweet Dreams: Conquering AsyncAPI Testing!.Technical Steering CommitteePart of doing mentorships is witnessing the growth within the community, and we are excited to welcomeAshmit Jagtapas our newest addition to the maintainers list and TSC member. We are proud of the work you have done so far.Ashmit JagtapFinal RemarksIt's been a privilege to write the AsyncAPI monthly summary blog consistently. As this is the final blog for the year, I am genuinely grateful for the opportunity to serve and continue supporting the community.As we approach the holidays, I wish everyone happy holidays and a fantastic 2025.I'll be back next year with an overall review summary of 2024.Until then, stay safe, and happy holidays!
"""
--------------------------------------------------------------------------------


Post 8
ID: https://www.asyncapi.com/blog/2024-october-summary?utm_source=rss
Title: October Community Update And AsyncAPI Online Conference 2024
Link: https://www.asyncapi.com/blog/2024-october-summary?utm_source=rss
Summary: October Community Update And Online Conference Summary
Content:
"""
October marked the third AsyncAPI Conference, this time an online edition. As someone fortunate enough to be extensively involved in organizing the conferences, I saw the challenges that came with in-person events.
It gave me the idea to propose bringing back the online edition as part of the AsyncAPI Conference brand. We're glad and excited that we received positive results, with over360 viewsfrom attendees who watched and engaged with us.I want to express my gratitude to our financial sponsors,Gravitee.ioandPostman, as well as to the speakers for their engaging talks and the conference volunteers (be sure to check out theHall of Famesection).I encourage you to watch the recorded sessions if you missed the event. A playlist of the individual talks and slides will also be available on theconference website.AsyncAPI Community Building and Maintenance Goals Proposal 2025As we approach the end of 2024, we have a proposal outlining the community building and maintenance goals we should prioritize in 2025. Please note that the AsyncAPI community manager will manage and oversee these goals. The goals are poised to address some of the challenges our community is facing, such as the limited number of maintainers and the lack of onboarding materials, and pave the way for a more vibrant and thriving community.I encourage everyone to participate in the open discussion and share your thoughts and solutions.Please take a moment to review the open PR related to the AsyncAPI Community Building Goals for 2025.AsyncAPI ConferencesAsyncAPI Conf in Paris 2024We are excited to announce that the final AsyncAPI Conference will be held on December 5th in Paris, thanks to the amazing team at APIdays.The draft agenda is now available on our conference website, and the lineup of speakers looks fantastic.Additionally, we have a limited number of free community tickets available. To register, please visit theAsyncAPI Conference website.Note:When getting your tickets, please choose quantity one (1) of the Regular ticket and click the blue continue button to get your free ticket.AsyncAPI Conf 2025 VenuesThe discussion for potential venues for the AsyncAPI Conference 2025 is underway, and we invite everyone to participate. Please share your thoughts and suggestions for locations for the upcoming year in theAsyncAPI Conference 2025 open discussion. Your input is valuable to us!AsyncAPI Conference RebrandingIn 2023, we successfully launched the AsyncAPI Conf on Tour (AACoT). We followed our vision to host events in various locations, allowing us to connect with the community in multiple cities. As we expand our reach and grow as a brand, we believe it is necessary to drop "on Tour" and simply refer to our events as the AsyncAPI Conf/Conference moving forward.
Although we are simplifying the name, we remain committed to hosting conferences worldwide and enhancing our conference brand's visibility.We welcome your thoughts on this rebranding in the AsyncAPI Conf rebranding discussion.AsyncAPI at FOSDEM 2025Are you attending FOSDEM and interested in speaking? AsyncAPI will participate in the FOSDEM conference as part of theAPIs: GraphQL, OpenAPI, AsyncAPI, and Friendstrack.The Call for Participation is now open, and we encourage everyone in the community to apply. Deadline for talk submissions is December 15, 2024. This is another great opportunity to meet fellow community members!Should AsyncAPI Initiative Endorse The United Nations Global Digital Compact?The United Nations General Assembly has approved the Global Digital Compact, a commitment to ensure digital technologies support sustainable development and human rights.
AsyncAPI is one of the key standards for event-driven architectures, and our Executive Director,Lukasz Gornicki,has called for a voteto determine whether we, as the AsyncAPI Initiative, should endorse the Compact which aligns with our values of open-source software and collaboration.We encourage all community members to participate in the vote and share their thoughts on this important decision.Spec x ToolingWe're thrilled to announce that Glee has been migrated to a monorepo structure and is moving its core functionality to a new package called Gleequore, inspired by the Italian word "cuore," which means "heart."
This change will allow developers to leverage Glee's features without using the full framework, facilitating integration with platforms like Remix and Next.js.
We're also working on creating a "Glee for the browser" by extracting protocol adapters to support HTTP and WebSocket clients, overcoming current limitations. Kudos toFran Mendezand all the Glee maintainers for their amazing work!The packages are now available on the Glee repo; be sure to try it out.AsyncAPI Mascot Brand RefreshAs part of the AsyncAPI Bounty Program, we have a task to rebrand the Eve and Chan mascots. The designs look amazing so far!Eve and Chan - AsyncAPI MascotsPlease join the discussion and share your thoughts on the progress made on the brand refresh mascot issue.AsyncAPI Conference Hall of FameI want to extend a heartfelt thank you to the incredible volunteers who generously dedicated their skills and time to ensure the success of the Online Conference. From developers and designers to those working both on-stage and off-stage, their efforts made the planning and execution of the event seamless.Victoria NdukaMiracleAishat MuibudeenAshmit JagtapTenzin DelekAzeez ElegbedeOluwabamikemiSarvesh PatilRoland AwodaHridyesh bishtKomolafe JoshuaAnushka SaxenaManul PatelFuad ALIPHATIC AdegokeOlumideComing in NovemberAsyncAPI Community Updates Newsletter- The November Edition issue will arrive in your inbox on the 8th.Ensure you subscribe to the AsyncAPI Newsletter; you don't want to miss out.
"""
--------------------------------------------------------------------------------


Post 9
ID: https://www.asyncapi.com/blog/2024-september-summary-and-london?utm_source=rss
Title: September Community Update And AsyncAPI Conference London 2024
Link: https://www.asyncapi.com/blog/2024-september-summary-and-london?utm_source=rss
Summary: September Community Update and London Conference Highlights
Content:
"""
In September, we had our second in-person AsyncAPI conference after Helsinki; read all about it in theAsyncAPI Helsinki Conference update.This time, I had the privilege of being present in person. First and foremost, I would like to thankGravitee.ioand toGeorgie Burrowsfor sponsoring the AsyncAPI Conference. Their sponsorship enabled me to cover the visa expenses and travel costs. I also want to express my gratitude toLukasz Gornickifor his support and assistance throughout the process. It wasn't easy, but in the end, it was an incredible achievement for all of us, especially for me.AsyncAPI Conference London Edition 2024This year's London Edition was made possible by the amazing folks atAPIdays, and we were part of the 2-day APIdays London Conference. The AsyncAPI track took place on the first day, and we had an incredible lineup of speakers and talks that attracted an entire room of attendees.Full room of attendees.Lorna started things off with a session on Better AsyncAPI Governance and how to devise sensible standards that support usability, security, and reliability.Lorna presenting Better AsyncAPI Governance.Artur followed with a demonstration on harmonizing NATS, CloudEvents, and AsyncAPI to build scalable, robust, and maintainable systems.Artur presenting Harmonizing Asynchronous Systems: NATS, CloudEvents and AsyncAPI.Eduardo then shared a success story on how using AsyncAPI helps build API management platforms that enable event-driven architectures across domains by decoupling producers and consumers without compromising data contracts between parties.Eduardo presenting Event-Driven Architectures Through API Management and AsyncAPI.Later, Swen spoke on lessons we can learn from synchronous API design and architecture.Swen presenting Lessons from Sync API Design: What Makes A Good AsyncAPI?.During the break, theAPI Specs and Standards Boothwas busy with people interested in what the AsyncAPI Initiative is all about and the work we do.Specs booth during the break.Dale gave a session on how much information you need to know to design a solution around Kafka topics and illustrated the critical additional information a provider of an asynchronous API needs to provide.Dale presenting Topic Characteristics: What Do You Need To Know In Advance.Laurent shared how to use Microcks ready to work with Testcontainers to provide solutions for mocking and testing APIs without extensive coding.Laurent presenting Using Test Containers for AsyncAPI Unit Testing and Mocking.Will then demonstrated how Architecture as Code and AsyncAPI work together to create deployable environments for production and the deployment of WebSocket-based APIs in a financial organization.Will presenting Deploying WebSockets with AsyncAPI and Architecture as Code.Sho ended the day by taking us on a journey on how to build a cross-exchange trading bot and how AsyncAPI has the proper tooling to tackle pain points such as document inconsistency and missing language support.Sho presenting Building Cross-Exchange Trading Library With AsyncAPI.All the talks were incredible, and even the questions asked during the sessions were very insightful. Some of the slide presentations and recordings will soon be available under theResources Hub at the AsyncAPI Conference website.API Specs And Standards BoothWe teamed up with the OpenAPI Initiative team at the booth and had many insightful conversations.
The first day was bustling with activity, and it was interesting to see how many people were not familiar with AsyncAPI and the community.
They were very intrigued by how a bunch of folks with diverse expertise and skills from different continents and companies came together to represent AsyncAPI despite having never met. Our maintainers and ambassadors did a fantastic job educating and answering questions about the community, specification, and tooling.AsyncAPI Maintainers and Ambassadors Answering Some Questions.Day 2 at the conference was calmer and less busy than the first day, but we had the opportunity to visit other booths and get some contacts for the future.Day 2 at the booth with AsyncAPI experts. From left: Artur, Ian, Thulie, KhudaI would like to thank the experts for taking their time at the conference and volunteering at theAPI Specs and Standards Booth.Khuda Dad NomaniArtur CiocanuDaniel KocotFrank KilcomminsDale LaneLaurent BroudouxIan CooperRichard CoppenRicha SharmaAsyncAPI Conf in ParisAs you can tell, London was a success, and now there's an opportunity to be part of another fantastic AsyncAPI conference in Paris.The Call for Proposals for Pariswill soon close on the 12th of October, and we encourage anyone to apply.AsyncAPI Bounty ProgramThis month, we celebrate a significant milestone: the first anniversary of the official launch of the AsyncAPI Bounty Program. Our goal has been and continues to recognize and reward the efforts of our maintainers and contributors and to challenge the notion that contributing to Open Source is always free. You can learn about the history of the AsyncAPI Program fromthe redistribution of Open Collective funds discussion.As a community, we have greatly benefited from the program. For example, we have used the AsyncAPI Cheat Sheet at conferences, saved costs on Digital Ocean, and implemented an automated TSC voting process. For more details,please read the AsyncAPI Bounty Program Summary.Kudos toViacheslav Turovskyi(Ash) for his outstanding work in leading and managing the initiative smoothly.AsyncAPI Mantainership ProgramThe Maintainership Program is progressing well; we have received some excellent project ideas. Once the project ranking is complete, we will announce the call for applications soon.Keep an eye on the#09_mentorshipsSlack channel for the exact dates. For details on the submitted projects,please take a look at the Mentor/Maintainership discussion.AsyncAPI AmbassadorWe are excited to welcomeLorna Mitchell, VP of Developer Experience at Redocly, to theAsyncAPI Ambassador Program.Lorna MitchellComing in OctoberAsyncAPI Community Updates Newsletter- The October Edition issue will arrive in your inbox on the 9th.Ensure you subscribe to the AsyncAPI Newsletter; you don't want to miss out.AsyncAPI Online Conference-The Online Conference will take place on the 30th of October. Be sure to check the website for the Agenda and Speakers.
"""
--------------------------------------------------------------------------------


Post 10
ID: https://www.asyncapi.com/blog/helsinki-and-community?utm_source=rss
Title: AsyncAPI Conference Helsinki and the API Specs and Standards Concept
Link: https://www.asyncapi.com/blog/helsinki-and-community?utm_source=rss
Summary: Conferences are great. They bring communities together and give people a platform to share their experiences. But is that enough?
Content:
"""
How It All StartedAfter three years of hosting online conferences (2020-2022), the AsyncAPI community felt it was time for something different— an in-person event. We wanted to meet people face-to-face, to confirm that behind the virtual interactions were real humans, the ones you could have meaningful conversations with, not bots!In 2023, we organized multiple events under the brandAsyncAPI Conf on Tour. One of them took place atAPIDays Paris, made possible by the amazing folks behindAPIDays, who share our belief in the future of strong API specifications and standards.It was a fantastic opportunity, but we had one major concern—how do we find our community members in an event with thousands of attendees? How do we have meaningful conversations? And how do we engage with people who don’t know about AsyncAPI yet?
As you probably know, conference talks end, and people scatter. It’s easy to lose them in the crowd.One of the best places to meet people at conferences is at the sponsor booths. But as an open-source, community-driven project, we don’t have the budget for that kind of setup.Once again,APIDayscame to the rescue and offered us a booth.We decided to take it one step further—not just a booth for AsyncAPI, but a shared space for other open-source communities. At Paris 2023, we organized the firstAPI Specs & Standardsbooth, bringing together AsyncAPI, OpenAPI, and JSON Schema experts. We created a vendor-neutral, safe space for knowledge exchange, where experts from different companies shared their expertise without pushing for their products.AsyncAPI Conf on Tour at APIDays Helsinki 2024Our next stop wasAPIDays Helsinki 2024.Hugo kicked things off with a great introduction to the AsyncAPI spec and later wrapped up the track with an excellent session on testing event-driven architectures.Hugo presenting AsyncAPI basics.Jonas followed with a detailed overview of the AsyncAPI tooling ecosystem, showcasing the various tools built around the specification to support developers working with AsyncAPI documents.Jonas presenting the AsyncAPI tooling ecosystem.I then presented an overview of AsyncAPI use cases, demonstrating how different companies use AsyncAPI in production, all based on real data we’ve gathered over the years. You can explore all of this in ourAsyncAPI case studies.Lukasz presenting how AsyncAPI is used in production.The talks were engaging, and the questions that followed were great. Slides from the talks areavailable for download. But the best, most technical, and insightful conversations happened at theAPI Specs and Standardsbooth. We teamed up with friends from the OpenAPI Initiative and had deep, meaningful discussions.OpenAPI and AsyncAPI experts side by side. From left: Lukasz, Erik, Frank, Hugo, and Jonas.September 18-19 in LondonI won’t be attending the London event this year, but plenty of other folks will, especially at theAPI Specs and Standardsbooth. I hope you all have as much fun there as we did in Helsinki!OpenAPI and AsyncAPI experts getting to know each other during a Helsinki city run.If you haven’t grabbed your ticket yet, AsyncAPI community members can get free passes. Justcheck out the agenda and reserve your spot.December in Paris and the future of the BoothLooking ahead to December, we’ll have some free passes for the Paris event too. But honestly, the best experience is joining as a speaker. Not only do you get a free pass, but you also get to attend the speaker’s party the night before the event. Most importantly, it’s a unique opportunity to share your story with the widerAsyncAPIcommunity. CfP is still open.Of course, we’ll have a booth again. This time, it won’t just be AsyncAPI and OpenAPI folks—our friends from JSON Schema will join too.Since it’s the fourth time we’ll be hosting this booth, I have a feeling it’s time to take things up a notch. We need to be more organized, include more community members, and maybe even secure some dedicated funding. A rebranding could be in order, too—perhaps renaming the booth toOpen API Standards. We could also broaden the scope to include experts from the open-source tooling ecosystem that builds on top of these standards and operates under open governance.Enjoy!
"""
--------------------------------------------------------------------------------


Post 11
ID: https://www.asyncapi.com/blog/asyncapi-bounty-program-2024?utm_source=rss
Title: AsyncAPI Bounty Program Summary - 2024
Link: https://www.asyncapi.com/blog/asyncapi-bounty-program-2024?utm_source=rss
Summary: Annual update on the quarterly published set of tasks that are currently in demand among AsyncAPI Maintainers, targeted at engineers of Middle and Senior professional levels.
Content:
"""
AsyncAPI Bounty ProgramSince ancient times, sponsors furiously wanted to support Open Source. AsyncAPI addressed that need by starting to quarterly publish for Middle and Senior engineers a set of tasks that are currently in demand among AsyncAPI Maintainers and rewarding their completion using accumulated donated funds.During one year of existence of theAsyncAPI Bounty Program:32 GitHub issues were resolved,16 of whichhad complexity levelAdvanced;50+ PRswere merged in total;8000+ USDwere paid out as rewards.Benefits for FOSS CommunityAt leastone issuewas closed in a third-party project due to a fixed bug in AsyncAPI's software.Benefits for AsyncAPI GitHub OrganizationThanks to the Bounty Program Participants, AsyncAPI got:Automation in Technical Steering Committee voting process(Aayush Saini): New automation and theprocess around votinghave been introduced, as well astransparent summariesof each voting activity.New monorepo setup ingeneratorandparser-js(Ayush Nautiyal): Consolidation of smaller repositories into these two larger projects helped unify the dispersed community within the organization, fostering collaboration in a single location and accelerating development.Saving of costs on DigitalOcean (Ashish Padhy): AsyncAPI was running out of credits too fast, and withproper deployment changes, it's not the case anymore.GitHub Action refactored from scratch to use CLI (Ashish Padhy): Simplification is always a driver for innovation. Now official GitHub Action from AsyncAPI supports not only AsyncAPI Generator but also 1:1 all features from the CLI.Not just any but AMAZINGcheat sheet poster(Aishat Muibudeen): It is not only availablefor download, but is also used at AsyncAPI conferences.Benefits for AsyncAPI MaintainersThe Bounty Program gives AsyncAPI Maintainers the possibility:To announce a financial reward for GitHub issues that are currently in demand by the maintained project or the AsyncAPI Initiative as a whole, on which AsyncAPI Maintainers can either work and get rewarded themselves or delegate those issues to regular contributors who have more time and/or the necessary expertise.Benefits for Bounty Program ParticipantsTypical benefits of the Bounty Program for its Participants who are in the early stages of their career are:Development of a better approach to the evaluation of issues (it's fun reading messages from two months ago saying, '1-2 weeks left'.)First/differing working experience (fully asynchronous distributed teams are still rare, unlike partially asynchronous distributed ones.)Development of the possibility to showcase to the potential employer real-world work not obscured by an NDA.With all that said, join a finally sure way to directly sponsor (and get rewarded for) FOSS development.Giggly thing as a finishing touch:PRfor a bug due to which several lines were output incorrectly to the front end.Co-authored-by:Lukasz Gornicki
"""
--------------------------------------------------------------------------------


Post 12
ID: https://www.asyncapi.com/blog/2024-august-summary?utm_source=rss
Title: Community Update: August 2024
Link: https://www.asyncapi.com/blog/2024-august-summary?utm_source=rss
Summary: August Community Update
Content:
"""
The summer holidays are almost over, but the community hasn't slowed down. We've been receiving great news, and I'm thrilled to share that our list of sponsors is growing.We're excited to welcomeHDI Globalas our first end-user non-software vendor company as our Silver Sponsor. We're grateful toManuel Ottlikfor helping us secure this sponsorship.Additionally, we'd like to welcomeRoute4Meas our Silver Sponsor for the initiative. We're thankful for their support.Finally, we've received the transfers fromPostman. As promised, they've elevated their support from Gold to Platinum level and become a Platinum sponsor for theAsyncAPI Conf on Tour. They've also allocated an extra $10,000 to further initiatives within the AsyncAPI ecosystem.We're truly grateful for the support we're receiving to drive the vision and the initiative forward.AsyncAPI Conference'sWe are excited thatour 2nd AsyncAPI Conference will be in London on September 18th. The event will feature a fantastic lineup of speakers and a jam-packed schedule.
As promised, we have some free community tickets for the conference;please visit the AsyncAPI Conference website and click the register button.Note:When getting your tickets, please choose quantity one (1) of the Regular ticket and click the blue continue button to get your free ticket.If you are unable to attend our London conference, we will also be heading to the Paris conference on December 5th.Our Call for Proposals is still open, and we encourage everyone to submit a proposal and share their expertise with the community.Additionally,the Call for Proposals for our Online Conference is open. Don't miss this opportunity to participate in and join us for this virtual event.
The deadline for proposal submissions will be on the 20th of September.Spec x ToolingOpenAPI to AsyncAPI ConverterWe love seeing the impact of theAsyncAPI Bounty Programand how it solves community needs. One recently completed project introduced an OpenAPI 3.0 to AsyncAPI 3.0 convertor. The converter enables the easy transition of OpenAPI 3.0 documents to AsyncAPI v3. Thanks toMintu Gogoi'seffort and contribution, as well asJonas Lagoni, for reviewing, providing feedback, and providing guidance until the issue completion.For more details about the converter,please check the AsyncAPI converter readme.AsyncAPI Developer NetworkThe initial version of theAsyncAPI Developer Networkis out. Here, you can access all the details about the specification and its components, including bindings, schemes, and security. The main goal is to gather existing and new guidelines on the use cases of the AsyncAPI specification in one place.
Kudos toPavel Bodiachevskiifor his outstanding work.Be sure to visit theAsyncAPI Developer Network portalfor additional information.Kotlin-AsyncAPIThe donation forKotlin-AsyncAPIis complete, and the repository has successfully migrated under the AsyncAPI organization. Many thanks toLorenz Simon, and we are pleased to welcome him as a new AsyncAPI maintainer as well.AsyncAPI Maintainers ListThanks to our bounty program and support fromMateusz Szostok, we're now maintaining the list of all AsyncAPI Maintainers in one place in an automated way.
The functionality is based on GitHub feature calledCODEOWNERS. Each repository contains such a file and is the truth source for us. The new automation keeps an eye on these files and updatesMAINTAINERS.yaml. In such a large organization, it is hard to follow all the changes in ownership of certain repositories manually.Thanks to the automation, we also know that the current number of maintainers in the AsyncAPI Initiative is72.AsyncAPI Mentorship ProgramThe planning for the 3rd cohort of the AsyncAPI Mentorship Program is already underway. In this edition, we prioritize projects that promote maintainership, meaning project ideas should align with our goals and pave the way for contributors to evolve into maintainers.If you have an exciting project idea that should be part of the program, please share it in theMentorship Program 2024 discussion. If you want to participate as a mentor,please read more in the AsyncAPI Call for Mentors discussion.Case StudiesWe're thrilled to announce the publication of our second case study. The HDI Global brand provides life and property/casualty insurance services in Germany and internationally. They serve individuals and corporate clients and have offered industrial insurance since 2016.For more in-depth information,explore the HDI Case Study on our website.AsyncAPI AmbassadorWe are pleased to welcomeManuel Ottlik, Product Owner of the Integration Platform at HDI Global SE, as ourAsyncAPI Ambassador.Manuel OttlikIf you want to join the program or learn more about our current ambassadors, please visit ourAsyncAPI Ambassador Program Page.Coming in SeptemberAACoT'24 London-The London Edition will take place on September 18th and 19th. Be sure to get your tickets. See you there!!AsyncAPI Community Updates Newsletter- The September Edition issue will arrive in your inbox on the 5th.Ensure you subscribe to the AsyncAPI Newsletter; you don't want to miss out.
"""
--------------------------------------------------------------------------------


Post 13
ID: https://www.asyncapi.com/blog/2024-july-summary?utm_source=rss
Title: Community Update: July 2024
Link: https://www.asyncapi.com/blog/2024-july-summary?utm_source=rss
Summary: July Community Update
Content:
"""
It's been a month since our partnership with Postman ended, and some of our maintainers at AsyncAPI lost their jobs. However, we are proud of sponsors like IBM, who continue to support open source and the Initiative. Please take a moment to readSalma Saeed'sarticleon how IBM is supporting AsyncAPI in breaking the boundaries of Event-Driven Architecture.We also encourage the community tocontinue sharing and assisting the impacted professionals in finding new opportunities.AsyncAPI Conference'sAACoT'24 LondonWe are excited to announce a fantastic line-up of speakers and engaging topics for our AACoT'24 London edition. Keep an eye out on our Slack workspace for ticket announcements and other important updates for the event.
For a sneak peek of what to expect,be sure to take a look at AACoT'24 London Agenda.AACoT'24 Online EditionPreparations for our online conference are well underway. We have begun implementing our Call for Speakers page, thanks to the amazing contributions ofAshmit Jagtap. For a glimpse of how this is coming along,please review the Call for Speakers form pull request.In the meantime, please start preparing your talk submissions and get ready to present on the conference day, on the 30th of October.AsyncAPI Conf in ParisWe are excited to announce that the Call for Proposalsfor our "main event" in Paris is now open. Start preparing your talks and submit them before the final deadline on September 20th. Don't miss it!Please Note: When submitting your proposal, choose the "AsyncAPI Conference (part of apidays Paris- Dec 5)" option and then the AsyncAPI track.Spec x ToolingNew ProjectAfter a successful vote, we will onboard a new project calledKotlin-asyncapi. This project consists of code-first tools that simplify the creation of AsyncAPI documentation for Kotlin applications. It allows developers to write the AsyncAPI docs in Kotlin code using a DSL or generate it directly from the code. Additionally, it integrates with Spring Boot to serve the generated docs via a REST endpoint.
For more details,please refer to the open discussion on Donate kotlin-asyncapi. If you want to familiarize yourself with the codebase,check out the kotlin-asyncapi repository.Thanks toLorenz Simon, who chose to move the project under the AsyncAPI umbrella to enable collaboration with a wider community. Lorenz is also searching for volunteers to join him as project maintainers.Call for New MaintainersTheTypeScript/Node.js NATSand.NET C# NATS templategenerators are looking for new maintainers. If you want to maintain these templates, please express your interest in thets-nats-template discussionor thedotnet-nats-template discussion.AsyncAPI v3 SupportWe are excited to have the AsyncAPI Validator byWaleed Ashrafas one of the latest projects to support v3. The AsyncAPI Validator project validates your messages against your AsyncAPI document. Be sure to test andtry out the AsyncAPI Validator for your projects.AsyncAPI Bounty ProgramThe AsyncAPI Bounty Program Q3is making good progress. Out of the 9 assigned issues, 3 are now complete.We have awarded $600 for the completed tasks, and an additional $400 will be processed by the end of July.Mentorship ProgramsOur Google Summer of Code'24 mentors have recently submitted their mid-term evaluations, and we are thrilled that 7 out of 8 mentees passed their evaluation. We still have one more mid-term evaluation, and I'm confident they will also pass, as the mentees are working hard on their contributions.You can check out the accepted AsyncAPI project listand see what the mentees are working on.Technical Steering CommitteeTo improve transparency in the project and ensure regular monitoring of the TSC's participation, we have implemented an automated report of TSC voting with support fromAayush Saini. The report provides detailed information about the voting process, andyou can check out the first version of the TSC Overview doc report.As a TSC member, if you identify incorrect data,please create an issue in the community repositorywith the correct information, as it will allow us to review and address any issues with the automation process or voting discrepancies.Coming in AugustAsyncAPI Community Updates Newsletter- The August Edition issue will arrive in your inbox on the 7th. Ensureyou subscribe to the AsyncAPI Newsletter.
"""
--------------------------------------------------------------------------------


Post 14
ID: https://www.asyncapi.com/blog/2024-june-summary?utm_source=rss
Title: Community Update: June 2024
Link: https://www.asyncapi.com/blog/2024-june-summary?utm_source=rss
Summary: June Community Update
Content:
"""
We have some fantastic news to share: we are pleased to welcomeIBMas our new Gold Sponsor for this year. We are proud of IBM's ongoing support for the initiative. A huge thank you goes toSalma Saeedfor her efforts in making this happen.If you are interested in supporting the AsyncAPI Initiative or would like to know how we spend our donations, please take a look at ourAsyncAPI Financial Summaryfor detailed breakdowns.Postman Partnership ChangesIn recent developments, several dedicated professionals from Postman who worked full-time on the AsyncAPI Initiative have unfortunately been affected by structural changes marking the end of apartnership with Postman that lasted over three years.Despite the recent changes, it's important to note that Postman's dedication to AsyncAPI remains strong. The decision to let go of these talented individuals does not diminish the value or importance of AsyncAPI. Postman continues to acknowledge and support the significance of AsyncAPI in the industry and has significantly increased its financial backing for AsyncAPI.Postman has elevated its support to the Platinum level with an additional contribution of $12,000. Moreover, Postman will also become a Platinum sponsor for the AsyncAPI Conf on Tour, offering a $5,000 contribution. Additionally, they will allocate an extra $10,000 to further initiatives within the AsyncAPI ecosystem.Opportunities for Skilled ProfessionalsFor those professionals impacted by the changes, we urge the AsyncAPI community to come forward and help them in their job search. A list containing all names, profile descriptions, and contact information is available. We encourage the wider community toshare this information and assist these professionals in finding new opportunities.AsyncAPI Conf on TourWe are fast approaching theCall for Speakers for AACoT'24 London deadline. We encourage anyone to submit their proposals and share your expertise with the community.As we plan for the Online Edition in October, we intend to host the conference on Wednesday, 30th October. Please share your thoughts or vote in theAsyncAPI Online Conference discussionif you agree or would like to propose a new date.AsyncAPI Mentorship ProgramWe've had a few people asking if we'll be hosting our annual AsyncAPI Mentorship Program this year, and the answer is yes. We're planning to start the program around September, as we're currently focusing on mentorships under Google Summer of Code. Although this may seem far off, it will allow us time to plan properly, especially as we aim to include more Maintainership projects in the program. As we are in preparation for this, you can read about how the previousAsyncAPI Mentorship Program in 2023 went.Please keep an eye on our Slack channel for further announcements.AsyncAPI Bounty ProgramThe AsyncAPI Bounty Program Q3 is in full swing, with 9 out of 10 issues already assigned and being worked on. Meanwhile, half of the Q2 issues are still in progress. We are pleased to see the program positively impacting the community.
We want to express our gratitude toViacheslav Turovskyifor his dedication to running the program smoothly and ensuring that participants adhere to the Bounty Rules. For more details on the submitted issues, please take a look at theAsyncAPI Bounty Program Board.Community DiscussionsWebsite RedesignIn recent weeks,Aishat Muibudeen(Maya) has been conducting a UX audit on the AsyncAPI website and has identified user experience issues. In the audit, she proposed redesigning the website to address these issues and improve the overall experience. Please read theProposal to Redesign the AsyncAPI Websitefor more details.Marketing Working GroupWe have a new Marketing Working Group; the group aims to use marketing strategies to accomplish two key objectives: promoting AsyncAPI adoption and showcasing community achievements. It envisions close collaboration between the AsyncAPI community and sponsors by strategically demonstrating AsyncAPI capabilities and celebrating community successes. If you're interested in participating, please join theMarketing WG channel on Slack.TSC x AmbassadorsWe are excited to welcome two new additions to our Ambassadors. Please help us welcomeRaphael De Lio, Software Consultant at Xebia, andHari Krishnan, Co-Founder and CTO at Specmatic.Raphael De LioHari KrishnanIf you are interested in joining the program or want to know more about our current ambassadors, please visit ourAsyncAPI Ambassadors Program Page.Coming in JulyAACoT'24 London CFP Deadline-The Call for Speakers for AACoT'24 London Editionwill close on the 12th of July. Please submit your proposal soon and prepare to share your knowledge with the community.AsyncAPI Community Updates Newsletter- The July Edition issue will arrive in your inbox on Thursday the 4th. Ensureyou subscribe to the AsyncAPI Newsletter.
"""
--------------------------------------------------------------------------------


Post 15
ID: https://www.asyncapi.com/blog/2023-mentorship-summary?utm_source=rss
Title: AsyncAPI Mentorship Program Summary - 2023
Link: https://www.asyncapi.com/blog/2023-mentorship-summary?utm_source=rss
Summary: In April 2023, we embarked on the second chapter of the AsyncAPI Mentorship Program. I couldn't be more excited to share that it was a phenomenal success!

In The Beginning

Let's take a moment to rem
Content:
"""
In April 2023, we embarked on the second chapter of the AsyncAPI Mentorship Program. I couldn't be more excited to share that it was a phenomenal success!In The BeginningLet's take a moment to reminisce about the very beginning. The buzz started with a livelyMentorship Program discussionthat saw participation from over 28 eager individuals, hinting at the incredible potential of the 2023 edition. We received a total of 21 project ideas that were nothing short of impressive, covering a spectrum from coding challenges to creative designs and comprehensive documentation efforts.The sheer variety opened doors to an overwhelming wave of candidate applications - more than 90! The applications came from contributors of various skills and backgrounds, each one rich with potential. Given the wealth of talent and ideas, our biggest hurdle was our budget, which allowed us to fund positions for only 13 candidates. After much consideration and deliberation, we also made the challenging but rewarding decision to move forward with only 10 of the 21 proposed projects.Proposed Project IdeasSelected Project IdeasCandidate ApplicationsSelected Candidates21109013Common Applicant MistakesWhile we received over 90 outstanding applications(proposals), only 13 applications made it through the final phase. During the selection process, we identified patterns from most applications:Quality of proposal: We noticed that most folks who were already familiar with the project or mentor assumed an automatic pass, so they spent less time working on their proposal. This is wrong and one of the reasons applicants like that got rejected. We believe everyone should work equally, irrespective of their status in the community.A well-defined timeline: Most of the applicants seem to ignore the impact of the impact of having a well-written and broken-down proposal. Many applicants kept their timelines short and vague, but when reviewing this proposal, mentors must focus on the timeline because they expect you to deliver results based on the timeline provided in your proposal.Communication: Mentors often select applicants who are often in communication with them during the selection process, not just to help enhance their application but to help them understand the project better and give room for asking and answering relevant questions during the application and selection phase.Not an Internship: Reviewing and selecting applicants can be a tedious job, which is one of the reasons most mentors love to select applicants who don't see the program as a means to earn money. Mentors prefer folks who are interested in the project mostly because of their love for open-source projects.The ResultsAs I mentioned in the beginning, the program was a success. Now, let's have a more in-depth look. Compared to 2022, when only 6 of 10 candidates completed their projects, this year, 12 out of 13 candidates successfully completed them. If you ask me, that's an outstanding improvement! But unlike the last edition, where we had no evaluation phase, I believe the introduction of the evaluation phase made a really huge impact on the success of this edition of the mentorship program.Now, let's see what the evaluation phase was like for selected participants.What was the Evaluation Phase like?In the first evaluation phase, 11 candidates passed successfully, and two candidates were granted an extension to complete the phase along with the final evaluation. The second evaluation phase went smoothly, with a total of 12 candidates successfully passing. One reason for the successful second evaluation was our flexible evaluation period, allowing mentors to extend the deadline based on realistic timelines for their candidates.The second evaluation went well, with 12 candidates successfully passing the phase. One reason for the success of the second evaluation was that we did not enforce a really strict evaluation period. We defined a specific evaluation date but enabled mentors to extend it based on the date they feel is more realistic for their candidate.Throughout the evaluation phases, we received excellent feedback from mentors. They noted that certain mentees could develop their own solutions, think creatively, produce high-quality work, and demonstrate strong communication skills. During the first evaluation phase, some mentees had made significant progress, impressing us.It's important to mention that we evaluated both the mentees and the mentors during the phases. This approach allows us to provide feedback to mentors for improvement and better mentorship experiences in the future.Projects successDuring the program, eight projects ranging from engineering to design and writing got some great help. Let's shine a light on some of these projects:Website UI Kit design/dev project: Thanks to the success of this program, the AsyncAPI website got a design system, which is something we really wanted. Now whenever someone works on the website, there's a consistent way of doing things design-wise.Simulator Desktop Application:  The AsyncAPI simulator, which started as a project in GSoC '21 and was just a command-line tool, now has a version that works on desktops. Now it's easier for people to use it right from their computers.Documenting how different protocols work with AsyncAPI: A group of four candidates embarked on a detailed project documenting the interaction between various protocols and AsyncAPI. Thanks to the program, they developed and published two series of tutorials covering how to use AsyncAPI with theKafka, which has gotten 3559 views since its release, andWebsocketprotocols which has gotten 2689 views.Add support for translations: Thanks to the implementation of the i18n, the AsyncAPI website now supports translation. It will be easier to add support for multiple languages on the website.Rewriting Nodejs template to react engine with support for AsyncAPI v3: We overhauled the template by the program's success, transitioning from Nunjucks to the React template engine. Additionally, the template now supports the new AsyncAPI v3; this makes the template much easier to extend in the future with new features.Note: Each project chosen for the program was on the receiving end of profound contributions during this phase. For brevity, we’ve highlighted only a selection.Mentees' SuccessesWhile all the selected projects received outstanding contributions from the mentees, I'm pleased to share some of the successes experienced by the mentees who participated in this program after its completion.Path to Maintainership: After the program, the following mentees became maintainers of certain projects due to the knowledge they gained during the mentorship program.AISHAT MUIBUDEEN: Design maintainer in theAsyncAPI WebsiteAnsh Goyal: Committer in theAsyncAPI WebsiteSambhav Gupta: Code triager maintainer inAsyncAPI WebsiteKaushik Rishi: Code maintainer inNodejs TemplateVaishnavi Nandakumar: Docs triager maintainer inAsyncAPI WebsiteJoy Almeida: Docs triager maintainer inAsyncAPI WebsiteActive Contributors: With the dedication and guidance provided by our mentorship program, many mentees have grown into active contributors, driving positive change and making significant impacts within our community. Their journeys from eager learners to influential leaders stand as a testament to the power of mentorship and the potential within each participant.Full Circle: A few of these mentees have come full circle and now serve as mentors in this year’s Google Summer of Code (GSoC). Their transition from mentees to mentors is a testament to their exceptional growth and dedication. Once guided and nurtured through our program, these individuals are now giving back by sharing their knowledge and experience with the next generation of mentees. We are incredibly proud of their achievements and commitment to fostering a culture of learning and mentorship. Here's the list of mentees who became mentors:AISHAT MUIBUDEEN: GSoC mentor for theAsyncAPI Website UI Kit DevelopmentAnsh Goyal: GSoC mentor forScript Stability Enhancement for AsyncAPI WebsiteSambhav Gupta: GSoC co-mentor forScript Stability Enhancement for AsyncAPI WebsiteOutside the community benefit: Thanks to the invaluable support and guidance from the program, some mentees received job offers and sought-after internships.The achievements of these individuals highlight the transformative power of mentorship, demonstrating how dedicated support can unlock potential and pave the way for professional success. The program's successes are a testament to the hard work of our mentees and the unwavering commitment of our mentors to fostering growth and excellence.What's Next?Firstly, we'd like to thank everyone who made this program possible, and we are looking forward to the next edition, which will commence on the 20th of June 2024. If you are interested in participating in the next edition as a sponsor or contributor, please get in touch with us.How To Connect With UsJoinour AsyncAPI Slack workspace. Be sure to follow ourSlack etiquetteandour code of conduct.Join the dedicated Mentorship channel#09_mentorshipsfor all mentorship discussions. All mentees and mentors are there.Photo bySpaceXonUnsplash
"""
--------------------------------------------------------------------------------


Post 16
ID: https://www.asyncapi.com/blog/2024-may-summary?utm_source=rss
Title: Community Update: May 2024
Link: https://www.asyncapi.com/blog/2024-may-summary?utm_source=rss
Summary: May Community update
Content:
"""
May has been a fantastic month for our community. We are delighted to announce thatGraviteehas joined us as our new Platinum sponsor; thanks toGeorgie Burrowsfor making this happen.Furthermore, we are thrilled to welcomeSmartBearas our Silver sponsor; thanks toFrank Kilcomminsfor making this happen.We cannot thank our sponsors enough for their unwavering support. Your contributions are truly invaluable.AsyncAPI Conf on TourWe recently wrapped up our first conference of the year in Helsinki and are grateful to our speakers for coming to share their knowledge and expertise; slide content will be available on theconference website soon.Next, we'll be heading to London for our next event. We are stillaccepting proposals for speakers, and we encourage anyone who would like to share their expertise or insights with the community to apply. The deadline for submissions is July 12th.We also seek volunteers to help organize our upcoming online conference in October. If you are interested in being involved in the planning process, hosting, designing, or contributing to the conference page,please take a moment to fill out the Call for Volunteers form, and we will be in touch soon.AsyncAPI Website MigrationOurAsyncAPI Websitehas successfully migrated to NextJS + TypeScript for easy maintenance. Thanks toAkshat Nemafor leading this fantastic work and for contributions made byAshmit Gupta,Ashish Padhy,Vishvamsinh Vaghela,Ansh Goyal, andSambhav Gupta. Pleasereview the new codebase on GitHubandcheck out the pull request with the website migration changes.Spec x ToolingWe're excited to announce that a new case study fromHDI Global SEis in progress and will soon be available on our website. Please keep an eye on Slack for the announcement when it's ready. For a quick sneak peek of the work-in-progress, check out theHDI Global SE case study preview.AsyncAPI Bounty ProgramTheAsyncAPI Bounty Program is now accepting issues for Q3. If you maintain any AsyncAPI repository and have backlog issues you don't have time to address, please consider submitting them. We encourage the submission of design and documentation issues. For more details and to track the current progress for Q2, please check out theBounty Board.Community DiscussionExploring ways of project fundingWe are exploring ways to fund our project, such as monetizing YouTube. If you know of any other funding solutions we could incorporate into the initiative, please share your suggestions in the open discussion onExploring Different Ways of Funding Project Work.Slack Admin Rights for CoC CommitteeWe are updating and finalizing the new AsyncAPI Code of Conduct Committee documentation. To help ensure the safety of the Slack workspace, we are holding an open vote to grant admin rights to full-time CoCC members. For more details and to cast your vote, please look at theProposal for Slack Admin Rights for CoC Main Committee discussion.New HireWe are pleased to welcomeOluwabamikemi Kayodeas our first Community Marketing Specialist. With the collaboration of experts in the marketing working group, she'll help us spearhead our marketing efforts. Thanks to ourOpen Collective donations, Bami is the second person to join the AsyncAPI Initiative and work full-time.Coming in JuneAsyncAPI Mentorship Program- Many have been wondering if we will have a third cohort of the AsyncAPI Mentorship Program and when it will start. Be sure to keep an eye out for announcements this month.AsyncAPI Community Updates Newsletter- The June Edition issue will arrive in your inbox this week. Ensureyou subscribe to the AsyncAPI Newsletter; you don't want to miss out.
"""
--------------------------------------------------------------------------------


Post 17
ID: https://www.asyncapi.com/blog/asyncapi-website-migration?utm_source=rss
Title: Migration of AsyncAPI Website to Next.js v14 and TypeScript
Link: https://www.asyncapi.com/blog/asyncapi-website-migration?utm_source=rss
Summary: Migration journey of the AsyncAPI Website, features introduced, and future plans.
Content:
"""
We're thrilled to announce the successful migration of the AsyncAPI website from JavaScript and Next.js v12 to TypeScript and Next.js v14! This exciting upgrade unlocks a new chapter for the website, paving the way for improved scalability, streamlined feature implementation, and the powerful capabilities of Next.js. As a bonus, this migration also enabled a well-documented codebase and streamlined our testing process by reducing the reliance on Cypress tests. In this blog post, we'll delve into the exciting journey behind the migration and share what's new on the website. I'll share insights into our team's efforts, the research and planning involved, the challenges we tackled, the valuable lessons learned, and what exciting plans lie ahead for the AsyncAPI website.This migration journey spanned from February to May 2024, and it involved a dedicated team of contributors and maintainers passionate about the AsyncAPI Initiative and the ecosystem of tools it provides. We'd like to give a shout-out to our amazing team:Lukasz Gornicki,Rohit T,Akshat Nema,Ansh Goyal,Ashish Padhy,Sambhav Gupta,Vishvamsinh Vaghela, and myself,Ashmit JaiSarita Gupta. Their expertise and commitment were instrumental in achieving this exciting upgrade for the AsyncAPI website.What's new on the website?The migration to Next.js v14 and TypeScript brought several significant transformations to the AsyncAPI website. These changes paved the way for a more performant, scalable, and developer-friendly experience.Streamlined Development Workflow:TypeScript integration introduces static typing to the codebase, enhancing code maintainability, reducing errors, and providing better autocompletion. This simplifies the development process and promotes cleaner code.Component Refactoring:Much of the migration involved meticulously refactoring website components within the Next.js framework. This ensures optimal performance and lays the groundwork for future feature development.Improved Testability:Moving to TypeScript also enhances our testing capabilities. Static type checking helps identify potential issues early in the development cycle, leading to a more robust and reliable website.Improved Code Clarity with JSDoc:For developers diving deeper into the codebase, we've added comprehensive JSDoc documentation for all components and their parameters. This documentation clearly explains each component's purpose and function, along with detailed information about the parameters it accepts. This enhanced clarity simplifies understanding of the website's code structure and functionality, making it easier for developers to contribute. This will also help generate proper docs for UI components in the UI Kit, which I am currently developing as a part of my Google Summer of Code project.Enhanced Documentation and Blog Structure:We've introduced a new directory structure to streamline content management and leverage Next.js capabilities. Previously housed in thepages/docsandpages/blogdirectories, our documentation and blog now reside in themarkdown/docsandmarkdown/blogdirectories, respectively. This change allows for better organization and integration with Next.js's built-in features for handling static content.Consistent Code Formatting:We've implemented well-defined Prettier and ESLint rules to enforce consistent code formatting and style across the entire codebase. This not only improves code readability and maintainability but also simplifies collaboration among developers.Improved Static Data Management:Static data that was previously hardcoded directly within components and pages is now housed in dedicateddatafolders. This separation of concerns promotes cleaner code, simplifies maintenance, and facilitates data reusability across the website.Refined Configuration Management:Theconfigfolder now strictly stores configuration-related data. Static data previously stored within the configuration folder has been relocated to thedatafolders.Choosing the Right Framework for the AsyncAPI WebsiteA crucial step in our migration journey was selecting the most suitable framework. Given the current website setup and limited use of server-side rendering, we initially considered React with Vite.js. Vite offers advantages like faster development, improved performance, and a user-friendly development server. However, browser support and a less mature plugin ecosystem presented potential challenges.Next.js emerged as the preferred choice due to its focus on scalability, SEO, and developer experience. Features like server-side rendering (SSR), static site generation (SSG), and automatic routing contribute to these benefits. Additionally, Next.js offers built-in functionalities for image, font, and script optimization, streamlining the development process. While Next.js has a steeper learning curve, its comprehensive feature set and strong community support ultimately aligned best with our vision for the AsyncAPI website's future growth and feature expansion.Planning the Migration: A Stepwise ApproachTo manage the complexity of migrating the AsyncAPI website's codebase, which included various directories like components, pages, scripts, and configurations, we devised a structured plan. This plan involved dividing the codebase into manageable subdirectories, focusing heavily on dependencies between them. Key areas like contexts, utility functions (lib), and Netlify serverless functions required specific attention during the migration process. It's important to note that existing Node.js scripts used for build tasks fell outside the scope of the migration and would be covered in the upcoming GSoC 2024 project:Script Stability Enhancement for AsyncAPI Website. We also updated configurations related to tools like Git, Docker, and Prettier as needed within the TypeScript environment.Our migration strategy involved a meticulously planned, five-phase approach. Each phase tackled crucial aspects of the website's modernization:Basic Setup:This initial phase focused on establishing the new project's infrastructure. We configured a fresh package.json file, managing all dependencies. We set up the Next.js application, integrated Google Analytics and SEO functionalities, and made a production-ready build for deployment on Netlify.Setup Context:The second phase involved establishing contexts for elements like blogs, docs, and the tool filter system.Migrating Components:This was the longest migration phase in which we migrated over 250 components compromising icons, navigation, layout, buttons, dashboard, typography, tools, etc. Additionally, this phase involved the strategic elimination of any redundant components and optimizing the website's overall structure. It took us around the whole of March and April to complete this phase.Migrating Pages:In this phase, we migrated the pages of our website. Since all the components were migrated, this step was easy and quick for us.Final Touches and Launch:In the final step, we migrated Netlify functions, updated the readme, conducted a manual comparison between the old and new websites to address any UI discrepancies, resolved bugs, and took feedback from the community. Finally, we integrated the migrated website onto the main branch and deployed it to production.Challenges we facedNo significant project is without its hurdles, and our migration journey was no exception. Here are some of the challenges that we faced:Challenge:How do you manage PRs that will be opened during the migration?Solution:We tried to merge all PRs to the migrated website instead of the production website. However, the urgent changes were merged into the master branch and then pulled into the migrate-ts branch.Challenge:Handling the redundancy of the same type of specifications in multiple PRs and files.Solution:We decided to have a common types folder and defined all the types inside it that were being used at multiple places.Challenge:Multiple structures of the TypeScirpt components by different team members.Solution:We decided and created a coding guideline to be followed by all team members.Challenge:Encountering usage of alowlightpackage that wasn’t installed as a dependency. More interestingly, there's nothing likelowlight.registerLanguageas per their API docs, which were on the old website.Solution:This was the funniest part; the old codebase usedlowlight.registerLanguage, which was not provided by the lowlight API. We noticed the codebase worked fine withoutlowlight, so we removed every usage.Challenge:Error in rendering custom JSX components inside .md files.Solution:This was the most annoying error that we faced, and it remained unresolved for several weeks. Finally, we all assembled in a huddle call to fight with this and got the solution. It required to be converted into mdx file with proper format. We used prettier and eslint rules to get the proper format after converting all .md files.What’s next?The migration of the AsyncAPI website to Next.js and TypeScript before the start of the Google Summer of Code 2024 coding phase marks a significant step forward. This upgrade unlocks a new era of scalability, streamlined feature implementation, and enhanced developer experience. We're incredibly proud of the collaborative effort that brought this project to fruition, and we extend a heartfelt thank you to our dedicated team and the invaluable community feedback. As we move forward, we're excited to witness the contributions of our Google Summer of Code mentees and the exciting new features they'll bring to life. Vishvamsinh Vaghela will be working on thescript stability enhancement of the websiteand I will be developing aUI kit for the AsyncAPI websiteusing the Storybook and Chromatic. These advancements will streamline future development and elevate the developer experience of the AsyncAPI website. We invite you to explore the revamped website and share your feedback! Your continued support inspires us to continuously improve the AsyncAPI ecosystem. Stay tuned for further updates on our progress!
"""
--------------------------------------------------------------------------------


Post 18
ID: https://www.asyncapi.com/blog/gravitee-annoucement?utm_source=rss
Title: Gravitee Sponsorship Announcement
Link: https://www.asyncapi.com/blog/gravitee-annoucement?utm_source=rss
Summary: Gravitee Sponsorship Announcement
Content:
"""
Gravitee Sponsorship AnnouncementWe are thrilled to announce that Gravitee has joined the AsyncAPI Initiative as a Platinum Sponsor! This partnership marks a significant milestone for our community, promising exciting developments and enhanced support for our growing community.About GraviteeGravitee is a leading open-source API management platform designed to empower organizations with robust API lifecycle management capabilities. Gravitee offers a comprehensive suite of tools, including an API gateway, access management, and an intuitive API designer. These tools help businesses manage their APIs more efficiently, ensuring secure, scalable, and high-performing digital ecosystems. By leveraging Gravitee, companies can accelerate their digital transformation journeys, streamline API workflows, and deliver seamless digital experiences to their users.What This Partnership Means for AsyncAPIGravitee’s sponsorship as a Platinum partner is a testament to their commitment to advancing the open-source ecosystem and supporting innovative API solutions. This support is instrumental in advancing the AsyncAPI initiative. Their expertise in API management will be invaluable as we continue to develop and refine AsyncAPI specifications and tools. This collaboration will enable AsyncAPI to:Enhance Community Support:With Gravitee's backing, we can provide more resources, events, and initiatives to support our vibrant community of developers and contributors. Additionally, Gravitee's Platinum sponsorship includes a generous donation to the AsyncAPI Conf on Tour, further amplifying our reach and impact within the developer community.Expand Educational Initiatives:We will be able to produce more educational content, workshops, and tutorials to help developers harness the power of asynchronous APIs and event-driven architectures.Foster Innovation:This partnership will drive further innovation within the AsyncAPI ecosystem, encouraging the development of new tools and integrations that benefit the entire community.A Heartfelt Thank You to GraviteeWe are profoundly grateful to Gravitee for their continued support and commitment to the AsyncAPI initiative. Their sponsorship is instrumental in advancing our mission to enhance event-driven architectures and make asynchronous APIs more accessible and efficient for developers worldwide. Gravitee plays a vital role in shaping the future of asynchronous API development by joining us as a Platinum Sponsor and contributing to AsyncAPI Conf on Tour.We're excited to have Gravitee.io on board as a Platinum Sponsor, and we look forward to continued collaboration in advancing the AsyncAPI ecosystem!For more information about Gravitee and their API management solutions, visitGravitee.io. To learn more about AsyncAPI and our mission, visitAsyncAPI.
"""
--------------------------------------------------------------------------------


Post 19
ID: https://www.asyncapi.com/blog/2024-april-summary?utm_source=rss
Title: Community Update: April 2024
Link: https://www.asyncapi.com/blog/2024-april-summary?utm_source=rss
Summary: April Community update
Content:
"""
We are excited and commendSpecmaticfor their commitment to supporting open-source projects. They have sponsoredPavel Bodiachevskii, whose project assists in parsing AsyncAPI specs in Java and converting the parsed specs into executable contracts using thejasyncapilibrary. This kind of support is truly invaluable to the community and open-source maintainers. Pleasecheck out the latestjasyncapireleasefor more details.AsyncAPI Conf on TourWe are thrilled to announce that AACoT'24 will return to London this year, andthe Call for Speakers is now open. Start preparing your proposals today, and get ready to join us in September!On an exciting note, we're considering having an online edition sometime this year;please attend the upcoming community meetingfor more context.Spec X ToolingTheAsyncAPI Optimizerhas reached v1.0 thanks to the collaborative efforts ofViacheslav Turovskyi, who has joined as the new maintainer. For breaking changes,check out the release notes.Aklivity, one of the initiative sponsors, is developing Zilla, a multi-protocol service proxy for Kafka that now supports AsyncAPI v3 for configuration and validation. Pleaseread the announcement blogfor more technical details and explorethe Zilla Petstore Kafka API v2 docsorPetstore app demo.In our efforts to improve the contributor experience, we have introduced new help commands:/ptal, which pings reviewers to please take a look at the PR, and/update, which triggers the AsyncAPI bot to update a PR to the latest upstream. We are grateful toPriyansh Mehta,Khuda Dad Nomani, andAshish Padhyfor their contributions.Don't worry if you don't remember all these commands; you can always use the/helpcommand in a pull request, and the AsyncAPI bot will share a list of available commands.Community DiscussionsBelow are some community discussions that require attention.MarketingAfter some weeks of discussing the marketing efforts, we are now looking for someone to fill the role ofCommunity Marketing Specialist. Please have a look at theAsyncAPI Community Marketing Specialist Hiring discussionfor additional context on the role.AsyncAPI Working GroupsWe have a new Conference Coordination Working Group that focuses on planning, managing, and creating a seamless way to enhance the conference experience. If you want to join the working group or read more about their work, please check out theConference Coordination Working Group discussion.TSC x AmbassadorsWe're thrilled to announce a new automated TSC voting system! We want to thankAayush Sainifor working on the implementation, as this will make the voting process smoother, more efficient, and more transparent. With this new system, we hope to encourage greater participation and engagement. Please make sure toread the voting docsto familiarize yourself with the new voting system.Coming in MayAACoT'24 Helsinki- The Helsinki Edition will take place on May 28th and 29th. Please keep an eye out for announcements on community tickets on Slack and our social channels.AsyncAPI Community Updates Newsletter- The May Edition issue will arrive in your inbox this coming week. Ensureyou subscribe to the AsyncAPI Newsletter; you don't want to miss out.
"""
--------------------------------------------------------------------------------


Post 20
ID: https://www.asyncapi.com/blog/2024-Q1-docs-report?utm_source=rss
Title: AsyncAPI Docs Report - Q1 2024
Link: https://www.asyncapi.com/blog/2024-Q1-docs-report?utm_source=rss
Summary: During Q1 2024, AsyncAPI docs had a total of 26,923 sessions and 8,128 unique users.
Content:
"""
AsyncAPI Documentation Report - Q1 2024As a core maintainer of AsyncAPI Docs, I (Quetzalli Writes) volunteer to write periodic updates about the AsyncAPI Docs ecosystem. The goal is to keep the community informed about what's going on in docs and how docs contributors collaborate with other areas in AsyncAPI Initiative.OverviewDuring Q1 2024, AsyncAPI Docs had a total of26,923 sessionsand8,128 unique users. Our tutorials content bucket garnered the highest visitor count, indicating strong engagement. Additionally, our newer content bucket for migrations attracted a notable influx of new users, showcasing promising growth.Content BucketSessionsUnique Users/docs/concepts4,700838/docs/tutorials8,2043,171/docs/tools3,982991/docs/guides909254/docs/reference6,3481,991/docs/migration487122Presented below are the analytics for documentation sections developed during the 2023 Google Season of Docs (GSoD), spanning from December 1, 2023, to March 25, 2024:2023 GSoD projectsSessionsNew Usersconcepts/asyncapi-document2,653449tutorials/getting-started/request-reply455109Top Searches: Algolia AnalyticsWe've identified the most popular searches within the AsyncAPI documentation, as tracked by our Algolia analytics.KafkaandWebSocketare amongst the most frequently searched terms in our documentation.Here are the top 15 queries:RankSearch QueryNumber of Queries1oneof572array563kafka554websocket415enum366type357example358operation339avro3310allof3111schema3012payload2913bindings2814operations2615format262024 Google Season of Docs: ApplicationOur documentation lacks a persona-driven journey for diverse roles, such as documentation contributors, code contributors, ambassadors, maintainers, etc. Consequently, the AsyncAPI onboarding experience is not as efficient as it could be for new contributors, often resulting in onboarding calls being perceived as bottlenecks. To address this issue,AsyncAPI has submitted an application for 2024 Google Season of Docsthat proposes two projects:Onboarding Contributor GuidesandExpand Community Docs.We have also created a newAsyncAPI Slack channel named#temp-gsod-2024that anyone can join for:Mentees identificationMentors identificationIdeas identificationMentees, ideas, and mentors matchingNOTE: Google will publish the list of accepted organizations on April 10, 2024, at 18:00 UTC. Stay tuned for updates!Technical Writer Onboarding GuideIn our efforts to automate the onboarding process for new documentation contributors at AsyncAPI, we've created theAsyncAPI Technical Writer Onboarding Guide and Checklist. The guide is designed to empower new community members with the necessary knowledge and skills to contribute effectively to our documentation. We also believe this guide will encourage greater participation.Outlined in this guide are various workflows and processes, including:Responsibilities of technical writer contributorsOnboarding checklist for technical writersPrerequisite knowledge requiredOverview of the AsyncAPI docs communitySetup and tools necessary for documentation contributionsSteps to open documentation pull requestsGuidelines for creating new documentation directoriesEtc.ConclusionOverall, Q1 showcased continued progress and engagement for AsyncAPI documentation. The documentation witnessed a total of26,923 sessionsand8,128 unique users, indicating consistent interest in our resources. Notably, our Algolia analytics revealed thatKafkaandWebSocketemerged as the most sought-after topics within our documentation, shedding light on key areas of interest for our users.Furthermore, we're excited to announce that AsyncAPI has submitted an application for the 2024 Google Season of Docs. Our proposal outlines two impactful projects:Onboarding Contributor GuidesandExpand Community Docs. These initiatives aim to streamline the onboarding process for new contributors and enhance our community documentation, fostering greater collaboration and knowledge-sharing within the AsyncAPI community.Contribute to AsyncAPI DocumentationTo get started as a docs contributor, follow the steps in theAsyncAPI Technical Writer Onboarding Checklist.
"""
--------------------------------------------------------------------------------


Post 21
ID: https://www.asyncapi.com/blog/2024-march-summary?utm_source=rss
Title: Community Update: March 2024
Link: https://www.asyncapi.com/blog/2024-march-summary?utm_source=rss
Summary: Community update for March
Content:
"""
We are excited to announce and welcome our new Silver sponsor,Aklivity, to the AsyncAPI Initiative.Additionally, we welcome backRedHatback as our Bronze sponsor for 2024. We extend our gratitude toHugo Guerrero, our AsyncAPI Ambassador, for connecting the right people from RedHat.We encourage organizations to support the initiative by getting involved either financially, through employee participation, service provision, or hosting an AsyncAPI event. Please referto our AsyncAPI Financial Summaryfor a detailed breakdown.AsyncAPI Conf on TourThe call for speakers forAACoT'24 Helsinki Editionhas ended, and we will soon add the speakers, agenda, and ticket informationto the AsyncAPI conference website.If you missed the deadline for submitting a talk, we are happy to share that the proposals for AACoT'24 London will soon be open. Be sure to start drafting your proposals and prepare to join us in September.Spec X ToolingIt's been a while since we releasedAsyncAPI v3, and its adoption and support over the past few months have been amazing. We are happy to share some of the projects that are doing cool stuff with v3:MicrocksMicrocksis an open-source cloud-native platform for mocking and testing contracts. It is designed to work in isolation and cut dependencies, making contract testing easier. Microcks supports various protocols, including AsyncAPI, REST, and OpenAPI. It is the first open-source tool under the CNCF Sandbox project to officially support AsyncAPI v3; read all about it in theMicrocks v1.9 release article.Check outthis live demo on Test Containers and AsyncAPI/Kafkato learn more.SpringwolfSpringwolfis an open-source project that streamlines the documentation process for event-driven apps. It focuses on documenting asynchronous APIs using the AsyncAPI v3 specification. With Springwolf, you can easily generate comprehensive API documentation from your codebase by leveraging your application's metadata, such as listener annotations like @KafkaListener, @RabbitListener, and @SqsListener. It also includes springwolf-ui, a user-friendly web interface allowing easy publication of events to document channels.Be sure to test and trySpringwolf's live demo and documentation.Java Code GeneratorWe are excited to share that theJava code generatornow supports AsyncAPI v3 and is the first generator template to support v3. Thanks toDale Laneand other IBM folks for contributing to this milestone in developing AsyncAPI tools.Read how you canAccelerate event-driven projects with AsyncAPI v3for more details.jasyncapiThejasyncapiis a Java code-first tool for the AsyncAPI specification that now supports V3, thanks toPavel Bodiachevskiiand other contributors. Be sure tocheck the latest jasyncapi releasefor breaking changes.AsyncAPI Bounty ProgramWe are excited that the AsyncAPI Bounty Program Q2 is already underway after the success of the first quarter. Though we had one issue that wasn't completed,  it resulted in the participant's suspension until the 3rd quarter; we are happy that the ball is rolling forward.We still have a few issues that haven't been assigned yet. If you are interested, be sure to check theBounty Program Board.Community DiscussionsAsyncAPI Working GroupsAfter officially establishing Working Groups in the initiative, we are happy to share that we now have the following:Developer Experience Working Group. This group aims to empower the AsyncAPI user journey through intuitive onboarding, tools, and a frictionless experience. If you want to join the working group or would like to read more about it, please check out theDeveloper Experience Working Group discussion.Community Growth Working Group. This group's goal is to ensure that the AsyncAPI community grows in a healthy and sustainable way. If you're interested, you can participate by commenting on theCommunity Growth Working Group discussion.Essential Building Blocks Working Group. The goal is to provide fundamental building blocks that enable a similar developer experience across languages such as C#/.NET, Kotlin, Java, Go, Python,  and TypeScript/JavaScript. Anyone can join and contribute by sharing their interest in theEssential Building Blocks Working Group discussion.MarketingWe have started moving forward with the marketing discussion and had a meeting to streamline the work; pleasewatch the marketing recordingorlisten through Spotifyfor more context. One way we are moving forward with the discussion is to create a marketing working group and start inviting experts and sponsors to join us. We have also outlined some recommendations for hiring someone full-time to handle this aspect. If you want to help us with our planned steps or join the efforts, pleaseshare your comments on the Marketing activity discussion.TSC x AmbassadorsWe are excited to welcomeGiri Venkatesan, Developer Advocate at Solace, as the latest addition to theAsyncAPI Ambassadors.Coming in AprilAsyncAPI Community Updates Newsletter- The April Edition issue will drop on the 2nd week. Make sureyou're subscribed to the AsyncAPI Newsletter; you don't want to miss out!
"""
--------------------------------------------------------------------------------


Post 22
ID: https://www.asyncapi.com/blog/2024-february-summary?utm_source=rss
Title: Community Update: February 2024
Link: https://www.asyncapi.com/blog/2024-february-summary?utm_source=rss
Summary: Community update for February
Content:
"""
We are starting the year off with a bang as we got accepted to theGoogle Summer of Code 2024program after two years of rejections. It is an incredible achievement for the community, and we wouldn't have done it without our Doc's Lead,Quetzalli Writes, who crafted an excellent proposal, andElegbede Azeez. We are very excited to have received this opportunity, and you can readthe AsyncAPI Project Ideas Pagefor in-depth details on participating projects.AsyncAPI Conf on Tour 2024The planning of AACoT'24 is already underway as we prepare for our first conference in Helsinki on the 28th - 29th of May. We are putting in the final touches to update our conference website with the latest details, and we will soon announce the Call for Speakers. In the meantime, be sure to start crafting those proposals and get ready to share your expertise with the community.Financial SponsorsWe are thrilled to share that the initiative has secured new sponsors who generously paid for the entire year in advance. We welcomePostmanas a gold sponsor, who contributed $12,000, andHiveMQ, our silver sponsor, who gave $6,000.For more information about our financial budget, pleaserefer to the 2024 Budget discussion.Community DiscussionsWe have important discussions that require the community's attention:Marketing ActivitiesWe need to invest in marketing efforts this year, and as the first initial step, we have secured a budget of $24,000. The next step now is to find a workaround to achieve this goal. If you have experience or have insights on how we can spend and efficiently boost our marketing aspects, pleasejoin the Marketing Activities discussion.Doc's Project Ideas for GSoD'24Google Season of Docs 2024 is now open, and we plan to participate again this year. We are currently gathering project proposals for our application, and if you have ideas on areas we should improve or focus on in our documentation, pleasepropose new docs project ideas in the community discussion.Sovereign Tech Fund ApplicationTheSovereign Tech Fundis opening its applications for open-source organizations in Q2. We have some ideas and areas we should focus on for the application, such as CI/CD infrastructure. Be sure tojoin the Sovereign Tech Fund discussionif you want to collaborate or share application ideas.Code of Conduct Draft UpdateThe AsyncAPI Code of Conduct Committee is halfway through updating the current Code of Conduct to the latest version. They have created some documents that explain the procedures and guidelines that the CoC Committee will use to enforce the Code of Conduct. You can glimpsethe updated Code of Conduct draft by checking the work-in-progress pull requests.Cupid is Looking For MaintainersWe're on the lookout for maintainers for the AsyncAPI Cupid. The library focuses on finding and analyzing the relationships between AsyncAPI documents. If you're well-versed in Event-Driven Architecture and AsyncAPI, pleasejoin the Cupid repository discussionand help us drive its development.AsyncAPI Working GroupsWe are finally officializing working groups throughout the AsyncAPI community. A working group will be a community where people share similar interests beyond GitHub repositories. You can read theWorking Groups docsor view theWorking Group public discussionfor more comprehensive details.TSC Members x AmbassadorsWe are excited to welcome five newTechnical Steering Committee(TSC) members.Ashish PadhyAshmit JaiSarita GuptaPrince RajpootSambhav GuptaSamir AMZANIAdditionally, we have a new addition to theAsyncAPI Ambassadorsteam, raising the number to seven.Iván García Sainz-AjaExciting times for our growing community!Coming in MarchAACoT'24 Helsinki Call for Speakers- We will announce our Call for Speakers for AACoT'24 Helsinki by the first week of March. Start crafting those proposals and get ready to submit them.AsyncAPI Community Updates Newsletter- The March Edition issue will drop on the 6th. Make sureyou're subscribed to the AsyncAPI Newsletter; you don't want to miss out!
"""
--------------------------------------------------------------------------------


Post 23
ID: https://www.asyncapi.com/blog/2023-summary?utm_source=rss
Title: Annual Review: State of AsyncAPI Initiative 2023
Link: https://www.asyncapi.com/blog/2023-summary?utm_source=rss
Summary: 2023 Year in Review
Content:
"""
It's almost unbelievable that we are in 2024. And if you are reading this, Happy New Year to you and your loved ones. Continuing the tradition, we look at how the community has grown over the last 365 days and look forward to our next phase.If you are curious about our past achievements, pleaseread the previous 2022 AsyncAPI summary.Community MetricsWhat better way to reflect on the past year than with numbers? Data is the most significant way to gauge our growth and measure our visible impact as an open-source community.SlackAs of 2024, we are currently at an overall total of4,471members in the AsyncAPI workspace. The Slack workspace is our primary communication medium, from updates to helping contributors and new adopters onboard with the AsyncAPI spec and tools.In 2023, we had 1488 people joining our workspace:Below are our top 5 members who joined the community in 2023 and have been the most active among other newcomers. As a community, we are proud of their contributions to our Mentorship programs. They even keep us entertained with memes😀.Additionally, our weekly activity continues to grow as we run different mentorship programs and initiatives that bring traction to our community.Social MediaWe use social media to communicate news and updates around our community. We don't use it for marketing.And honestly, I didn't invest much when it came to socials, so don't expect big big numbers😝Let's dive into the data:LinkedInFor our LinkedIn page, we are currently sitting at2988overall followers. During 2023, we gained a total of849followers since 2022.We also don't use any premium or marketing services; everything you see here is 100% organic. Even though LinkedIn still has much to offer, it is better than the X/Twitter app.X/TwitterWe gained almost 1K followers since 2022, and now have 4.4k overall followers. When it comes to website referrals via Twitter, we have seen a decline compared to last year, 2022Although the decline is shallow, I'm not extremely worried. Most top tweets for this year were appreciation tweets balanced with technical tweets. We don't use advertising because we don't consider the X/Twitter platform worth additional investment.YouTubeThe AsyncAPI YouTube channel performed way better than expected, especially as we moved from online to in-person conferences. We currently have over 364 people subscribed to our channel, increasing total subscribers to over 1.46k. Our live streams and conference recordings bring in a lot of views, leaving us optimistic for 2024.NewsletterOn the 5th of April, 2023, we sent out our first AsyncAPI Community Updates Newsletter. The main aim was to summarize monthly community activities/initiatives straight to your inbox.
Over the past nine months, the December Edition was the most popular due to the release of the AsyncAPI v3 (one of our major accomplishments in 2023).And, of course, I'm not exempt from unsubscribers. Although the number might seem minimal to some, it still stings as a writer.Looking forward to sending the 2024 Editions!!🎉🎉Google AnalyticsAsyncAPI website sessions and unique user have increased significantly over the past year. Our major contributor to these metrics comes from docs, and we expect to see more in the coming year as people want to know more about the AsyncAPI v3.We also lost 21 days' worth of data during October due to a PR update that affected the analytics workflow, but we are doing well.Google Search ConsoleGoogle Search Console is one of my favorite tools as it shows how much impact and interest we are gaining. Compared to 2022, we can see a surge in impressions and clicks.GithubThe number of contributors in the community keeps growing, from having over1600contributors in 2022 to2320contributors in 2023.Although we have a handful of maintainers, we try our best to manage, resolve, and close issues as much as we can. Additionally, we are focusing on growing the number of maintainers in the coming years.NPMNumbers don't lie; and yes, these are the total downloads of the top AsyncAPI packages hosted in the Node Package Manager. We can also see the adoption of AsyncAPI spec downloads increased from 5M to 17M since 2022.If you are worried about the project slowing down anytime soon, we are still growing strong.Community AchievementsWe achieved so much this year, and here are some of the highlights from the AsyncAPI community in 2023!We had our first community hire,Thulisile Sibanda, to work full-time as the project's Community Manager.Lukasz Gornickiwent from Community Guardian to Executive Director (boss moves right there😂😂). And yes, he's planning to get rid of the title soon.TheAmbassador Programincreased this year from having 3 ambassadors to 5.We launched the AsyncAPI Community Updates newsletter.Released theParser-JS v2.We launched theAsyncAPI Bounty Program, where we successfully resolved and paid out a total of 11 out of 16 issues during the initial trial and 2023 Q4 round.Established our very firstAsyncAPI Code of Conduct Committee.Barbaño González shared a detailed article onWhy Women Are Underrepresented In Open-Source.Participated inGSoC'23andGSoD'23, while kickstarting theAsyncAPI Mentorship Program II.Held our first in-personAsyncAPI Conference on Tourin London, Madrid, Bangalore and Paris.Released theAsyncAPI v3.Launched theAsyncAPI Store.We hope you enjoyed a glimpse into our 2023 highlights; we have even more planned for 2024! Learn about our2024 AsyncAPI Community Building Goals.
"""
--------------------------------------------------------------------------------


Post 24
ID: https://www.asyncapi.com/blog/conference-2023?utm_source=rss
Title: AsyncAPI Conference on Tour 2023 Report
Link: https://www.asyncapi.com/blog/conference-2023?utm_source=rss
Summary: In 2023, we hosted our very first in-person conference edition. Find out how it all went down!
Content:
"""
For three consecutive years, we have hosted online conferences, and in 2023, we decided to take it up a notch and move to in-person events.
The idea was to have aconference tour with micro meetups in different cities, giving birth to the brandAsyncAPI Conf on Tour (AACoT).Now imagine this: planning the very first AsyncAPI in-person conference by someone organizing an event for the first time; you would wonder what kind of faith the community had in me.
Being part of AACoT'23 was an adventurous, bumpy ride that came with valuable lessons.The Planning ProcessWe initially envisioned having five meetups per continent. For people who started the conference planning late, you would think we were being too optimistic.
At the end of the year, we managed to accommodate and have four confirmed locations.So much had to be put in place, like updating the conference website, starting with the marketing, creating announcements, doing calls for speakers, etc. We had to think on our feet most of the time.ChallengesOur biggest challenge of all was that the AACoT'23 planning started late. This meant that for every decision and effort we made, we were dashing against the clock.Planning and marketing were complex since most venues were confirmed a few weeks before the summer holidays.In terms of promoting the events, we had some challenges in certain locations as we expected some support in this regard. This would have helped boost the event's visibility, but we were partly at fault since this wasn't communicated prior.Sometimes, free things can be costly! All the conference tickets were free. Of as many those who redeemed free tickets through Open Collective, only less than 50% showed up. It was very discouraging as food and resources that could have catered for everyone went to waste.There was no time to rest between the events as they all happened one after the other.We didn't have a sponsorship budget. By the time we thought about this, it was way too late.LessonsTime and money are essential! When it comes to building a brand and conference planning.
I can't over-emphasize the importance of early planning, as we have seen in the past year, which we will prioritize for AACoT'24.Firstly, having open communication and fostering strong partnerships with our sponsors is undeniable. Before we agree and confirm the location, each venue must meet our community's minimum requirements, especially regarding support in marketing and participation in the planning process.Secondly, open up sponsorship tiers for companies and individuals who want to support us. Running AACoT requires a lot of funds, especially when it comes to swag costs, shipping, and going further to provide travel scholarships to community members who would like to participate. So, having a separate budget for AACoT is very crucial in this regard.Lastly, spacing all the conferences this year. Instead of what happened in 2023, where we had all meetups lined up a few weeks apart from each other, in 2024, we plan to have one conference each quarter. Additionally, this will give people time to prepare and plan to travel.AttendanceThough you may have an idea of how the attendance went, the best takeaway is that we had time to network, connect, and learn during the conferences.
Being our first year, we did fairly well regarding attendance numbers. We had 225+ individuals who attended in person, and two of our events were live-streamed, receiving over 820+ views.In addition, during our time in Paris, we also organized anAPI Specs and Standardsbooth, where we held discussions with people from the API world while promoting the conference.Who Made AACoT'23 PossibleAACoT'23 was only possible with our Event Hosts and Sponsors. These organizations provided a venue to host the conference and sponsored us lunch, breakfast, and refreshments; some even provided live stream coverage for those who couldn't attend.We are truly grateful to them for their contributions!SpeakersWhat is a conference without our star speakers? These individuals took time out of their busy schedules to share their expertise.
They provided valuable industry insights, and we are proud of the network we built during the events.You can also catch up on the live recording fromAACoT'23 MadridandAACoT'23 Bangalore.Special Shout-OutI want to express my gratitude to these individuals and many others for their unwavering dedication in assisting with AACoT'23 behind the scenes.
They contributed to the design of website prototypes, conference design implementation, creating promotional videos, reviewing Call for Papers (CfPs), editing conference recordings, and providing constant communication and support. I am genuinely thankful for their hard work and commitment.Aishat MuibudeenLukasz GornickiAzeez ElegbedeBarbanio GonzálezIván García Sainz-AjaDale LaneSouvik DeKaruna TataJonas LagoniFlorence NjeriWhere To Next?As we plan for AACoT'24, we are excited to announce thatAPIdayswill be hosting us in Helsinki on May 28-29th, London on September 17-18th, and Paris on December 3-5th.
Additionally, we are exploring the possibility of holding the event in Lagos in early Q2 or later.If you are interested in sponsoring AACoT'24, we welcome financial sponsors or event and host sponsors.You can check out ourOpen Collective Pageto see the current sponsorship tiers ordownload our conference sponsorship prospectusfor more information.
"""
--------------------------------------------------------------------------------


Post 25
ID: https://www.asyncapi.com/blog/2023-Q4-docs-report?utm_source=rss
Title: AsyncAPI Docs Report - Q4 2023
Link: https://www.asyncapi.com/blog/2023-Q4-docs-report?utm_source=rss
Summary: In Q4, AsyncAPI docs had primary engagement across the tutorials and reference content buckets.
Content:
"""
AsyncAPI Documentation Report - Q4 2023As a core maintainer of AsyncAPI Docs, I (Quetzalli Writes) volunteer to write periodic updates about the AsyncAPI Docs ecosystem. The goal is to keep the community informed about what's going on in docs and how docs contributors collaborate with other areas in AsyncAPI Initiative.OverviewDuring Q4 2023, AsyncAPI Docs had a total of19,267 sessionsand6,447 unique users.The successful contributions from the2023 Google Season of Docsand the2023 Technical Writing Mentorship Program, made significant strides in documenting the intricacies of the new Spec 3 and its enhanced features.Sessions percontent bucket:/docs/concepts:1,861 sessionswith286 unique users./docs/tutorials:5,528 sessionswith2,139 unique users./docs/tools:2,492 sessionswith665 unique users./docs/guides:523 sessionswith167 unique users./docs/reference:6,834 sessionswith2,629 unique users.Google Season of Docs 2023 (GSoD)AsyncAPI was accepted into Google Season of Docs 2023 for two projects:documenting the AsyncAPI document in detailandcreate a 100-level interactive learning path. We received a total budget of $10,350.Project 1: AsyncAPI document structureOur first identified challenge involved updating the documentation for the structure of an AsyncAPI document to align with the latest specification, version 3.0.0. The new version introduces numerous changes and features, necessitating a revision of the configuration guidelines for AsyncAPI documents. To facilitate easier implementation of Event-Driven Architectures (EDAs), our documentation needs to provide more comprehensive explanations of the different sections within an AsyncAPI document. We've introduced a dedicated/AsyncAPI-documentsubdirectory within theConceptsarea. That new section delves into the structure of an AsyncAPI document, with each component meticulously detailed on its own page.Project 2: Create a 100-level interactive learning pathThe second challenge we've addressed is launching a beginner-friendly, 100-level introduction to AsyncAPI. Our new interactive learning path is enhanced with engaging e-characters and a creative storyline, employing creative metaphors to effectively convey technical concepts. That new interactive educational resource will soon be available on ourAsyncAPI Killercoda profile. To support this initiative, we've established a dedicated repository for interactive learning content athttps://github.com/asyncapi/learning-paths.Our new interactive learning path features a narrative where theAsyncAPI mascot Eve assists Chanin repairing his spaceship following an unexpected crash in Eve's backyard. Throughout this journey, various API concepts are elucidated using the engaging theme of fixing Chan's spaceship. In"Module 1: Introduction to AsyncAPI,"Chan's spaceship crash lands in Eve's backyard, serving as a backdrop to explore AsyncAPI, its usage, and real-world applications. The story progresses to"Module 2: Event-Driven Architectures,"where Eve examines the spaceship's engine, introducing event-driven systems and their design using AsyncAPI, particularly for microservices. The"Module 3: AsyncAPI Specification"sees Eve helping Chan program his spaceship, delving into the AsyncAPI document structure, including its various components like info, channels, and schemas. The narrative continues with"Module 4: Creating and Validating AsyncAPI Code and Documents,"where Chan returns to his planet to test communications with Eve, focusing on writing, validating, and hands-on exercises for AsyncAPI documents. The journey concludes with Module 5, a summary of the learning outcomes, a teaser about checking AsyncAPI tools, and a link back to the documentation.AsyncAPI 2023 Mentorship Program -technical writingcategoryIn the AsyncAPI 2023 Mentorship Program, thetechnical writingcategory started documenting how the Kafka and Websocket protocols work with AsyncAPI. We also detailed different kinds of schemas to manage with AsyncAPI.The below table lists sample topics covered:Kafka with AsyncAPIWebSockets with AsyncAPICreate AsyncAPI document for app interacting with KafkaTutorial for WebSockets with AsyncAPIKafka Specific BindingsTutorial for Request Reply using WebSocketsSpec 3.0 DocsAll AsyncAPI docs now align with the latest specification, version 3.0.0. The new version introduces numerous changes and features, necessitating a complete revision of the docs. The newrequest/replyfeature from version 3 has been comprehensively documented, enriching both ourConceptsandTutorialssections.ConclusionOverall, Q4 showed a period of significant growth and achievement for AsyncAPI Docs. The data speaks volumes: with a total of 19,267 sessions and 6,447 unique users, with primary engagement across the/tutorialsand/referencecontent buckets.We enhanced our documentation to align with Spec 3.0.0, introduced a dedicated/AsyncAPI-documentsubdirectory within theConceptsarea, and created an innovative, interactive 100-level learning path stand. These additions not only provided in-depth knowledge of the new Spec 3.0.0 but also made learning more engaging and accessible to our community. Moreover, our focused efforts in documenting specific protocols like Kafka and WebSockets under the Mentorship Program further diversified and strengthened our content offerings.Overall, Q4 2023 was a testament to our commitment to delivering high-quality, relevant, and community-friendly documentation, setting a strong foundation for continued growth and innovation in the coming year.How to contribute to AsyncAPI DocsDid you know that you can contribute Docs to AsyncAPI as well?Code isn't the only way to contribute to OSS; Dev Docs are ahugehelp that benefit the entire OSS ecosystem. At AsyncAPI, we value Doc contributions as much as every other type of contribution.❤️To get started as a Docs contributor:Familiarize yourself with ourproject's Contribution Guideand ourCode of Conduct.Head over to ourAsyncAPI Docs Board.Pick an issue you would like to contribute to and leave a comment introducing yourself. This is also the perfect place to leave any questions you may have on how to get started.If there is no work done in that Docs issue yet, feel free to open a PR and get started!Docs contributor questionsDo you have a documentation contributor question and you're wondering how to tag me into a GitHub discussion or PR? Never fear!Tag me in your AsyncAPI Doc PRs orGitHub Discussionsvia my GitHub handle,quetzalliwrites🐙.Talk to meI want and need to listen👂🏽to all of your perspectives and ideas. Please don't be shy to express to me what you think needs to be documented first or what is missing.📝There's a lot of good work ahead, butyoudetermineour content roadmapbecause the OSS community needs should always come first.✨
"""
--------------------------------------------------------------------------------


Post 26
ID: https://www.asyncapi.com/blog/introduction-to-glee-a-spec-first-framework?utm_source=rss
Title: An Introduction to Glee
Link: https://www.asyncapi.com/blog/introduction-to-glee-a-spec-first-framework?utm_source=rss
Summary: Glee is a powerful spec-first framework that streamlines the building of server-side applications. By integrating your code with the spec, Glee takes care of the heavy lifting involved in creating and managing connections, allowing you to focus on the business logic that truly matters.
Content:
"""
For the last year, I have been working full-time on AsyncAPI, where I have actively taken part in building a new framework calledGlee. This is the first of many blogs to come where I will be talking about Glee and all the cool stuff we can build with it. In this blog, I will introduce Glee and give a broad overview of how to get started and keep up with Glee's development.IntroductionGleeis a powerful spec-first framework that streamlines the process of building server-side applications. By integrating your code with the spec, Glee takes care of the heavy lifting involved in creating and managing connections, allowing you to focus on the business logic that truly matters.It makes sure your code, specification, and documentation are synchronized. Glee eliminates the possibility of straying from the spec, which compels you to embrace a spec-first methodology, ensuring that your API is always entirely defined and coherent. When your API evolves, it includes the specification and documentation.Glee simplifies creating and maintaining connections, allowing you to concentrate solely on developing code that meets your business needs. By handling performance, scalability, resilience, and all other aspects necessary for production readiness, Glee frees you from the burden of managing these technicalities, enabling you to focus on delivering a high-quality application that meets the demands of your users.Getting Started With GleeLet's create a simple WebSocket API using Glee to understand its magic. We will create a simple WebSocket server that receives a current time from the client and then sends a "good morning," "good evening," or "good night," respectively.Setting Up A Glee Project.To work with Glee, you must install NPM and NodeJS version 10 or higher. You can just run the following commands in your terminal to check if you have both installed.1# check if node is installed2node -v3# or4node --version56# check if NPM is installed7npm -v8# or9npm --version10If you don't have any of the above tools missing, go ahead and install them.Create a Glee projectWe recommend creating a new Glee app using our officialCLI, which sets up everything automatically. (You don't need to create an empty directory, create-glee-app will make one for you.) To create a project, run:12asyncapi new glee3To install AsyncAPI CLI either usenpmor install binaries for your operating system fromhttps://github.com/asyncapi/cli/releasesOnce the process is complete, you should have a new Glee app ready for development and see these files that were made.Define The Spec For Our API.Glee being a spec-first framework, development starts with defining your API spec. For our case, we will define our API:1asyncapi:3.0.02info:3title:GreetBot4version:0.1.05servers:6websockets:7host:'0.0.0.0:3000'8protocol:ws9channels:10greet:11address:greet12messages:13onGreet.message:14$ref:'#/components/messages/time'15subscribe.message:16$ref:'#/components/messages/greet'17operations:18onGreet:# operationId19action:receive20channel:21$ref:'#/channels/greet'22messages:23-$ref:'#/components/messages/time'24greet.subscribe:25action:send26channel:27$ref:'#/channels/greet'28messages:29-$ref:'#/components/messages/greet'30components:31messages:32time:33payload:34type:object35properties:36currentTime:37type:number38name:39type:string40greet:41payload:42type:stringThis will be the specification that defines our API. In our case, it is very simple, as we will send a name and the time of the day, and our API will greet us accordingly.One thing to note here is theoperationId; this is needed and is a crucial part of Glee, as this is how we will be connecting our business logic with our spec,operationIdis the name of the function that will be called every time a certain operation occurs. In our case, whenever the/greetchannel received a message.Define Our Operation Function.Now for our case, we will add a filefunctions/onGreet.jsand write up the logic for parsing our time and sending a response.1exportdefaultasyncfunction(event){2const{ name, time } = event.payload3constt =newDate(time)4constcurHr = t.getHours()5letresponse =''6if(curHr <12) {7response =`Good Morning${name}`8}elseif(curHr <18) {9response =`Good Afternoon${name}`10}else{11response =`Good Evening${name}`12}13return{14reply: [15{16payload: response,17},18],19}20}Every file in the functions folder acts as a handler to develop business logic for Glee. Each file should export an async function that receives an event parameter, where you have access to payload and server details.Running And Testing Your ApplicationWe will not execute the application and carry out testing with Postman to ensure that it is functioning as intended.Now to run your Glee application, just execute the following:1npm run dev2# or3npm run startThen open Postman and checkout the endpoint:ConclusionSo this is how easy it is to build a WebSocket API using Glee.  Please do check outthe Greet-Bot example code.Glee is rapidly evolving and aims to support a variety of protocols, and while it is still in development, it currently has stable support for MQTT and WebSocket. As a team, we are eager to gather feedback from users like you to help us improve Glee and make it even better. If you are interested in trying out Glee, we would greatly appreciate it if you could test it out and share your thoughts about your experience. Your feedback will be invaluable in helping us identify areas for improvement and making Glee more user-friendly and effective. The best way to communicate with us is throughGitHub Issues.
"""
--------------------------------------------------------------------------------


Post 27
ID: https://www.asyncapi.com/blog/designblog?utm_source=rss
Title: Contributing to Open Source as a Product Design and UX Researcher
Link: https://www.asyncapi.com/blog/designblog?utm_source=rss
Summary: Design BlogPost
Content:
"""
Every software has a design system, regardless of whether it is free or not. Suppose you are a UX researcher or designer intending to be part of an Open Source community. In that case, you can begin contributing to the research or design program by collaborating with others. This article clarifies what Open Source is and provides tips on how you can start contributing as a UX researcher or designer. In addition, I’ll share some Open Source communities that you can contribute to as a beginner.What is Open Source?public/img/posts/oss_image.webpOpen Source Software (OSS) refers to software shared with its source code, allowing users to access, modify, and distribute. OSS allows everyone to contribute to the source code, make changes, or suggest new features. You can use the code for your purpose or contribute to improving the entire project’s features.Some examples of Open Source Software are available, including AsyncAPI, Linux Kernel, Oppia Foundation, VLC Media Player, Mozilla Firefox, Audacity, Blender, and more. These software are free to download, use, and distribute. It’s essential to recognize that some individuals put in much effort to make these projects available to a broad audience. Pursuing a career in Open Source can be beneficial, as it allows you to give back to the community and assist as many users as possible.It is worth noting that not all open-source projects are free of charge. To determine whether a project is free, you can check the project’s LICENSE file on GitHub.My Experience as a Product Designer and UX Researcher in Open SourceIf you want to move faster in your career, I suggest getting started contributing to Open Source projects as early as possible. As a UX personnel, working with dummy users without getting feedback can be frustrating. However, Open Source allows you to learn your expertise and receive real-time feedback from users. Additionally, the collaborative nature of Open Source provides real-life working environments.In late 2022, I made my first Open Source contribution by designing speaker cards for the AsyncAPI Virtual Conference. When I received a notification that my pull request had been merged, I felt a sense of fulfillment about seeing my work showcased on a global scene.My interest in Open Source Communities made me apply for the Outreachy Internship Program. My collaboration and research skills helped me get into the program. I worked on the Foundational Research for Nigeria, a research project created to understand the learning needs and problems associated with technology learning among children between the ages of 7 and 15 in Nigeria. I also conducted usability testing with Oppia users to evaluate the effectiveness and usability of the Oppia application and website platform.Since completing my Internship Program in March, I have worked on other open-source projects.Completed ProjectsDesigned the AsyncAPI Conference on Tour 2023 website (AACoT’23).Conducted a UX Design Audit on the AsyncAPI Website.Designed the AsyncAPI Financial Summary Page.Designed the Community Member’s Page for AsyncAPI.I worked with my team to design and create content for the Ladder Library as part of She Code Africa HackFest 2022.On-going ProjectsWorking on the Design system for the AsyncAPI website.Creating a UX research plan for usability testing.Reviewing all design and research-related issues.What are the advantages of contributing?There are numerous benefits to contributing to open source. One of the most prominent reasons is collaboration. For beginners and experienced fellows, collaborating using a version control system is an added advantage to your career. Getting hired based on your open-source contribution and contributing to technologies that make your life better and more accessible.
Finally, open source is time-consuming and can become overwhelming if you do not manage your time.Are you ready to start contributing?Check if the applications you frequently use are Open Source and consider joining their communities. You can ask questions, solve issues, and offer assistance to others. Many communities offer issues that are suitable for beginners who are new to open source.
"""
--------------------------------------------------------------------------------


Post 28
ID: https://www.asyncapi.com/blog/september-2023?utm_source=rss
Title: Community Update: September & October 2023
Link: https://www.asyncapi.com/blog/september-2023?utm_source=rss
Summary: September and October Community Update
Content:
"""
Our second AsyncAPI Conf on Tour took place on the 19th of October, hosted by SNGULAR in Madrid. The day was well-organized, packed with informative talks from industry experts and great networking sessions, making it a valuable experience for attendees. Additionally, the conference was live-streamed, and every session was recorded, so even if you missed out on attending the event in person, you can stillwatch the recordings on YouTubeand catch up on all the insightful talks.
Our gratitude goes toIvan Garcia Sainz-Ajafor helping us bring SNGULAR on board, plan, and host the event.AACoT'23 Bangalore EditionWe're excited that AACoT'23 is heading to Bangalore next on the 30th of November, and Postman will be hosting us. Our full-day agenda will be live soon on theAsyncAPI conference website, and we have excellent sessions and fantastic speakers lined up.
If you know someone or are interested in joining us in person,get your ticketsand get ready to learn more about EDAs and experience the culture in Bangalore. We can't wait to see everyone there!Spec x ToolingSergio Moya,Peter Ramos, and the team are currently working on measuring the AsyncAPI adoption by collecting metrics through the usage of our tools. If you are interested in participating or following up on the progress, you can join the public discussion onMeasuring AsyncAPI Adoption.We're excited to share that we have successfully migrated Modelina from v1 to v2. The new version will focus more on creating accurate array types. For more information, please check out theModelina v2 migration guide.Mentorship ProgramThe first evaluation for the 2nd cohort of the AsyncAPI Mentorship Program just concluded, and we are happy thatall the mentees participatingare doing well in their projects. They are now eligible to request the first half of their stipend bysubmitting an expense through Open Collective. We are proud and can't wait for the final results.AsyncAPI Bounty ProgramAfter a successful trial, we are happy that the official AsyncAPI Bounty Program is in full swing. The program will be run by three outstanding individuals,Viacheslav Turovskyi,Aishat Muibudeen, andAbir Pal, who will ensure the rules are correctly implemented and oversee the smooth running of the program.In Case You Missed ItMissed the live streaming of AACoT'23 Madrid? Don't fret! Catch up on all the sessions by watching the recordings.Coming in NovemberAsyncAPI Community Updates Newsletter- The next issue will drop on the 9th of November. Make sure tosubscribe to the AsyncAPI Newsletter.AACoT'23 Bangalore Edition- Our next stop for AACoT'23 will be held at thePostman Bangalore officeon the 30th of November.Be sure to get your ticketsto join us. See you there!
"""
--------------------------------------------------------------------------------


Post 29
ID: https://www.asyncapi.com/blog/beyond-boundaries?utm_source=rss
Title: Beyond Boundaries - Empowering Through OSS Mentorship
Link: https://www.asyncapi.com/blog/beyond-boundaries?utm_source=rss
Summary: In 2022 we piloted our innovative mentorship program that focuses on open-source software(OSS). We envisioned a platform where aspiring developers could learn, grow, and contribute to exciting project
Content:
"""
In 2022 we piloted our innovative mentorship program that focuses on open-source software(OSS). We envisioned a platform where aspiring developers could learn, grow, and contribute to exciting projects while receiving guidance from experienced mentors.Our BackstoryAt AsyncAPI, we value giving back to the community, giving us a sense of purpose as a community-first organization. We are always looking for ways to participate in open-source mentorship programs like Google Summer of Code(GSoC), Google Season of Docs(GSoD), and more because the fulfilling feeling of contributing to society gotten from these programs is unparalleled.As an open-source organization, we participate to collaborate with a broader reach of enthusiasts and help bring more folks into this world(which we are already doing). Furthermore, our reason for participating in these programs comes from our passion for open source and the care to support and encourage contributors by building and participating in mentorships.Why Start Our Own OSS Mentorship Program?In 2021, AsyncAPI participated in its first paid mentorship program alongside Postman under Google Summer Of Code(GSoC). After applying to participate as an organization for GSoC in 2021, we got rejected and were opportune to participate alongside Postman.Postman is an established software development company committed to open-source initiatives. We received a lot of engagement from folks interested in our projects despite having just a few slots allocated to us by Postman.Fast forward to 2022, we applied for GSoC and got rejected again. This time, Postman also got rejected, leaving us in shock because many folks were already looking forward to joining us. The shock and disappointment permeated the team's spirits, but they refused to let this setback deter them from their mission.Determined to overcome this unexpected obstacle, we regrouped and brainstormed alternative strategies to keep the program afloat. What had initially seemed like a devastating rejection transformed into an opportunity for growth and resilience. The team's unwavering passion and refusal to accept defeat turned their setback into a stepping stone toward even greater success.The Journey Proved To Be More Challenging Than AnticipatedWe knew piloting an in-house mentorship program would be challenging, so we made the initial program a way to collect feedback. We approached the program flexibly, avoiding rigid decisions or commitments.During the project ideas phase,we received 19 project ideas, andten of these projects made it to the final phasebut out of the ten selected candidates for the program onlysixwere able to complete their project. This program addresses the real needs of the open-source community. It ensures the program leaders forge meaningful relationships with the participants to ensure their diverse voices are heard and provide them with resources, advice, and networking opportunities.How We Are Approaching These Challenges For The Next CohortsAt AsyncAPI, mentorship programs are practical tools for teaching and upskilling professionals. When managed well, they can create significant benefits for mentees and lasting benefits and impact for mentors. However, we know it takes some strategy and finesse to operate a mentorship program that lasts and reaches its potential. That's why we've organized a way to keep our Mentees on schedule to complete their projects using the following method:Reduce the level of stress in the program.Encourage them to ask when they need help.Ask them what they want.Connect often.Share stories and struggles.Agree on expectations.Emphasize good self-care.Our Relationship With Potential MentorsAll of AsyncAPI's mentors are core community members and prominent advocates for open-source projects with a strong belief in FOSS, which means keeping them engaged will require just a little effort. But we still keep them engaged by staying connected and ensuring communication channels go both ways, showing how they made a difference and valuing the opinions of every mentor.How We Engage Contributors In The Community During The Mentorship ProgramWe value every single contribution at AsyncAPI, and there is a nearly immediate value to people using and contributing to AsyncAPI. If and when they contribute code, the quicker it gets integrated into the main codebase, the happier the contributor will be. We also know contributors like to be challenged and to learn new things, and they like to work on code that's known to be of high quality and work with projects that positively impact the industry.This quality makes AsyncAPI stand out and will encourage contributors to be involved in the community during the program. Furthermore, we ensure contributors are heard and respected and give them public credit for their work to encourage them to contribute. We ensure contributors have direct access to the main maintainer(s) and can have meaningful discussions with them.Where Are We?With the next cohort kicking off, we put things such as the [program guidline] in place, including theEvaluation Period. And we received a significant surge in this current cohort(2023) application phase! We received 29 project ideas, 10 of which were selected for the program, over 90+ proposals were received across all of these ten projects, and 13 candidates made it to the final selection phase. Unlike the previous year(2022), we were not only accepting code-related projects but also design and technical writing, which means anyone can be a part of the program this year.Comparing this to the previous year, we are proud of this current trajectory and can't wait to see the numbers for the coming years, how much growth awaits us as a community, and how fantastic the projects under this great initiative will become with all of these contributions.Current Cohort ProjectsNoProject IdeaMentor/sCategoryMentee/s1Add help/{command} endpointDavid PereiraEngineeringPrince Rajpoot2Website UI Kit design/dev projectAceTheCreatorDesignAISHAT MUIBUDEEN3MVP integration of extensions catalog with AsyncAPI toolsLukasz GornickiEngineeringSambhav Gupta4Documenting how different protocols work with AsyncAPIQuetzalli WritesDocumentationCynthia Peter,Arya Gupta,Joy Almeida,Vaishnavi Nandakumar5Rewrite this template and NodeJS WS templateLukasz GornickiEngineeringKaushik Rishi6Simulator Desktop ApplicationNektarios FifesEngineeringSumant Tirkey7Tutorial document or separate guides for gleeSouvik&Khuda Dad NomaniDocumentationAfzal Ansari8Add support for translationsMaciej UrbańczykEngineeringAnsh Goyal9Prepare CLI for v1.0.0 releaseSouvikEngineeringAshish Padhy10DocsUI: Messages Object outputMissy Turco&Fran MéndezDesignAsmit MalakannawarWho Is This Program For?If you're new to the world of open-source or you'd love to get paid for doing open-source for some time, then this program is definitely for you.Would you be interested in sponsoring our program?By sponsoring us, we can use your sponsorship funds to provide more slots in future mentorship programs for candidates interested in elevating their careers via open-source contributions.How To Connect With UsJoinour Slack workspace. Just make sure to follow ourSlack etiquetteandthe code of conduct.Join the dedicated Mentorship channel#mentorshipsthat we use for all mentorships discussion. All mentees and mentors are there.Photo byRachelonUnsplash
"""
--------------------------------------------------------------------------------


Post 30
ID: https://www.asyncapi.com/blog/august-2023?utm_source=rss
Title: Community Update: August 2023
Link: https://www.asyncapi.com/blog/august-2023?utm_source=rss
Summary: August Community Update
Content:
"""
As August comes to a close, many of us have had a slow month. Most of the community took some well-deserved time off, and the project has been quiet these past few weeks. We're looking forward to September and can't wait for everything to get back in full swing.AACoT'23 LondonSpeakers for AACoT'23 London Edition have been selected and informed; we are currently working on the schedule for the day. We anticipate a jam-packed day of inspiring talks and networking with esteemed industry experts. If you know any communities in London or ways we can maximize the AACoT'23 London event happening on the 20th of September, please do reach out toThulieorLukaszvia Slack.Financial ContributionsWe received new financial contributions this month. Please welcome our:new Silver sponsor,Svix, who will contribute $500 monthly.new Bronze sponsor,Rviewer, who will contribute $100 monthly.Huge thank you to our one-time sponsor,Simlot, for donating $944.AsyncAPI Bounty Program TrialWe're thrilled to share that theAsyncAPI Bounty Program Trialhas been completed. We started the trial with a total of 7 projects consisting of coding, design, and technical writing tasks, categorized into medium and advanced levels. We had pre-set rules for the bounty trial, and everything went smoothly when it came to task assignment and completion. We also learned valuable insights during the trial, such as timeline extension and handling additional tasks necessary for task completion that will be implemented in the official program. Here are the accomplished tasks and the exceptional assignees:Bounty Issue LinkScopeCategoryTypeAssigneeStatushttps://github.com/asyncapi/website/issues/843Enable caching on a website built on NetlifyMedium LevelCodingSambhav GuptaCompletehttps://github.com/asyncapi/cli/issues/358Add a Dockerfile and release pipeline necessary to publish itMedium LevelCodingSavio DiasCompletehttps://github.com/asyncapi/cli/issues/123Configure CLI commands docs generation into existing flowsMedium LevelCodingMahfuza Humayra MohonaCompletehttps://github.com/asyncapi/cli/issues/38Enable CLI to read the context from CWDAdvanced LevelCodingViacheslav TurovskyiCompletehttps://github.com/asyncapi/generator/issues/943Create a first tutorial for AsyncAPI GeneratorAdvanced LevelDoc'sFlorence NjeriCompletehttps://github.com/asyncapi/community/issues/672Create an infographic with information about AsyncAPI Initiative financeAdvanced LevelDesignAISHAT MUIBUDEENCompletehttps://github.com/asyncapi/cli/issues/361Extend the functionality of --version flag in AsyncAPI CLI to include info about versions of other AsyncAPI libraries used in the projectMedium LevelCodingViacheslav TurovskyiCompleteSpec x ToolingThe progress on supporting the AsyncAPI Spec v3 is advancing significantly. So far, we are currently working on updating the CLI to validate v3 documents together with the Generator and Modelina. You can keep track of the releaseson the AsyncAPI Spec v3 issue.Google Summer of Code(GSoC)Google Summer of Code'23 is coming to an end soon, and our esteemed mentors are currently underway with the final evaluation of the projects. We are excited and can't wait to announce the successful completion of the projects. One of the GSOC'23 mentees,Richa Sharma, wrote a detailed blog,Reflections on My GSoC 2023 Journey; please be sure to read it.Code of ConductWe are calling for votes to establish our first Code of Conduct Committee that will enforce and ensure every community member follows and doesn't violate it. Please make sure to drop a comment with your nominations to theAsyncAPI Code of Conduct Refresh discussion.Coming in SeptemberAsyncAPI Community Updates Newsletter- The next issue will drop in August's first week. Stay informed about the latest community activities bysubscribing to the AsyncAPI Newsletter.AACoT'23 London Edition- Our first AACoT'23 stop will be held at theIBM London officeon the 20th of September.Be sure to get your ticketsbefore they run out. See you there!
"""
--------------------------------------------------------------------------------


Post 31
ID: https://www.asyncapi.com/blog/2023-july-docs-report?utm_source=rss
Title: AsyncAPI Docs Report - July 2023
Link: https://www.asyncapi.com/blog/2023-july-docs-report?utm_source=rss
Summary: import ContributionNotes from '@/assets/docs/fragments/contribution-notes.md';
import TalkToMe from '@/assets/docs/fragments/talk-to-me.md';

AsyncAPI Docs Report - July 2023

Overview

In July 2023,
Content:
"""
AsyncAPI Docs Report - July 2023OverviewIn July 2023, our AsyncAPI documentation continued to flourish, with a total of7,443 sessionsand3,895 unique usersrecorded. Engagement this month also included2,345 new users, further underlining the thriving growth of our docs community.With the successful continuation of the2023 Google Season of Docsand theTechnical Writing Mentorship Program, our documentation contributors have made significant strides in understanding the intricacies of the new Spec 3 and its enhanced features.2023 Google Season of DocsDuring July, remarkable progress was achieved ondocumenting the AsyncAPI document structure. Assigned to our diligent Google Season of Docs (GSoD) writers, most sections have already undergone their second draft, and these dedicated writers are actively engaging with core spec contributors to clarify any queries.Simultaneously, thecreate 100-level interactive learning pathhas been advancing steadily. Thesetup of a dedicated AsyncAPI GitHub repository to host with Killercoda, marks a significant step towards hosting our interactive learning paths. To ensure inclusivity, the topics to be covered in our 100-level learning path will also be determined through a forthcoming community vote.2023 AsyncAPI Mentorship Program —Technical WritingTechnical writers participating in the 2023 AsyncAPI Mentorship Program are actively engaged in community building, opening acommunity vote that successfully identified Kafka and Websocket as the prioritized protocols for this year's scope of work.Diving into detailed research and interactions with diverse community members, ourwriters are also researching meticulously the most common AsyncAPI processes/tasks associated with Kafka and Websocket.JoinOPENSpec 3.0 Docs MeetingsCalling out to all members of the AsyncAPI community! Our efforts to bolsterSpec 3.0 documentationcontinues with a series of community meetings. These biweekly gatherings, scheduled for Thursdays at 14:30 UTC, provide an open forum for enthusiastic contributors and inquisitive minds.Whether you're passionate about contributing to Spec 3.0 docs or seeking clarifications, these meetings are the conduit to connect and collaborate with the expertise of our spec contributors. A special invitation is extended to the participants of the GSoD and Mentorship Program, ensuring their contributions seamlessly align with the evolution of Spec 3.0.Watch July Spec 3.0 Docs MeetingsFor those who missed our July meetings, you can revisit these sessions on the AsyncAPI YouTube channel.July 6th 2023 (Spec 3.0 Docs Meeting)July 20th 2023 (Spec 3.0 Docs Meeting)AsyncAPI Docs - July SummaryIn July 2023, the AsyncAPI documentation community experienced steady engagement, with a total of 7,443 sessions and 3,895 unique users. The concurrent progress of the2023 Google Season of Docsand theTechnical Writing Mentorship Programhighlighted the writers' dedication to understanding the intricacies of the new Spec 3 and its advanced functionalities.During this period, the Google Season of Docs (GSoD) writers made substantial strides in their assigned projects. Additionally, the "create 100-level interactive learning path" project gained momentum as the writers set up a dedicated GitHub repository for hosting our interactive learning paths with Killercoda.The 2023 AsyncAPI Mentorship Program writers delved into meticulous research and community interactions, aiming to comprehensively capture common AsyncAPI processes and tasks associated with our selected protocols.Meanwhile, the OPEN Spec 3.0 Docs Meetings continued to serve as a platform for fostering docs collaboration. With biweekly gatherings scheduled on Thursdays at 14:30 UTC, these meetings provide an opportunity for contributors to engage with expert spec contributors, aligning their contributions seamlessly with the evolution of Spec 3.0. Those who missed the July Spec 3.0 Docs Meetings could easily catch up by accessing the recordings on the AsyncAPI YouTube channel.How to contribute to AsyncAPI DocsDid you know that you can contribute Docs to AsyncAPI as well?Code isn't the only way to contribute to OSS; Dev Docs are ahugehelp that benefit the entire OSS ecosystem. At AsyncAPI, we value Doc contributions as much as every other type of contribution.❤️To get started as a Docs contributor:Familiarize yourself with ourproject's Contribution Guideand ourCode of Conduct.Head over to ourAsyncAPI Docs Board.Pick an issue you would like to contribute to and leave a comment introducing yourself. This is also the perfect place to leave any questions you may have on how to get started.If there is no work done in that Docs issue yet, feel free to open a PR and get started!Docs contributor questionsDo you have a documentation contributor question and you're wondering how to tag me into a GitHub discussion or PR? Never fear!Tag me in your AsyncAPI Doc PRs orGitHub Discussionsvia my GitHub handle,quetzalliwrites🐙.Talk to meI want and need to listen👂🏽to all of your perspectives and ideas. Please don't be shy to express to me what you think needs to be documented first or what is missing.📝There's a lot of good work ahead, butyoudetermineour content roadmapbecause the OSS community needs should always come first.✨
"""
--------------------------------------------------------------------------------


Post 32
ID: https://www.asyncapi.com/blog/api-first-with-asyncapi?utm_source=rss
Title: API-First with AsyncAPI
Link: https://www.asyncapi.com/blog/api-first-with-asyncapi?utm_source=rss
Summary: If you are familiar with OpenAPI and OpenAPI Generator API-First process, doing API-First with AsyncAPI is similar.
Content:
"""
API-First with AsyncAPIAPI-First with AsyncAPIBroker-based APIs are SymmetricEvents, Commands, and MessagesUnderstanding AsyncAPI DefinitionInfoServersChannels: Publish / SubscribeMessagesMessage Payloads / SchemasReusing Configurations: Operation Traits, Message Traits...Different Styles of Event MessagesNotification MessagesState Transfer MessagesDomain Event MessagesNext: Java Code Generator for AsyncAPIIf you are familiar with OpenAPI and OpenAPI Generator API-First workflow:First, write the OpenAPI definition, collaborating between API providers and API consumers.Then, use OpenAPI Generator, either the maven plugin or a CLI, to generate some DTOs and interfaces from your OpenAPI definition.Implementing the generated interfaces, you can create a service for the API.As a client, you can use generated interfaces to consume the API with some HTTP client generated behind the scenes.When doing API-First with AsyncAPI, the process is similar. After you generate some interfaces and DTOs from your API definition, you use the generated interfaces to produce messages, send them to the broker, and implement them to consume messages from the broker.There is still a fundamental difference between OpenAPI and AsyncAPI: OpenAPI is used to document Request-Response / Client-Server APIs, while AsyncAPI is used to document Event-Driven APIs which, except for WebSockets, are Broker-based.And broker-based APIs, unlike Client-Server, are inherentlysymmetric.Broker-based APIs are SymmetricBecause APIs mediated by a broker are inherentsymmetric, it's difficult to establish the roles of the client/server: what represents apublishoperation from one side will be asubscribeoperation seen from the other side. Also, a given service can act as a publisher and subscriber on the same API.For these reasons, to avoid defining the same API operations multiple times from each perspective, we propose to define the API only once from the perspective of the provider of the functionality, which may be a producer, a consumer, or both.Some definitions:SERVICE: An independent piece of software, typically a microservice, that provides a set of capabilities to other services.PROVIDER: The service that implements the functionality of the API. It may be accepting asynchronous command requests or publishing business domain events.CLIENT/s: The service/s that uses the API's functionality. It may be requesting asynchronous commands or subscribing to business domain events.PRODUCER: A service that writes a given message.CONSUMER: A service that reads a given message.Define your AsyncAPI from the perspective of thePROVIDERof the functionality, which may be a producer, a consumer, or both. Share this definition with yourCLIENTS.Use the table to understand which section of AsyncAPI (publish or subscribe) to use for each topic and which role (provider or client) to use on the plugin configuration.EventsCommandsProviderProduces (publish)Consumes (subscribe)ClientConsumes (subscribe)Produces (publish)OperationId Suggested Prefixon<Event Name>do<Command Name>If you still find it confusing which one is a provider and a client, just use this rule: it can be only one provider of a given message, while clients of a given message there can be many:If the provider is the producer, use publish sectionIf it is the consumer, use subscribe section.Events, Commands, and MessagesThere are two types of messages in a messaging system: events and commands. An event message describes a change that has already happened, while a command message describes an operation that needs to be carried out. In other words, events are used to notify subscribers about something that has already occurred, while commands are used to initiate an action or process.Event:A message describing a change that has already happened.Command:A message describing an operation that has to be carried out.Also, while there can be only one provider that produces a given event, commands can be issued for one or many client producers.Understanding AsyncAPI DefinitionWhile OpenAPI and AsyncAPI come to document completely different architectural styles, they are similar in many aspects; in fact, AsyncAPI YAML format was initially based on OpenAPI format and structure.If you are familiar with OpenAPI, you may find useful the following image borrowed from AsyncAPI documentation (click image to follow):InfoDocument your API: name, purpose, contact details, and license...ServersDocument where your API will be deployed and required security...You can also document some serverprotocol-specific configurationsusing free-formbindingspropertyChannels: Publish / SubscribeEach channel represents one single broker topic, channel, or queue... where you are about to publish or subscribe.Use the table above to understand which section, publish or subscribe, you may want to use.In a nutshell:Providers publish events and subscribe to commands/queries/requests.If you still find it confusing which is a provider and a client, use this rule: In a given messaging scenario, there can be only one provider of a message, while there can be multiple clients. If the provider is producing messages, use thepublishsection. If the provider is consuming messages, use thesubscribesection.MessagesUse Messages to describeHeaders,Payload Schema, andContent-Type. You can also include examples, descriptions, and protocol-specific binding documentation...1components:2messages:3turnOnOff:4name: turnOnOff5title: Turnon/off6summary: Command a particular streetlighttoturn the lightsonoroff.7headers:8type:object9properties:10my-app-header:11type: string12payload:13$ref: "#/components/schemas/turnOnOffPayload"14Message Payloads / SchemasYou can define message payloads as:Inline components/schemas in the same familiar way you do in OpenAPIExternal files: bothjson-schemaandavro schemas(.avsc) are supported1components:2messages:3MessageWithAsyncAPISchema:4payload:5$ref:"#/components/schemas/turnOnOffPayload"## asyncapi/inline schema6MessageWithExternalJsonSchema:7schemaFormat:'application/schema+json;version=draft-07'8payload:9$ref:"some/external/file.schema"## a json-schema file10MessageWithAvroSchema:11schemaFormat:application/vnd.apache.avro+json;version=1.9.012payload:13$ref:"v1/imports/file.avsc"## and avro schema fileReusing Configurations: Operation Traits, Message Traits...Operation Traits, Message Traits are an excellent way to reuse chunks of configuration between different operations or messages.For instance, if various messages share some common headers, you can configure them as Message Traits:1components:2messages:3CustomerEventMessage:4name:CustomerEventMessage5title:Async Event for a Customer6summary:Async Event for a Customer7schemaFormat:application/vnd.aai.asyncapi;version=2.4.08traits:9- $ref:'#/components/messageTraits/CommonHeaders'#'CommonHeaders'contents will replace'traits'property10payload:11$ref:'#/components/schemas/CustomerEventPayload'1213messageTraits:14CommonHeaders:15headers:16type:object17properties:18my-app-header:19type:integer20minimum:021maximum:100And the same concept applies to Operation Traits.Different Styles of Event MessagesNotification MessagesAn Event Notificationcontains minimal information about the eventand enough information for interested consumers to locate additional details. The specifics of what information is included in an event notification can vary depending on the system or use case.1{2"headers": {3"event-type":"customer-created",4"event-id":"",5"aggregate-id":"1",6"aggregate-type":"customer"7},8"payload": {9"id":1,10"eventType":"created",11"link":"/customers/1"12}13}State Transfer MessagesOn the other hand, a State Transfer messagecontains the entire state of the aggregate, so a consumer does not need to make additional calls. This can be useful in situations where subscribers need to maintain a synchronized view of the data. Compacted keyed topics typically use this style of messages.1{2"headers": {3"event-id":"",4"aggregate-id":"1",5"aggregate-type":"customer"6},7"payload": {8"id":1,9"firstName":"string",10"lastName":"string",11"password":"string",12"email":"string",13"username":"string",14"address": {15"id":1,16"street":"string",17"city":"string",18"state":"string",19"zip":"string"20}21}22}Domain Event MessagesDomain Event Messagescontains information about the event and interesting portions of the underlying aggregate, but not the entire state of the aggregate. This style of events is typically used for Event Sourcing integration patterns.1{2"headers": {3"event-type":"customer-address-updated",4"event-id":"",5"aggregate-id":"1",6"aggregate-type":"customer"7},8"payload": {9"id":1,10"eventType":"address-updated",11"customer": {12"id":1,13"new-address": {14"street":"string",15"city":"string",16"state":"string",17"zip":"string"18}19}20}21}Next: Java Code Generator for AsyncAPINext: Java Code Generator for AsyncAPIOriginally published athttps://zenwave360.github.io
"""
--------------------------------------------------------------------------------


Post 33
ID: https://www.asyncapi.com/blog/jhipster-jdl-to-asyncapi?utm_source=rss
Title: Convert JHipster JDL to AsyncAPI v2/v3 with ZenWave SDK
Link: https://www.asyncapi.com/blog/jhipster-jdl-to-asyncapi?utm_source=rss
Summary: Because writing YAML by hand is now fun... You can generate AsyncAPI v2/v3 from  JHipster JDL models with ZenWave SDK.
Content:
"""
Generating AsyncAPI definition files from JDL with ZenWaveSDKWriting YAML by hand is no fun, but you can simplify the process of writing AsyncAPI definition files by using a Domain Specific Language (DSL).JHipster Domain Language (JDL)is a Domain Specific Language (DSL) used to define the domain model of a web application. With JDL, you can describe the entities, relationships, and constraints of your system in a concise and readable way.Zenwave SDKis a set of tools to generate (and reverse engineering) code from JDL and API-First models like AsyncAPI and OpenAPI.Thanks to ZenWave SDK, you can convert JDL models into AsyncAPI definition files. This can save time and effort in the development process while ensuring that your APIs follow best practices and standards.JDL Example1@aggregate2entity Customer {3username String required minlength(3) maxlength(250)4password String required minlength(3) maxlength(250)5email String required minlength(3) maxlength(250)6firstName String required minlength(3) maxlength(250)7lastName String required minlength(3) maxlength(250)8}9entity Address {10street String11city String12country String13zipCode String14}1516relationship OneToOne {17Customer{address} to Address{customer}18}Generating AsyncAPI definition files from JDL with ZenWaveSDKSeeJDL To AsyncAPI Generatorfor a complete list of options andGitHub repositoryfor install instructions.Because JDL can only describe static aspects of your models and doesn't cover dynamic behavior, ZenWave SDK can only infer CRUD operations from your entities, generating:One channel for each entity for both publishing Domain Events and subscribing to Commands/Requests.Messages and payloads for each entity Create/Update/Delete events (AVRO and AsyncAPI schema)1jbang zw -p io.zenwave360.sdk.plugins.JDLToAsyncAPIPlugin \2includeCommands=false \3specFile=src/main/resources/model/entities-model.jdl \4idType=integer \5idTypeFormat=int64 \6annotations=aggregate \7payloadStyle=event \8targetFile=src/main/resources/model/asyncapi.ymlYou can choose to generate only Events or Commands usingincludeEvents(default: true) andincludeCommands(default: false) to filter which channels you want to include in your AsyncAPI definition file.You can also filter which entities you want to include Messages for in your AsyncAPI definition file using:entities,skipEntities,annotations, andskipForAnnotations.UPDATE:ZenWave SDK version 1.0.6 now supports generating AsyncAPI v3 format. UseasyncapiVersion=v3as:1jbang zw -p io.zenwave360.sdk.plugins.JDLToAsyncAPIPlugin \2includeCommands=false \3specFile=src/main/resources/model/entities-model.jdl \4idType=integer \5idTypeFormat=int64 \6annotations=aggregate \7payloadStyle=event \8asyncapiVersion=v3 \9targetFile=src/main/resources/model/asyncapi.ymlSupported Schema Formats and Message StylesYou can generate AsyncAPI definition files with the following options:Supported Schema Formats: AVRO and AsyncAPI schemaSupportedPayload Styles: "Entity State Transfer" and "Domain Event" (for Create/Update/Delete events):State Transfer message contains the entire state of the aggregate, so a consumer does not need to make additional calls.Domain Event Messages contain information about the event and interesting portions of the underlying aggregate, but not the entire state of the aggregate.By using JDL to define your domain model and ZenWave SDK to convert it into an AsyncAPI definition file, you can simplify the process of designing and documenting your APIs. This can improve your APIs' overall quality and consistency while reducing errors and inconsistencies.Originally published athttps://zenwave360.github.io.
"""
--------------------------------------------------------------------------------


Post 34
ID: https://www.asyncapi.com/blog/zenwave-asyncapi-code-generator?utm_source=rss
Title: API-First with AsyncAPI and ZenWave SDK
Link: https://www.asyncapi.com/blog/zenwave-asyncapi-code-generator?utm_source=rss
Summary: With ZenWave SDK plugins, you can generate strongly typed business interfaces, payload and header DTOs and several integration patterns like Transactional Outbox, DeadLetter Queue... from AsyncAPI definitions.
Content:
"""
API-First with AsyncAPI and ZenWave SDKWith ZenWave'sspring-cloud-streams3andjsonschema2pojoplugins, you can generate:Strongly typedbusiness interfacesPayload DTOsandHeader objectsfrom AsyncAPI definitions.It uses Spring Cloud Streams as the default implementation, so it can connect to many different brokers via provided binders.And because everything is hidden behind interfaces, we can encapsulate many Enterprise Integration Patterns:Transactional Outbox: with MongoDB ChangeStreams, Plain SQL, and Debezium SQL flavorsBusiness DeadLetter Queues: allowing you to route different business Exceptions to different DeadLetter queues for non-retryable errors.Enterprise Envelope: when your organization uses a common Envelope for messages, you can still express your AsyncAPI definition in terms of your business payload.SeeAsyncAPI and Spring Cloud Streams 3 Configuration OptionsandZenWave Maven Pluginfor more details.1<plugin>2<groupId>io.github.zenwave360.zenwave-sdk</groupId>3<artifactId>zenwave-sdk-maven-plugin</artifactId>4<version>${zenwave.version}</version>5<configuration>6<inputSpec>classpath:/model/asyncapi.yml</inputSpec>7<addCompileSourceRoot>true</addCompileSourceRoot>8<addTestCompileSourceRoot>true</addTestCompileSourceRoot>9</configuration>10<executions>11{/* DTOs */}12<execution>13<id>generate-asyncapi-dtos</id>14<phase>generate-sources</phase>15<goals>16<goal>generate</goal>17</goals>18<configuration>19<generatorName>jsonschema2pojo</generatorName>20<configOptions>21<modelPackage>io.zenwave360.example.core.domain.events</modelPackage>22{/*<jsonschema2pojo.includeTypeInfo>true</jsonschema2pojo.includeTypeInfo>*/}23<jsonschema2pojo.useLongIntegers>true</jsonschema2pojo.useLongIntegers>24</configOptions>25</configuration>26</execution>27{/* Generate PROVIDER */}28<execution>29<id>generate-asyncapi</id>30<phase>generate-sources</phase>31<goals>32<goal>generate</goal>33</goals>34<configuration>35<generatorName>spring-cloud-streams3</generatorName>36<configOptions>37<role>provider</role>38<style>imperative</style>39<transactionalOutbox>mongodb</transactionalOutbox>40<modelPackage>io.zenwave360.example.core.domain.events</modelPackage>41<producerApiPackage>io.zenwave360.example.core.outbound.events</producerApiPackage>42<consumerApiPackage>io.zenwave360.example.adapters.commands</consumerApiPackage>43</configOptions>44</configuration>45</execution>46</executions>4748<dependencies>49<dependency>50<groupId>io.github.zenwave360.zenwave-sdk.plugins</groupId>51<artifactId>asyncapi-spring-cloud-streams3</artifactId>52<version>${zenwave.version}</version>53</dependency>54<dependency>55<groupId>io.github.zenwave360.zenwave-sdk.plugins</groupId>56<artifactId>asyncapi-jsonschema2pojo</artifactId>57<version>${zenwave.version}</version>58</dependency>59</dependencies>60</plugin>Provider vs ClientBecause broker-based API definitions are inherentlysymmetrical, it's difficult to establish the roles of client/server. ZenWave generates code based onproviderandclientroles, where aprovider"produces events" and "consumes commands". SeeAPI-First with AsyncAPIpage for more details on "publish/subscribe", "producer/consumer," and "provider/client" roles.Write your AsyncAPI definitions from theproviderperspective and then configure the code generator to generate either aprovideror aclient.If you still find it confusing which is a provider and a client, use this rule: In a given messaging scenario, there can be only one provider of a message, while there can be multiple clients. If the provider is producing messages, use thepublishsection. If the provider is consuming messages, use thesubscribesection.Spring Cloud Streams Producer: Using generated code to produce messagesOn the producer side generates:InterfaceICustomerEventsProducerto produce typed messages that uses your domain names:onCustomerEvent,CustomerEventPayload, andCustomerEventPayloadHeaders.Producer@ComponentCustomerEventsProducerto use Autowire in your services.To produce messages, all you need to do is @Autowire, the generated producer, as part of your code.Because it sits behind a business-oriented interface, this producer component can be implemented in different flavors and integration patterns like transactional outbox (for MongoDB and SQL), or enterprise envelop, depending on how you configure the Zenwave maven generator.1// Autogenerated: you can @Autowire it in your code2publicinterfaceICustomerEventsProducer{3// headers object omitted for brevity4/**5* Customer Domain Events6*/7booleanonCustomerEvent(CustomerEventPayload payload, CustomerEventPayloadHeaders headers);89}1// Autogenerated: add it to your autoscan packages2@Component3publicclassCustomerEventsProducerimplementsICustomerEventsProducer{45// details omitted for brevity67/**8* Customer Domain Events9*/10publicbooleanonCustomerEvent(CustomerEventPayload payload, CustomerEventPayloadHeaders headers){11// this is one of the many flavors, you shouldn't need to worry about the details12log.debug("Sending message to topic: {}", onCustomerEventBindingName);13Message message = MessageBuilder.createMessage(payload,newMessageHeaders(headers));14returnstreamBridge.send(onCustomerEventBindingName, message);15}16}1// Autowire this producer in your code2@Autowired3ICustomerEventsProducer customerEventsProducer;45// and use it to produce messages6varmessage =newCustomerEventPayload()7.withCustomerId("123")8// [...] set some more data9.withEventType(CustomerEventPayload.EventType.CREATED);10// notice how headers are also strongly typed11varheaders =newICustomerEventsProducer.CustomerEventPayloadHeaders()12.entityId("123")13.commonHeader("value")14.set("undocumented-header","value");1516customerEventsProducer.onCustomerEvent(message, headers);Spring Cloud Streams Consumer: Using generated code to consume messagesOn the consumer side generates:Functional ConsumerDoCustomerRequestConsumerfor Spring Cloud Streams bindings.Business InterfaceIDoCustomerRequestConsumerServiceyou need to implement in order to receive strongly typed messages.This Functional Consumer can abstract away different integration patterns like Business Dead Letter Queue and others... depending on how you configure the Zenwave maven generator.To consume messages, you need to implement the generated business interface and register it as a Spring bean.1// Autogenerated: you need to implement and provide this business interface2publicinterfaceIOnCustomerEventConsumerService{3/**4* Customer Domain Events5*/6defaultvoidonCustomerEvent(CustomerEventPayload payload, CustomerEventPayloadHeaders headers){};7}1// Autogenerated: add it to your autoscan packages and provide business interface implementation2@Component("on-customer-event")3publicclassOnCustomerEventConsumerimplementsConsumer<Message<CustomerEventPayload>>{45// you need to implement this interface6protectedIOnCustomerEventConsumerService service;78@Override9publicvoidaccept(Message<CustomerEventPayload> message){10log.debug("Received message: {}", message);11try{12Object payload = message.getPayload();13if(payloadinstanceofCustomerEventPayload) {14varheaders =newIOnCustomerEventConsumerService.CustomerEventPayloadHeaders();15headers.putAll(message.getHeaders());16service.onCustomerEvent((CustomerEventPayload) payload, headers);17return;18}19log.error("Received message without any business handler: [payload: {}, message: {}]", payload.getClass().getName(), message);20}catch(Exception e) {21// error handling and dead-letter-queue routing omitted for brevity22}23}24}1// Implement the business interface and add it to your context2@Component3classDoCustomerRequestConsumerServiceimplementsIDoCustomerRequestConsumerService{45@Override6publicvoiddoCustomerRequest(CustomerRequestPayload payload, CustomerRequestPayloadHeaders headers){7log.info("Received '{}' message with payload: {}", payload.getClass(), payload);8// [...] do something with this message9}10}Exception Handling with Business Dead Letter QueueZenWave SDK consumers can be configured to route exceptions to different error queues. This is useful to manage non-retryable business exceptions so the stream processing is not interrupted. If your code throws an exception not configured for error routing, it will be rethrown and follow the standard error handling mechanism for your particular Spring Cloud Stream binder.1spring.cloud.stream.bindings:2on-customer-event-in-0:3destination:customer.events4content-type:application/json5# configuring error routing for this consumer6dead-letter-queue-error-map:>7{8'javax.validation.ValidationException': 'on-customer-event-validation-error-out-0',9'java.lang.Exception': 'on-customer-event-error-out-0'10}Populating Headers at Runtime AutomaticallyZenWave SDK providesx-runtime-expressionfor automatic header population at runtime. Values for this extension property are:$message.payload#/<json pointer fragment>: follows the same format as AsyncAPICorrelation IDobject.$tracingIdSupplier: will use the tracing idjava.function.Supplierconfigured in your Spring context.1CustomerEventMessage:2name:CustomerEventMessage3//[...]otherpropertiesomittedforbrevity4headers:5type:object6properties:7kafka_messageKey:8type:string9description:Thisonewillbepopulatedautomaticallyatruntime10x-runtime-expression:$message.payload#/customer/id11tracingId:12type:string13description:Thisonewillbepopulatedautomaticallyatruntime14x-runtime-expression:$tracingIdSupplier1<configOption>2<tracingIdSupplierQualifier>myTracingIdSupplier</tracingIdSupplierQualifier>{/* default is "tracingIdSupplier" */}3<runtimeHeadersProperty>x-custom-runtime-expression</runtimeHeadersProperty>{/* you can also override this extension property name */}4</configOption>1@Bean("myTracingIdSupplier")2publicSuppliertracingIdSupplier(){3return() ->"test-tracing-id";4}InMemory Producers as TestDoublesAlongside the generated producer, ZenWave SDK also generates anin-memory producer captorthat can be used as a test double and a singletone manual context so you easily include them in your unit/integration tests.1// generated class, you can use in your tests2publicclassProducerInMemoryContext{34publicstaticfinalProducerInMemoryContext INSTANCE =newProducerInMemoryContext();567privateCustomerEventsProducerCaptor customerEventsProducerCaptor =newCustomerEventsProducerCaptor();89public<T extends ICustomerEventsProducer>TcustomerEventsProducer(){10return(T) customerEventsProducerCaptor;11}12}And you can use it in your tests to instantiate your service and perform assertions. You can finda working example here.1// example of how you can instantiate your service using the in-memory producer captor2publicclassInMemoryTestsManualContextextendsInMemoryTestsConfig{34// [...] other beans omitted for brevity56publicCustomerUseCasesImplcustomerUseCases(){7// instantiating a bean with in-memory dependencies8returnnewCustomerUseCasesImpl(customerRepository(), ProducerInMemoryContext.INSTANCE.customerEventsProducer());9}10}1112// and using it in your tests to perform assertions13publicclassCustomerUseCasesTest{1415// this is the in-memory producer captor wired16CustomerEventsProducerCaptor customerEventsProducer = ProducerInMemoryContext.INSTANCE.customerEventsProducer();1718@Test19voidtestCustomerUseCase(){20// [...] test your use case21Assertions.assertEquals(3, customerEventsProducer.getCapturedMessages(customerEventsProducer.onCustomerEventBindingName).size());22}23}Enterprise Integration PatternsBecause access to the underlying implementation is encapsulated behind the generated interfaces, it's possible to implement many Enterprise Integration Patterns (EIP) on top of them.Transactional Outbox: for MongoDB, plain JDBC, and Debezium SQLBusiness DeadLetterQueueEnterprise EnvelopAutomatic headersJump to (https://zenwave360.github.io/zenwave-sdk/plugins/asyncapi-spring-cloud-streams3/[ZenWaveSDK Spring-Cloud-Streams plugin] for more details on how to configure this.Originally published athttps://zenwave360.github.io.
"""
--------------------------------------------------------------------------------


Post 35
ID: https://www.asyncapi.com/blog/july-2023?utm_source=rss
Title: Community Update: July 2023
Link: https://www.asyncapi.com/blog/july-2023?utm_source=rss
Summary: July Community Update
Content:
"""
Earlier this month, we officially kickstarted the AsyncAPI Mentorship Program. After receiving an overwhelming response of over 90+ applications for the program, we inducted13 mentees into the AsyncAPI mentorship program. We are thrilled to welcome these talented individuals and look forward to seeing them grow and excel in their respective projects. Additionally, we are excited that ourbudget of $19,500 for the AsyncAPI Mentorship Program got approved, which means we can compensate all successful mentees of the program. We are grateful for the support and look forward to a successful program.AsyncAPI Conf on Tour 2023 (AACoT)Tickets for AACoT'23 London event are available for purchase now, and we have some fantastic talks lined up for September 20th that you won't want to miss.Hurry and get your tickets through Open Collectivebecause we have limited availability.We are also in the process of reviewing talk proposals and will announce our selected speakers soon.Be sure to keep an eye out for our August newsletter, as we will be sharing some exciting news there and maybe revealing the next location.Spec x ToolingThe work on the pre-release version of AsyncAPI Studio is now in progress. The implementation will include the support of validating AsyncAPI v3 documents. If you want to follow the development process or contribute, pleasecheck out the ShapeUP dashboard.On the other hand, we have released the initial versions of three protocol bindings. Our gratitude goes out to:Adam Retterfor contributing to theJMS binding,Richard Coppen, andSteve Headfor agreeing to maintain it long-term.Ian CooperandDec Kolawskifor contributing and being maintainers to theSNS bindingandSQS binding.Thanks to the involvement of various community members in reviewing the changes.DesignOur design contributor community is experiencing significant growth, and we are thrilled to see our onboarding process going smoothly. More talented individuals joining the community will bring fresh ideas and different perspectives and further foster collaboration and creativity in the initiative. Additionally,Mayais currentlyleading a design for our website, and we're eager to see all the great insights she'll bring to enhance our website even better.Ambassador ProgramDo you have a passion for event-driven architectures or message-driven APIs? Would you like to contribute to the AsyncAPI community? You can become an AsyncAPI Ambassador by making at least 4 contributions, either by giving talks, writing articles, or promoting AsyncAPI. If you're interested,learn more about becoming an AsyncAPI Ambassador today!TSC membersTheAsyncAPI Technical Steering Committeeis expanding rapidly, and we would like to warmly welcome our two latest members,Thulisile Sibanda, andAishat Muibudeen. We are excited to have you on board.In Case You Missed ItDid you miss our community session on Open Standards and Private Products? You can catch up by watching the recording.Coming in AugustAsyncAPI Community Updates Newsletter- Stay updated on the latest community activities bysubscribing to the AsyncAPI Newsletter.
"""
--------------------------------------------------------------------------------


Post 36
ID: https://www.asyncapi.com/blog/2023-june-docs-report?utm_source=rss
Title: AsyncAPI Docs Report - June 2023
Link: https://www.asyncapi.com/blog/2023-june-docs-report?utm_source=rss
Summary: import ContributionNotes from '@/assets/docs/fragments/contribution-notes.md';
import TalkToMe from '@/assets/docs/fragments/talk-to-me.md';

AsyncAPI Docs Report - June 2023

In June 2023, the AsyncA
Content:
"""
AsyncAPI Docs Report - June 2023In June 2023, the AsyncAPI documentation had7,827 sessionsand4,203 unique users, including2,566 new users, showing consistent engagement within our vibrant docs community.Adding to this excitement was the kick-off of both the2023 Google Season of DocsandTechnical Writing Mentorship Programprojects, further expanding our bustling docs community.Google Season of Docs 2023 Update: AsyncAPI ProjectsAs of June, our Google Season of Docs (GSoD) writers have been diligently working on tasks from thecover AsyncAPI document sections in detailproject. Most have completed initial drafts for their first documents, and some are already diving into their second. A select few have gone above and beyond, arranging discussions with core spec contributors to clarify questions on their docs pull requests.Meanwhile, progress on thecreate 100-level interactive learning pathproject continues. We've concluded thecommunity vote on our host platform for AsyncAPI Interactive Learning Paths, withKillercodasecuring the majority of votes. Consequently, our writers are now fully geared towards crafting the 2023 GSoD Learning Path on the Killercoda platform. Once developed, we can repurpose this content to also share on the Linux Foundation platform.Note:For clarity, the 2023 GSoD focus lies solely on implementation on one platform—Killercoda. Any potential addition of the content to the Linux Foundation platform is a separate task, not included in the 2023 GSoD writers' obligations.Introducing aTechnical WritingCategory in 2023 AsyncAPI Mentorship ProgramIn our quest to continually enhance the AsyncAPI Mentorship Program, we're excited to announce the inclusion of aTechnical Writingcategory in our 2023 edition. For 2023, the selected technical writers will document how various protocols(i.e., Kafka, Websocket, MQTT, etc.)work with the AsyncAPI specification.We're delighted to welcome and congratulate our accepted writers into this year's program -Cynthia Peter,Arya Gupta,Joy Almeida, andVaishnavi Nandakumar. Their remarkable skills and passion shone through during a rigorous selection process, earning them their well-deserved places in our 2023 Technical Writing Mentorship Program.Join ourOPENSpec 3.0 Docs MeetingsCalling all AsyncAPI community members! We're continuing our series ofSpec 3.0 documentationcommunity meetings, happeningbiweekly on Thursdays at 14:30 UTC.Whether you're eager to contribute to Spec 3.0 docs, or you have questions that need answers, these open meetings are your gateway to connect and collaborate with our expert spec contributors. We especially encourage our GSoD and Mentorship Program writers to attend so as to ensure that their contributions align flawlessly with Spec 3.0.Missed our June Meetings?No worries! You can watch the previous JuneSpec 3.0 documentationcommunity meetings on the AsyncAPI YouTube channel.AsyncAPI Docs' Hall of Fame - Welcoming Florence NjeriWe're delighted to introduce the⭐AsyncAPI Docs' Hall of Fame⭐ to our monthly AsyncAPI Docs reports; a place to feature particularly exceptional and dedicated technical writing maintainers and contributors!A hearty congratulations toFlorence Njeri, our inaugural inductee and exceptional docs contributor for June. Florence, an active TSC member, excels in her meticulous maintenance of theGenerator Tool documentation. Her consistent, flawless, and timely contributions have made her an invaluable asset to our community.Florence, a Kenyan🇰🇪engineer, emerged from the 2022 Google Season of Docs with AsyncAPI, focusing on Generator Tool docs. Of the six writers from 2022 GSoD, she distinguished herself bycrafting the most documentationandautomating the copying of docs from the/generatorrepo to the/websiterepoviaasyncapi/generator#872.AsyncAPI Docs - June SummaryJune 2023 was a pivotal month for AsyncAPI's vibrant documentation community. The month marked the introduction of ourAsyncAPI Docs' Hall of Fame, withFlorence Njeribeing the inaugural inductee for her exceptional contribution. We've also unveiled theTechnical Writingcategory as part of our 2023 Mentorship Program, welcoming Cynthia Peter, Arya Gupta, Joy Almeida, and Vaishnavi Nandakumar.In our ongoing series ofOPENSpec 3.0 Docs Meetings, held biweekly, we continued to foster collaboration and knowledge-sharing. Our Google Season of Docs (GSoD) 2023 witnessed significant progress, with writers focusing on creating a 100-level interactive learning path on the Killercoda platform. The website sessions for June were at7,827with4,203 unique users, indicating a healthy and growing engagement.Congratulations to all members for this productive month, and let's continue this momentum moving forward!How to contribute to AsyncAPI DocsDid you know that you can contribute Docs to AsyncAPI as well?Code isn't the only way to contribute to OSS; Dev Docs are ahugehelp that benefit the entire OSS ecosystem. At AsyncAPI, we value Doc contributions as much as every other type of contribution.❤️To get started as a Docs contributor:Familiarize yourself with ourproject's Contribution Guideand ourCode of Conduct.Head over to ourAsyncAPI Docs Board.Pick an issue you would like to contribute to and leave a comment introducing yourself. This is also the perfect place to leave any questions you may have on how to get started.If there is no work done in that Docs issue yet, feel free to open a PR and get started!Docs contributor questionsDo you have a documentation contributor question and you're wondering how to tag me into a GitHub discussion or PR? Never fear!Tag me in your AsyncAPI Doc PRs orGitHub Discussionsvia my GitHub handle,quetzalliwrites🐙.Talk to meI want and need to listen👂🏽to all of your perspectives and ideas. Please don't be shy to express to me what you think needs to be documented first or what is missing.📝There's a lot of good work ahead, butyoudetermineour content roadmapbecause the OSS community needs should always come first.✨
"""
--------------------------------------------------------------------------------


Post 37
ID: https://www.asyncapi.com/blog/june-2023?utm_source=rss
Title: Community Update: June 2023
Link: https://www.asyncapi.com/blog/june-2023?utm_source=rss
Summary: June Community Update
Content:
"""
Over the last few months, we have seen a significant surge in people interested in using AsyncAPI to document and define event-driven architectures. We've received feedback on how it has been challenging to reuse objects effectively, like servers, messages, channels, and even author AsyncAPI documents. If you are one of those individuals, we have excellent news;Fran Méndez,Samir Amzani, and the team have been working on redesigning the AsyncAPI Studio.This redesign aims to enhance the developer experience and ensure the quality of AsyncAPI files and tools. Additionally, we are trying outthe Shape Up dashboardto coordinate with the development and redesign process. Pleasejoin the AsyncAPI Studio discussionif you wish to keep up with the progress or contribute.AsyncAPI Conf on Tour 2023 (AACoT) UpdateAsyncAPI is heading to London on the 20th of September, 2023, andIBMwill be hosting us. We want to give a big shout-out toDale Lanefor bringing them on board.TheCall for Speakers for AACoT London Edition is now open, and we welcome anyone who has a talk that can benefit or wants to share their experience with the AsyncAPI community to submit their session before the deadline on the 28th of July.We've been in touch with the speakers for AACoT Madrid Edition and are thrilled to have received exceptional talks from industry experts. We're working on creating a schedule and a rich program that will benefit all attendees.Code of Conduct CommitteeDuring April, we started thediscussion around refreshing the AsyncAPI Code of Conduct (CoC), and we have received a positive response from the community thus far. As part of the conversation, we are establishing a CoC Committee that will enforce and ensure that everyone in the community follows the CoC and doesn't violate it.
In line with that, we are encouraging everyone to participate in nominating three individuals who are part of theTechnical Steering Committeeto become our first Code of Conduct Committee.Drop a comment with your nominations to theAsyncAPI Code of Conduct Refresh discussion.Everyone must be involved, which helps keep our community safe and inclusive.Spec x ToolingWe are thrilled to announce that theAPI documentation for Modelinais now digitalized. This makes it easier to find information on how to use Modelina's features, and the best part is that it automatically updates when the source code changes. Also, we have added integration tests for TypeScript, PHP, C++, and Kotlin. Please be sure to try them out today and let us know what you think.AsyncAPI Mentorship ProgramAfter receiving an overwhelming response from folks all over the community about the mentorship program application, we are moving closer to the announcements of this year's mentees for the AsyncAPI Mentorship Program Cohort Two. Our gratitude goes out to all our mentors who dedicate their time reviewing applications to select the best candidates to mentor.Please keep your eyes on the announcement by followingthe AsyncAPI Mentorship discussion.AsyncAPI Bounty Program UpdateThe trial for the AsyncAPI Bounty Program has been progressing exceptionally well. Most of the issues have been successfully completed and compensated. We anticipate the remaining two issues to be wrapped up within the next few days.We are excited to observe the success of this trial and its contribution towards our community goals.In Case You Missed ItAre you looking to enhance your knowledge about AsyncAPI and its tools? Check out this onboarding video to gain a deeper understanding.If you missedAce'sworkshop on building a headless commerce architecture using the AsyncAPI specification and AMQP, there's no need to worry. You can catch up by watching the recording.Coming in JulyAsyncAPI Community Updates Newsletter- The next issue will drop in July's first week. Stay informed about the latest community activities bysubscribing to the AsyncAPI Newsletter.Open Standards and Private Products, with Valériane Venance- We will hostValériane Venance, Principal Developer Advocate at Bump.sh, on the13th of July at 9 am UTC as we tackle the topic "Open Standards and Private Products: A DevRel's Dream or Nightmare". Mark your calendars, and be sure to join.
"""
--------------------------------------------------------------------------------


Post 38
ID: https://www.asyncapi.com/blog/the-new-era-approaches?utm_source=rss
Title: The New Era Approaches
Link: https://www.asyncapi.com/blog/the-new-era-approaches?utm_source=rss
Summary: An update around AsyncAPI 3.0, where we are, what is remaining, release schedule, and a first look at 3.0
Content:
"""
Back inMarch 2022, you heard the first official words around AsyncAPI 3.0. Since then, a lot of people have been working diligently across many expertise to bring it to life. And with its current state, it's finally time to give an update on the progress.Show Me the Money!We are not going to give any lengthy description of features, fixes, and changes. Instead, I will just show you the money as a teaser.😉Below is an AsyncAPI v3 document that defines how you, a public application, can interact with my Smartylighting Streetlights system, where you can turn on a specific streetlight through WebSocket and get real-time information about environmental lighting conditions through Kafka.See how many features you can spot just from this example. Some changes are absent in the example, but I tried to cramp as many changes into it as possible. Below the example is a short list of changes you'll be able to fact-check your guess with.1asyncapi:"3.0.0"2info:3title:Smartylighting Streetlights public API4version:"1.0.0"5description:|6The Smartylighting Streetlights public API allows you to remotely manage the city lights through Kafka and WebSocket.78### Check out its awesome features:910* Turn a specific streetlight on 🌃11* Receive real-time information about environmental lighting conditions 📈12license:13name:Apache2.014url:https://www.apache.org/licenses/LICENSE-2.01516servers:17kafka:18host:test.mykafkacluster.org:809219protocol:kafka-secure20description:Test Kafka broker21security:22- $ref:'#/components/securitySchemes/saslScram'23websocket:24host:test.websocket.org:199925protocol:ws26description:Test WebSocket server2728defaultContentType:application/json2930channels:31turnStreetlightOnChannel:32address:"/"33messages:34turnOn:35$ref:"#/components/messages/turnOn"36servers:37- $ref:"#/servers/websocket"3839turnStreetlightOnReplyChannel:40address:"/"41messages:42turnOnReply:43$ref:"#/components/messages/turnOnReply"44servers:45- $ref:"#/servers/websocket"4647lightMeasured:48description:The topic on which measured values may be produced and consumed.49address:"smartylighting.streetlights.1.0.event.{streetlightId}.lighting.measured"50parameters:51streetlightId:52$ref:"#/components/parameters/streetlightId"53messages:54lightMeasured:55$ref:"#/components/messages/lightMeasured"56servers:57- $ref:"#/servers/kafka"5859operations:60turnOn:61action:send62operationId:turnOn63channel:64$ref:"#/channels/turnStreetlightOnChannel"65reply:66channel:67$ref:"#/channels/turnStreetlightOnReplyChannel"6869lightMeasured:70action:receive71summary:Inform about environmental lighting conditions of a particular streetlight.72operationId:receiveLightMeasurement73channel:74$ref:"#/channels/lightMeasured"75traits:76- $ref:"#/components/operationTraits/kafka"7778components:79messages:80turnOn:81name:turnOn82title:Turn on83summary:Command a particular streetlight to turn the lights on.84payload:85$ref:"#/components/schemas/turnOnPayload"8687turnOnReply:88name:turnOnReply89title:Turn on reply90summary:Reply from turning on the lights91payload:92$ref:"#/components/schemas/turnOnReplyPayload"9394lightMeasured:95name:lightMeasured96title:Light measured97summary:Inform about environmental lighting conditions of a particular streetlight.98contentType:application/json99traits:100- $ref:"#/components/messageTraits/commonHeaders"101payload:102$ref:"#/components/schemas/lightMeasuredPayload"103104schemas:105turnOnPayload:106type:object107properties:108streetlightId:109description:The ID of the streetlight.110type:string111sentAt:112type:string113format:date-time114description:Date and time when the request was sent115116turnOnReplyPayload:117type:object118properties:119turnedOnTimestamp:120type:string121format:date-time122description:Date and time when the light was actually turned on.123124lightMeasuredPayload:125schemaFormat:"application/vnd.apache.avro;version=1.9.0"126schema:127type:record128name:User129namespace:com.company130doc:User information131fields:132- name: lumens133type:int134- name: sentAt135type:timestamp_ms136137securitySchemes:138saslScram:139type:scramSha256140description:Provide your username and password for SASL/SCRAM authentication141142parameters:143streetlightId:144description:The ID of the streetlight.145146messageTraits:147commonHeaders:148headers:149type:object150properties:151my-app-header:152type:integer153minimum:0154maximum:100155156operationTraits:157kafka:158bindings:159kafka:160clientId:publicAs of the pre-releasev3.0.0-next-major-spec.12, this is a valid AsyncAPI document. You can always find the most recent pre-release version here:https://www.asyncapi.com/docs/reference.All the changes in 3.0 up until now are the following:Request/reply pattern.Introduce the new Channel Object, detached from operations.Introduce the new Operation object, detached from channels.Channels are no longer identified with address/topic/path.Optional channels.Schemas and schema formats are now naturally bound.Cleaned up the root object.Added additional meta fields for Server Object, Channel Object, Operation Object, and Operation Trait Object.External Documentation Object and Tag Object can now be reused and referenced.Unified referencing behavior.In due time we will give you a complete rundown about all the changes in 3.0 and extended documentation that explains the features in more in-depth, including a migration guide and release blog post.The Remaining EffortThe specification work is nearly done; only one change is still being discussed which is changing traits behavior to an inheritance that can be overwritten.However, at AsyncAPI, a specification is nothing without documentation and tools, which is why the majority of the remaining effort resolves just that.For documentation, you have probably noticed that since the first release of 2.0, we now have concepts, tutorials, and guides. Some of those docs will be updated due to 3.0.Regarding tooling, it's impossible to give you a clear overview of what exactly will support 3.0 right out the gate because there are many different code owners and contributors with individual priorities. So if you want a tool to support 3.0 right out the gate, please do head over to the issue and voice the need, add a👍, write a comment, or maybe even contribute the needed changes!AsyncAPI CLIAsyncAPI asyncapi-reactAsyncAPI generatorAsyncAPI studioAsyncAPI converter-jsAsyncAPI vs-asyncapi-previewAsyncAPI bundlerAsyncAPI diffAsyncAPI cupidAsyncAPI gleeAsyncAPI server-apiAsyncAPI modelinaAsyncAPI dotnet-nats-templateAsyncAPI ts-nats-templateAsyncAPI python-paho-templateAsyncAPI nodejs-ws-templateAsyncAPI java-templateAsyncAPI java-spring-cloud-stream-templateAsyncAPI go-watermill-templateAsyncAPI java-spring-templateAsyncAPI markdown-templateAsyncAPI html-templateThe only tools we can say for sure that will support 3.0 right out the gate are the JS parser and the specification JSON Schema documents because they need to be updated for any specification change to be accepted😆Currently, we areusing completed tasks as the release date for 3.0. Once all tasks are completed, we'll release 3.0.Release DateThat leaves the big question... When is the release then?Honestly, we tried to stick with a release date, and more specifically, we thought the July release period (yes, next month). However as you can probably guess with the remaining work, that's most likely not going to happen. As we are learning, major changes take time, and schedules in open source are, hard, to say the least.😄While all the specification changes are most likely done by July, my best guess, right now, is for everything to be released in September.The more people help out, the faster it will get done.😉The next time you will hear from me will be the release blog post for 3.0.👋Photo byTim MarshallonUnsplash
"""
--------------------------------------------------------------------------------


Post 39
ID: https://www.asyncapi.com/blog/may-2023?utm_source=rss
Title: AsyncAPI Community Update: May 2023
Link: https://www.asyncapi.com/blog/may-2023?utm_source=rss
Summary: May Community Update
Content:
"""
At AsyncAPI, we strive to provide valuable opportunities for individuals to work on open-source projects and gain real-world experience.
We are excited to announce the fantastic projects that made it to the Google Summer of Code this year. Although we initially submitted five projects, only four got selected.ProjectMentor/sSelected CandidateAutomate listing of members of technical steering committeeLukasz GornickiRicha SharmaAdd "Autofix" feature for common linting errors (w/ spectral)Iván García Sainz-AjaSavio DiasIntroduce UI tests and refactoring in the websiteAkshat Nema,AbirAadrika BhargavaAuthentication and Authorization support for websocket adaptersSouvik,Khuda Dad NomaniGodwin AlexanderWe can't wait to see these talented individuals progress throughout the program.Spec x ToolingTheParser-JS v2is finally released. You can browse theParser-JS documentationand learn more! It supports the AsyncAPI schema and JSON schema formats. Additionally, the Parser-JS implements a global API definition for all AsyncAPI parser implementations and is browser compatible.You can now reference AsyncAPI JSON Schema along with the SchemaStore project. This feature allows you to use JSON and YAML plugins in your IDE and fetches the JSON schema for your AsyncAPI document, providing you with autocompletion, validation, and tooltips. To ensure that the IDE recognizes your AsyncAPI document, SchemaStore matches the file names for the schema. For more details,check out the SchemaStoreor test theAsyncAPI JSON Schemafor yourself.AsyncAPI Mentorship ProgramWe are glad to have received a significant number of entries and are now moving to the next phase - ranking the projects in this year's cohort. Please stay updated by following theAsyncAPI Mentorship discussion and timeline.AsyncAPI Conf on Tour (AACoT) WebsiteThe conference redesign website is going smoothly, thanks toMaya'sincredible work. She's been busy crafting some impressive designs, and we are excited about the progress so far. If you have some ideas or input, or you'll like to contribute, pleasejoin the AACoT discussion, and let's make AACoT'23 a huge success.In case you missed it...We have a new episode on the AsyncAPI podcast featuringAce, and you don't want to miss it! Tune in and hit theAsyncAPI podcast subscribe buttonto stay in the loop.Missed the latest community call, don't worry! You can catch up by watching the recording.Coming in JuneAACoT'23 London Edition-  We're excited that AACoT'23 is coming to London on the 20th of September. The Call for Speakers will open soon, so start working on those ideas.AsyncAPI Community Updates Newsletter-The next issue will be released in the first week of June. To stay updated on the latest activities happening across the community,subscribe to the AsyncAPI Newsletter.AsyncAPI Podcast- Our upcoming episode will featureBarbaño Gonzalez, an Education Program Manager and Ambassador Program Lead. Don't forget tosubscribe to the AsyncAPI Podcast.Till next time, keep your head held high.You got this!
"""
--------------------------------------------------------------------------------


Post 40
ID: https://www.asyncapi.com/blog/2023-April-docs-report?utm_source=rss
Title: AsyncAPI Docs Report - April 2023
Link: https://www.asyncapi.com/blog/2023-April-docs-report?utm_source=rss
Summary: import ContributionNotes from '@/assets/docs/fragments/contribution-notes.md';
import TalkToMe from '@/assets/docs/fragments/talk-to-me.md';

AsyncAPI Docs Report - April 2023

In April 2023, the Asyn
Content:
"""
AsyncAPI Docs Report - April 2023In April 2023, the AsyncAPI documentation experienced significant growth with8,889 sessionsand4,575 unique users, including2,895 new users. April was a strong month for our expanding docs community.Google Season of Docs 2023 (GSoD) at AsyncAPIWe are thrilled to introduce this year's selected technical writing candidates for the 2023 Google Season of Docs (GSoD) at AsyncAPI!2023 GSoD Accepted Technical Writer CandidatesQuetzalli Writes has chosen four outstanding candidates to collaborate with us for GSoD this year:Mahfuza,Bhaswati,Rohit, andHridyesh.Overview of the LIVE Writing/Editing InterviewsDuring the LIVE interview session, Quetzalli divided the exercises into two parts: writing and editing. Candidates were given a document and asked to identify issues and potential solutions, then rewrite or edit the document as needed. Some candidates faced challenges with staying focused on writing, while others struggled to generate ideas due to nerves or the live format of the exercise. A few candidates had difficulty spotting errors and completing the editing task.However, Quetzalli did not disqualify candidates who experienced nerves, writer's block, or had limited editing skills. Instead, she guided them with questions and suggestions, encouraging them to search for answers online during the call. The main objective was to evaluate the candidates' problem-solving skills, ability to accept feedback, and integrate suggestions for improvement. The following sections outline the writing and editing exercises and the selection criteria for the candidates.The Writing PartFor the writing exercise, Quetzalli utilizedan old commit from the 2022 GSoD project, which contained numerous errors for candidates to identify and fix. Some examples of these errors include:Multiple preview deployment links instead of live links to actual documentation.Content more appropriate for theBackground contextsection crammed into theIntroduction.Inadequate tutorial steps that lacked sufficient technical background context for first-time users.The Editing PartFor the editing exercise, Quetzalli used the sameold commit from the 2022 GSoD projectfor some candidates. For those who progressed further during the writing exercise, she provided a second block of content to edit that was unformatted and contained repeated mistakes. The purpose of this unformatted text was to assess the candidates' ability to:Research terms like CLI, Node.js, macOS, etc., instead of assuming they know the correct spelling.Use thereplace allkeyboard shortcut to fix repeated mistakes.Think to check and confirm the correct spelling of AsyncAPI during an AsyncAPI interview.Candidate Selection CriteriaThe following factors were considered when assessing candidates:A humble attitude that actively listens and incorporates feedback.Strong collaborative abilities.A clear writing style.Technical writing experience and passion.Editing experience and approach.Effective use of grammar tools(e.g., Grammarly)and tech writing research tools(e.g., Phind.com, ChatGPT).Competency in researching with search engines such as Google.Spec 3.0 ReleaseAsyncAPI community members, including Jonas Lagoni and Sergio Moya, have started the process of identifying Spec 3.0 Subject Matter Experts (SMEs) who can provide the necessary background context for our technical writers to begin updating our documentation.While Quetzalli and Sergio are currently the only ones sharing the Spec 3.0writing work, we're actively seeking more contributors to join their writing efforts.The following Spec 3.0 release changes require documentation updates:Request/replyOperation/channel decouplingOperation action: pub/sub confusionUnified referencing behavior: using $ref instead of stringCommon metadata fieldsMoving root propertiestagsandexternalDocstoinfoSplitting out server URL into host and pathnameMore reusable objects in componentsContributor GrowthWe are delighted to report an increase innew docs contributorscollaborating on theAsyncAPI Docs Style Guide, working alongsideBhaswati Roy. We would like to recognize and thankAbhishekfor his ongoing contributions to our Style Guide andMahfuzafor proactivelyopening PRs to fix documentation bugs.Our gratitude goes out to our new contributors for their valuable contributions to the expansion and improvement of our documentation!ConclusionApril 2023 has been an exciting month for AsyncAPI, as we welcomed exceptional technical writing candidates through 2023 GSoD and expanded our community of docs contributors again. These developments will enhance the quality of AsyncAPI documentation and foster a more collaborative environment. We eagerly anticipate the progress our technical writers will make, addressing Spec 3.0 release changes with the support of Subject Matter Experts (SMEs) and new contributors. Our growing docs community, demonstrated by the work on the AsyncAPI Docs Style Guide and proactive bug fixing, showcases the dedication of our contributors. 2023 GSoD at AsyncAPI signifies a major milestone in our community's journey towards better documentation, a stronger docs community, and an improved overall experience for AsyncAPI users.How to contribute to AsyncAPI DocsDid you know that you can contribute Docs to AsyncAPI as well?Code isn't the only way to contribute to OSS; Dev Docs are ahugehelp that benefit the entire OSS ecosystem. At AsyncAPI, we value Doc contributions as much as every other type of contribution.❤️To get started as a Docs contributor:Familiarize yourself with ourproject's Contribution Guideand ourCode of Conduct.Head over to ourAsyncAPI Docs Board.Pick an issue you would like to contribute to and leave a comment introducing yourself. This is also the perfect place to leave any questions you may have on how to get started.If there is no work done in that Docs issue yet, feel free to open a PR and get started!Docs contributor questionsDo you have a documentation contributor question and you're wondering how to tag me into a GitHub discussion or PR? Never fear!Tag me in your AsyncAPI Doc PRs orGitHub Discussionsvia my GitHub handle,quetzalliwrites🐙.Talk to meI want and need to listen👂🏽to all of your perspectives and ideas. Please don't be shy to express to me what you think needs to be documented first or what is missing.📝There's a lot of good work ahead, butyoudetermineour content roadmapbecause the OSS community needs should always come first.✨
"""
--------------------------------------------------------------------------------


Post 41
ID: https://www.asyncapi.com/blog/2023-may-docs-report?utm_source=rss
Title: AsyncAPI Docs Report - May 2023
Link: https://www.asyncapi.com/blog/2023-may-docs-report?utm_source=rss
Summary: import ContributionNotes from '@/assets/docs/fragments/contribution-notes.md';
import TalkToMe from '@/assets/docs/fragments/talk-to-me.md';

AsyncAPI Docs Report - May 2023

In May 2023, the AsyncAPI
Content:
"""
AsyncAPI Docs Report - May 2023In May 2023, the AsyncAPI documentation had9,453 sessionsand4,876 unique users, including2,895 new users, highlighting the increasing interest and engagement within our vibrant docs community. May was a busy month in our expanding docs community!Google Season of Docs 2023 (GSoD) at AsyncAPIWe are thrilled to have started working with this year's selected technical writing candidates for the 2023 Google Season of Docs (GSoD) at AsyncAPI:Mahfuza,Bhaswati,Rohit, andHridyesh. This year, all GSoD interns will get the opportunity to work on both GSoD projects:cover AsyncAPI document sections in detailandcreate 100-level interactive learning path.Additionally, our GSoD interns have started acommunity vote to select our host platform for AsyncAPI Interactive Learning Paths. You are cordially invited to participate in the vote and share your thoughts, as your feedback plays a vital role in shaping the future of our interactive learning experience.NEW Spec 3.0 Docs Meeting -OPENAttention, AsyncAPI community members! We are excited to announce a newOPENmeeting dedicated toSpec 3.0 documentation. In this meeting, we will have the privilege of hosting Spec 3.0 Subject Matter Experts (SMEs), including the esteemed Jonas Lagoni, who will provide essential background context. If you are interested in contributing to Spec 3.0 docs or have any questions, this is the perfect opportunity to join and engage with our knowledgeable experts. We also encourage our GSoD interns to attend these meetings to ensure their new docs align seamlessly with Spec 3.0.Mark your calendars! We are planning to hold the first meeting on June 15, 2023, at 02:30 UTC. Stay tuned for further updates and details!Additionally, we want to highlight an upcoming change in the Spec 3.0 release that will require documentation updates. TheRequest/replyfeature is among the first to undergo these updates. Keep an eye out for further information and ensure your familiarity with this important change.Thank you for your active participation and dedication to advancing the AsyncAPI ecosystem. Let's strive for excellence in our Spec 3.0 documentation!Contributor GrowthWe are thrilled to share the exciting news of welcoming a new contributor to our documentation community! Please join us in extending a warm welcome toCynthia Peter! Cynthia is eager to enhance her technical writing skills and contribute to the growth of the AsyncAPI documentation.To start her journey, Cynthia will be working on her first task, which involves completing theAsyncAPI Docs Style GuideGlossary task. Once she successfully completes this task, we will swiftly onboard her with a Spec 3.0-related assignment. We are excited to see her skills flourish and her valuable contributions to the documentation.Let's celebrate Cynthia's arrival and support her as she embarks on this rewarding endeavor. Together, we will continue to elevate the quality and accessibility of the AsyncAPI documentation.ConclusionMay witnessed another remarkable increase in sessions with a total of 9,453 community members exploring our docs. Welcoming 2,895 new docs readers to our community further demonstrates the expanding interest in AsyncAPI.We are grateful for the dedication and contributions of our community members, both new and existing, who have played a pivotal role in this progress. The enthusiasm and support from our community continue to inspire us to provide high-quality documentation, and we appreciate the trust you place in us.Furthermore, we are excited about the future endeavors and collaborations within the AsyncAPI ecosystem. The selected technical writing candidates for the 2023 Google Season of Docs (GSoD) program, along with their projects, promise to bring further enhancements to our documentation. Additionally, the community vote for the host platform of AsyncAPI Interactive Learning Paths empowers our community members to shape the future of our learning experience.How to contribute to AsyncAPI DocsDid you know that you can contribute Docs to AsyncAPI as well?Code isn't the only way to contribute to OSS; Dev Docs are ahugehelp that benefit the entire OSS ecosystem. At AsyncAPI, we value Doc contributions as much as every other type of contribution.❤️To get started as a Docs contributor:Familiarize yourself with ourproject's Contribution Guideand ourCode of Conduct.Head over to ourAsyncAPI Docs Board.Pick an issue you would like to contribute to and leave a comment introducing yourself. This is also the perfect place to leave any questions you may have on how to get started.If there is no work done in that Docs issue yet, feel free to open a PR and get started!Docs contributor questionsDo you have a documentation contributor question and you're wondering how to tag me into a GitHub discussion or PR? Never fear!Tag me in your AsyncAPI Doc PRs orGitHub Discussionsvia my GitHub handle,quetzalliwrites🐙.Talk to meI want and need to listen👂🏽to all of your perspectives and ideas. Please don't be shy to express to me what you think needs to be documented first or what is missing.📝There's a lot of good work ahead, butyoudetermineour content roadmapbecause the OSS community needs should always come first.✨
"""
--------------------------------------------------------------------------------


Post 42
ID: https://www.asyncapi.com/blog/april-2023?utm_source=rss
Title: AsyncAPI Community Update: April 2023
Link: https://www.asyncapi.com/blog/april-2023?utm_source=rss
Summary: April Community Update
Content:
"""
April brought ecstatic news that AsyncAPI is participating in the 2023 Google Season of Docs (GSoD). This achievement is a result of the exceptional work done byQuetzalli Writes, our lead documentation engineer and author ofDocs-as-Ecosystem: The Community Approach to Engineering. Quetzalli's contributions to the documentation process have been vital in improving the quality of AsyncAPI documentation, and her hard work has not gone unnoticed. As part of the GSoD program, Quetzalli carefully reviewed and selected the best applicants out of the 87 applications received, and she conducted live writing/editing interviews. We are excited to welcome the five selected candidates, Mahfuza, Bhaswati, Rohit, Abhishek, and Hridyesh! We can't wait to see them contribute to AsyncAPI's documentation with Quetzalli's guidance and mentorship. Do check outQuetzalli's Q1 AsyncAPI documentation reportto learn more about our docs community's recent efforts.AsyncAPI Bounty Program TrialWe are thrilled to introduce the trial launch of the AsyncAPI Bounty Program. This program aims to express our gratitude and support to our maintainers and contributors who dedicate their time and efforts to drive the initiative forward. As part of the trial, we have selected seven projects comprising various coding, design, and technical writing tasks. We invite you to explore theprojects participating in the AsyncAPI Bounty Program trial run.Code of Conduct RefreshAsyncAPI has been growing exponentially, and to maintain a safe and inclusive environment for all community members, we must refresh our Code of Conduct. Our goal is to thrive on ensuring the community remains welcoming, respectful, and supportive. Please share your thoughts and suggestions in thisopen discussion for our Code of Conduct refresh.Call for Speakers MadridAsyncAPI Conf on Tour 2023 (AACoT) is coming to Madrid on the 18th - 19th of October. TheCall for Speakers of AACoT Madrid Editionis now open, and we are looking for diverse talk topics ranging from community, API design, and best practices. We welcome both first-time and returning speakers to submit their proposals. We can't wait to see you there!Spec x ToolingWe are excited to announce the release of the newParser-API v1.0.0. The API follows an intent-driven design approach that prioritizes the user's purpose over technical mechanics. To learn more about the functionalities, please refer tothis detailed AsyncAPI article about intent-driven APIs.There won't be any spec v2.7 release as the April release window was not used. We haven't pushed any specific features and are still looking for a release coordinator. If you are interested, please indicate in the#specchannel on Slack. We are hands-on in completing Spec v3.0; hopefully, this will be done in June. You canfollow all Spec v3.0 updates on this issue.AsyncAPI Mentorship ProgramThe AsyncAPI Mentorship Program Cohort 2 is now ready for kickoff. This year we are excited to accept code-related projects and expand to technical writing and design. Whether you are interested in participating or have project ideas, we encourage you to engagein the AsyncAPI Mentorship Program discussions.Ambassador ProgramAre you passionate about the work of the AsyncAPI community and interested in becoming part of it? Look no further; you are invited to join the Ambassador Program, which is designed to foster partnership,  community engagement, and development. As long as you meet the minimum requirements, everyone is welcome to join. To learn more about the program, please refer tothis AsyncAPI Ambassador Program articleor watch thisAsyncAPI Ambassador Program stream.Women in Open SourceBarbaño Gonzalez, Lead Education Program Manager and Ambassador Program Lead, is currently working on an article highlighting women's contributions to the open-source community. Through her research, she's exploring various case studies to gain deeper insights into the number of women involved in the field, where they're located, and the specific work they do. Barbaño aims to increase community visibility of women in open source and showcase their valuable impact in the industry. Do you have recommendations on communities that should be included in the case study? Please doreach out to Barbaño.New TSC MemberPlease help us welcome our newest AsyncAPI TSC member,Heiko Henning. We are excited to have you!Coming in MayWe have some exciting things planned for May, such as:Parser-JS v2- We eagerly anticipate the release of the main implementation of the Parser API, the Parser-JS v2. You can follow the process onParser-JS v2 GitHub issueand join the conversation in the#toolingchannel on Slack.AsyncAPI Podcast- Did you know that AsyncAPI has a podcast? If you didn't, now you know! The best part? We are dropping an episode in May. Get to know the community builders and the work they do.Be sure to subscribe to the AsyncAPI Podcast.AsyncAPI Community Updates Newsletter- We will drop the next issue in the first week of May. Be sure tosubscribe to the AsyncAPI Newsletterif you like to stay on top of the latest activities happening across the community.Till next time, keep your head held high.You got this!
"""
--------------------------------------------------------------------------------


Post 43
ID: https://www.asyncapi.com/blog/2023-Q1-docs-report?utm_source=rss
Title: AsyncAPI Documentation Report - Q1 2023
Link: https://www.asyncapi.com/blog/2023-Q1-docs-report?utm_source=rss
Summary: Did you know that you can contribute Docs to AsyncAPI as well? Code isn't the only way to contribute to OSS; Dev Docs are a huge help that benefit the entire OSS ecosystem.
Content:
"""
AsyncAPI Documentation Report - Q1 2023During Q1 2023, AsyncAPI Docs had26,875 sessionsand13,506 unique users.Docs sessions by content bucket:/docs:26,875 sessionsoverall with13,506 unique users./docs/concepts:2,316 sessionswith1,308 unique users./docs/tutorials:7,719 sessionswith4,679 unique users./docs/tools:2,955 sessionswith239 unique users./docs/guides:360 sessionswith6,011 unique users./docs/reference:10,807 sessionswith6,011 unique users.Google Season of Docs 2023 (GSoD)AsyncAPI is one of 13 OSS organizations accepted into Google Season of Docs 2023!Selected technical writers will work on two projects:documenting the AsyncAPI document in detailandcreating interactive learning paths.GSoD 2023 budget at AsyncAPI:We received a total budget of $10,350.$5,000 for documenting the AsyncAPI document section details$5,000 for creating interactive learning paths$350 for participant swag+shipping costsGSoD technical writer applications are openQuetzalli Writes is currently accepting applications for technical writers who want to participate in GSoD 2023 at AsyncAPI.The deadline for applications is April 15.Interested participants must complete thisAsyncAPI GSoD 2023 written application available in a public Google form. We have received 18 applications to date.If selected, the next step in the process for candidates will be to receive a direct follow-up message (DM) on AsyncAPI Slack and an email from Quetzalli to schedule a LIVE editing and writing exercise interview. Up to 6 technical writers will be selected no later than April 21st.AsyncAPI Docs style guideTheAsyncAPI Docs Style Guide has been created as an epic issuein our docs repository, broken into individual tasks:About this guideAccessibilityCode examplesContent buckets explanationDocs contribution guidelinesInclusive languageVoice & ToneGrammarNumbersPunctuationFormattingInternalization (i18n) & LocalizationLinksSEOStylingVersion controlGlossaryWe did not pitch the style guide project for Google Season of Docs 2023 because creating a style guide does not require any knowledge of event-driven architecture (EDA). A style guide can be a good first issue to assign to new contributors unfamiliar with EDAs. By assigning them such tasks, we can help them learn about the basics of AsyncAPI and gradually move on to more complex documentation projects.Spec 3.0 ReleaseAsyncAPI community members, including Jonas Lagoni, have begunplanning documentation updates for the upcoming Spec 3.0 releasein June. We are looking for contributors to assist with the documentation efforts. A meeting point has also been established for documentation in our community spec meetings until the release is live and the docs are ready.Here are the Spec 3.0 release changes requiring documentation:Request/replyOperation/channel decouplingOperation action: pub/sub confusionUnified referencing behavior: using $ref instead of stringCommon metadata fieldsMoving root propertiestagsandexternalDocstoinfoSplitting out server URL into host and pathnameMore reusable objects in componentsContributor growthWe are pleased to report thatnew docs contributorsare already working on theAsyncAPI Docs Style Guide, such asBhaswati Roy. Bhaswati impressed us with her research strength and ability to break down new topics into managable tasks.We are thrilled to have new contributors working with us to help ensure consistency and clarity across all documentation.ConclusionOverall, Q1 2023 saw many sessions and unique users visiting the new AsyncAPI Docs after their information architecture makeover from the GSoD 2022 program. For the second time, we were accepted into Google Season of Docs 2023 for two projects that will help improve the quality of our documentation and provide valuable opportunities for contributors to develop new skills. We have also begun planning documentation updates for the upcoming Spec 3.0 release and started work on our first style guide, which will ensure that our documentation remains consistent and relevant.Creating our first AsyncAPI Docs style guide is a major milestone because it will help ensure consistency and clarity across all documentation moving forward. With three new contributors working on the Style Guide and 18 applications already submitted for GSoD 2023 technical writing positions, the future of our docs community keeps looking bright!How to contribute to AsyncAPI DocsDid you know that you can contribute Docs to AsyncAPI as well?Code isn't the only way to contribute to OSS; Dev Docs are ahugehelp that benefit the entire OSS ecosystem. At AsyncAPI, we value Doc contributions as much as every other type of contribution.❤️To get started as a Docs contributor:Familiarize yourself with ourproject's Contribution Guideand ourCode of Conduct.Head over to ourAsyncAPI Docs Board.Pick an issue you would like to contribute to and leave a comment introducing yourself. This is also the perfect place to leave any questions you may have on how to get started.If there is no work done in that Docs issue yet, feel free to open a PR and get started!Docs contributor questionsDo you have a documentation contributor question and you're wondering how to tag me into a GitHub discussion or PR? Never fear!Tag me in your AsyncAPI Doc PRs orGitHub Discussionsvia my GitHub handle,quetzalliwrites🐙.Talk to meI want and need to listen👂🏽to all of your perspectives and ideas. Please don't be shy to express to me what you think needs to be documented first or what is missing.📝There's a lot of good work ahead, butyoudetermineour content roadmapbecause the OSS community needs should always come first.✨
"""
--------------------------------------------------------------------------------


Post 44
ID: https://www.asyncapi.com/blog/march-2023?utm_source=rss
Title: Community Update: March 2023
Link: https://www.asyncapi.com/blog/march-2023?utm_source=rss
Summary: Community update for March
Content:
"""
March came with some ecstatic news for the AsyncAPI community. We welcomedThulisile Sibandaas our new Community Manager. And to top it all, our beloved community guardian,Lukasz Gornickistepped up to become the newExecutive Directorfor AsyncAPI.
This is such an incredible milestone for the community and we can't wait to see the amazing things to follow in the next few months.AsyncAPI Conf on Tour 2023One of our goals this year is to hostAACoT, a series of micro-conferences in different locations around the world. We are glad that our first location has been confirmed and we'll be in Madrid on the 18th - 19th of October 2023.Call for speakerswill be open soon and we are eagerly waiting to receive your submissions. For more details about other AACoT locations, keep an eye out for thisdiscussion.Case StudiesWe recently added a newcase studiessection on our website. It showcases real-world production scenarios and how different individuals adopt and integrate our specifications and tools. On this note, we are glad to have our first official case study fromAdeofeatured on the website. You can read more about ithere.Spec x ToolingTheModelinawebsite has been merged and if you are interested in generating data models for your payloads, do try it out.
Spec 3.0 meetings will now incorporate various discussions and will be the best place to ask about v3, how to usenon-JSON schemaswithin AsyncAPI, anddocumentation.Google Summer of CodeAs a community, we are always looking for initiatives to drive diversity and bring more people passionate about open-source. In this regard, we applied to GSoC'23. Although our application didn't make it to the final organization selection, we are privileged to participate in GSoC'23 under Postman.Contributor applications open on the 20th of March and close on the 4th of April. If you are looking to participate we have some excitingAsyncAPI projectsand if you want to make your proposal outshine do watch thissessionfor tips.AsyncAPI Mentorship ProgramIt's almost a year since we launched our mentorship program; ourfirst cohort of six AsyncAPI Mentorship Program menteesgraduated and truly impressed us. Several of them joined our technical steering commitee and became mentors for GSoC. With that being said, we are delighted to share that our second cohort will begin soon after GSoC'23 commences. Keep an eye out on our#mentorshipchannel for the official announcement.Ambassador ProgramOne of our latest additions to the initiatives in the community is the Ambassador's Program. This program is dedicated to fostering collaboration between users and community members. It is a method to promote and nurture community growth. Presently we have a total of5 AsyncAPI Ambassadorsand the best part is, anyone can join the program as long as they meet the requirements. You can read thisarticlefor more details.TSC membersTheAsyncAPI TSChas grown exponentially over the last few months. We now have a total of 44 members and a 12% increase in women maintainers so far. Shout out to our newest members,Barbano GonzalezandKenneth Aasanwe are thrilled to have you.Coming up in AprilWe have some exciting things to look forward to in April, for instance:Newsletter- We are launching a monthly AsyncAPI community updates newsletter. This is where we will be keeping you in the loop of the activities happening in the community such as discussions, meetings, and updates. Dosubscribe!AsyncAPI Bounty Program- We are launching a trial for the AsyncAPI bounty program. This program is a way to appreciate and support maintainers for the work they are doing to push the initiative forward. You can read all about it in ouropen discussion on community building/maintenance goals for 2023.Google Season of Docs- After the success ofGSoD'22, we are happyAsyncAPI was accepted as a 2023 GSoD participantagain this year. If you are a technical writer interested in open-source and improving AsyncAPI's documentation, we'd love to see you apply and fill out theAsyncAPI GSoD technical writer application. Deadline is on the 15th of April.Call for Speakers for AACoT Madrid Edition-  Call for Speakers for Madrid will be opening soon. You can expect a keynote fromFranabout the history of AsyncAPI Initiative. Bookmark thisAACoT Madrid event page, and get ready to submit that talk!Till next time, keep your head held high.You got this!
"""
--------------------------------------------------------------------------------


Post 45
ID: https://www.asyncapi.com/blog/asyncapi-say-hi-to-triggermesh?utm_source=rss
Title: Automatically pipe events from AsyncAPI channels with TriggerMesh
Link: https://www.asyncapi.com/blog/asyncapi-say-hi-to-triggermesh?utm_source=rss
Summary: TriggerMesh makes it easy to reliably pipe events from any source to any destination. Let's use it to read from AsyncAPI channels, and see how to autogenerate the TriggerMesh config.
Content:
"""
This tutorial demonstrates how to use AsyncAPI with TriggerMesh. It shows how the two play nicely together because TriggerMesh can easily ingest, transform, filter, and route events from channels defined in an AsyncAPI definition. This is one of many possible ways to use the two technologies together. This post assumes you have basic knowledge of AsyncAPI already, but are potentially new to TriggerMesh.If you want access to the source files for this tutorial, head to thededicated GitHub TriggerMesh repo.The scenario is based on the perspective of a DevOps engineer that has been provided with an AsyncAPI definition that describes an application (or set of applications) that produceorderevents over various channels, including aKafka topic, aGoogle pub/sub topic, and anHTTP service.  The engineer's task is to ingestordersfrom these channels and route them to a single downstreamKafka topiccalledunified-orders.The tutorial leverages the TriggerMesh open-source command-line interface calledtmctlto create the TriggerMeshsources,brokers,triggers, andtargetsthat make up the event flow.tmctllets you run these components locally on any laptop that has Docker.The main components of TriggerMeshThe project includes aprototype parserbuilt with AsyncAPI'sjs-parser. It parses theprovided AsyncAPI definitionand generatestmctlCLI commands that create TriggerMesh event sources that ingest events from various channels into a TriggerMesh broker for further processing. You could write thetmctlcommands manually too, but this parser shows how a well-documented AsyncAPI definition can be used alongside TriggerMesh.The following schema illustrates what we'll build in this tutorial.Schema shows the event flow we'll build during the tutorialPlease reach out to the TriggerMesh team on theTriggerMesh Slack workspaceorGitHub TriggerMeshif you need help getting this to work or have any feedback.PrerequisitestmctlInstalltmctlwith homebrew orother methods:brew install triggermesh/cli/tmctlAsyncAPI'sjs-parserWe also need to install the AsyncAPI parser. Make sure you have a recent enough version of npm and node:npminstall @asyncapi/parserQuickstart a Kafka clusterOne of the order management systems is producingorderson a Kafka topic calledorders. We also want to write all unified orders to a downstreamunified-orderstopic. We'll need a cluster to implement these topics.Here we provide an easy way to start one usingRedpandaand Docker Compose, but you could use any Kafka distribution you like (self-hosted or managed).The provideddocker-compose filewill start a single node Redpanda cluster and a handy console. It is configured to work with the docker desktop and could require some adjustments to the listeners and advertised listeners for it to work on other environments. Reach out to us on Slack or GitHub if you need help, or read thiskafka listeners blog postif you want to dive deep into this.Run the following command in the same directory as the docker compose file to start Redpanda:docker-compose up -dStart a mock HTTP serviceWe'll start a mock HTTP service locally to simulate the order management system that providesordersthrough an HTTP API. Copy theorder.jsonfile to the current directory, it will be used as a mock event. Run the mock HTTP server, ideally in a new terminal (requires python 2 or 3):python3-m http.server8000(Optional) AsyncAPI CLIYou don't necessarily need it, but theAsyncAPI CLIis a great companion for working with AsyncAPI definitions during development, particularly the Studio that you can easily run in your browser to view or edit theprovided AsyncAPI definition.1brewinstallasyncapi2asyncapi start studio &Overview of the AsyncAPI definitionServersLet's see what is in ourAsyncAPI definition. We've defined three servers that represent the three order management systems. These definitions contain information we'll need to create the TriggerMesh source components that will read from these servers.1servers:2kafkaserver:3url:host.docker.internal:90924protocol:kafka5httpserver:6url:http://host.docker.internal:80007protocol:http8googlepubsub:9url:https://cloud.google.com10protocol:googlepubsubChannelsI've defined one channel per order management system, each with its own reference to the server and bindings for its specific protocol. There may be ways to improve on this by creating a single channel that has different implementations depending on the server.1channels:2orders:3description:Kafkatopictowhichordersareproduced4servers:5-kafkaserver6subscribe:7message:8$ref:'#/components/messages/order'9/orders/order.json:10description:RESTAPIendpointthatrespondswithanorder11servers:12-httpserver13subscribe:14message:15$ref:'#/components/messages/order'16bindings:17http:18type:request19method:GET20orders-gcp:21description:Googlepub/subtopictowhichordersareproduced22servers:23-googlepubsub24subscribe:25message:26$ref:'#/components/messages/order'27bindings:28googlepubsub:29topic:projects/jmcx-asyncapi/topics/ordersgcpThere is nothing overly special about theordermessage and schema so we don't need to go into detail on it here (but you can see it at the end of theAsyncAPI definition).We can see that by combining information from the servers and the channels, we have everything we need (except, in some cases, auth credentials) to create TriggerMesh source components that can subscribe to and read from these channels. Let's do that!Generating the TriggerMesh source componentsLet's usethe parserto generate some TriggerMesh components that will consume events from the channels defined in the AsyncAPI definition.Make sure you're in the same directory as the JS file and try running the following command:nodeparser.jsIt should print the generatedtmctlcommands to standard out, and will also write them to a file calledtmctl.sh. It will overwrite the file on each run. It's contents should look something like this:1tmctlcreatebroker TriggerMeshAsyncAPI2tmctlcreatesource kafka --name orders-kafkasource --topic orders --bootstrapServers host.docker.internal:9092--groupID orders-group3tmctlcreatesource httppoller --name ordersorderjson-httppollersource --methodGET--endpointhttp://host.docker.internal:8000/order.json --interval 10s --eventType io.triggermesh.httppoller.event4tmctlcreatesource googlecloudpubsub --name orders-gcp-pubsubsource --topic projects/jmcx-asyncapi/topics/ordersgcp --serviceAccountKey $(cat serviceaccountkey.json)The first command creates a lightweight event broker, the central component that will decouple event producers and consumers, and provide pub/sub-style reliable delivery of events to their targets. The name of the broker is derived from the title of the AsyncAPI definition.Next, one source component is created perchannelthat provides asubscribeoperation and has a reference to aserverwith a supported protocol such ashttp,kafka, orgooglepubsub.To get this working on your environment, you may want to play with thebootstrapServersvalue for the Kafka source, and the endpointhostfor the HTTP poller source. You can change them in the AsyncAPI definition and then re-run the parser.
You'll also need to create a file calledserviceaccountkey.jsonwith a GCPservice account key, if you want to get the Google Pub/Sub channel working. If not, you can delete the Pub/Sub channel in the asyncAPI definition.You can visit the TriggerMesh documentation for theKafka source,HTTP Poller source, andGoogle Pub/Sub sourcefor more information on parameters and usage.We can now execute thesetmctlcommands to create the TriggerMesh components. You can either copy/paste them into your terminal or run the generated script:shtmctl.shOr you can pipe the output of the parser into the shell:nodeparser.js | shWe'll also open a second terminal and starttmctl watchto watch events flowing through the broker:tmctl watchOrders are already coming in from the HTTP serviceThe first thing you'll notice is that the HTTP poller is starting to produce events from the order management system that exposes the HTTP API, we can see the event showing up in the broker in thetmctl watchterminal:A CloudEvent that originates from the HTTP pollerThe poller is configured to fetch an event every 10 seconds. You can adjust the endpoint and other parameters depending on your environment and needs. I’m usinghost.docker.internalbecause I’m running on Docker Desktop.Ingest orders from KafkaNow we can send an order to theorderstopic and watch it land in the broker too. To do this, you can open the Redpanda console that was started in the docker compose and should be available athttp://localhost:8080/by default.Go to the orders topic and publish this:1{2"orderid":18,3"ordertime":1497014222380,4"region":"eu",5"category":"fashion",6"item": {7"itemid":"184",8"brand":"Patagonia",9"category":"Kids",10"name":"Tribbles Hoody"11}12}You should see it show up in the terminal that is runningtmctl watch:A new order from the Kafka channel shows up in TriggerMeshPub/SubThe same idea goes for the Google pub/sub topic. You can head to GCP and publish an event there and it'll also show up in the TriggerMesh broker:Publishing an event to a Google Pub/Sub topicRouting all orders to a single Kafka topicWe just showed how simple it was to captureorderevents from three different AsyncAPI channels with TriggerMesh. Now they are all arriving in our central broker, wrapped asCloudEventsso that they all have a uniform envelope that can be used to implement transformations and filters.Let's keep it simple here and route events from all sources to a new Kafka topic calledunified-orders. To do that, we'll start by creating a new Kafka target:tmctlcreatetargetkafka--nameunified-orders-target--topicunified-orders--bootstrapServers<serverURL>And then we can define a "catch-all" trigger that will send all events to that target:tmctlcreatetrigger--target unified-orders-targetAlthough we generally recommend being more specific when creating triggers by adding a list of event types that should fire the Trigger. For example I could send only the events from the HTTP service to the Kafka topic as such:tmctlcreatetrigger--target unified-orders-target --eventTypes io.triggermesh.httppoller.eventNow take a look at the RedPanda console and you should see all orders arriving on theunified-orders topic. You can send more orders into GCP Pub/Sub and AWS SQS and see them get routed to the Kafka topic.Wrap-upIn this post, we piped events from multiple AsyncAPI channels into a single Kafka topic. By pairing AsyncAPI with TriggerMesh, we can generate the TriggerMesh source components that will ingest and centralize the events into a broker. From there, we can start creating routes to deliver filtered sets of events to different targets. We did this with a Kafka target, but there aremany other targets available.If you wanted to take this example further, you could implement someJSON transformationsthat would standardize legacy order formats coming from some of the sources or could customize the format for a specific consumer on a new Kafka topic (as shown in the initial diagram). You could also model other parts of the architecture with their own AsyncAPI definitions.Oh and one more thing, try thetmctl dumpcommand. It will produce Kubernetes manifests that you can deploy onto a Kubernetes clusterwith TriggerMesh installedand run these event flows as a Kubernetes-native application.Head toAsyncAPI.comto learn more about AsyncAPI, and theTriggerMesh quickstartif you want to try outtmctlfor yourself. You can also reach theTriggerMesh community on Slack, we'd love to hear from you!All graphics byJonathan Michaux.
"""
--------------------------------------------------------------------------------


Post 46
ID: https://www.asyncapi.com/blog/asyncapi-ambassador-program?utm_source=rss
Title: AsyncAPI Ambasador Program
Link: https://www.asyncapi.com/blog/asyncapi-ambassador-program?utm_source=rss
Summary: Information about AsyncAPI Ambassador Program.
Content:
"""
AsyncAPI and its community have grown exponentially during the last few months. As a feedback exercise, both the project and the community are getting stronger with one another. The community is the driving force that leads the initiative and the bigger it gets, the greater the consistency and potential it has. It’s amazing to see a vast number of people who invest their time in disseminating and promoting the initiative through talks, articles, workshops, and program direction...To follow that line, the AsyncAPI Ambassador Program is one of the latest additions to the initiative to keep the community going.The program is, after all, a reaction to the natural impulse of the community. Thus, in this case, the ambassadors came before the Ambassadors Program itself. This proposal was born based on the recognition of the work of community members who invest their time in bringing AsyncAPI to the community and new potential users.AsyncAPI Ambassadors are passionate about open source. They are committed to making AsyncAPI an inclusive place for everyone and participate in leading and mentoring the community.Below are guidelines to be followed by anyone who wishes to become an ambassador:Promote user cooperation and disseminate the tools needed for any specific user.Engage with the project in some way, whether as a contributor, blogger, speaker, etc.Speak at community events or write technical content (e.g., blog posts) that solves community needs.Foster community growth and a welcoming environment to spread knowledge about the project.Why create an ambassador program?As we know, everyone has a unique way of looking at things and a person's abilities differ. Following that line, each ambassador can offer a different approach. They bring part of their essence into the content or the program where they are involved and disseminate. This is what brings human value to the project, enriching the conception and possibilities.The community is experiencing rapid growth. Over the past year, we started the Ambassadors Program and the AsyncAPI Mentorship program and participated in GSoD for the first time. As the community evolves, the initiative remains dynamic and open, driving new ideas and proposals.How does the program work?The Ambassador Program is a transparent system, just like any other management issue related to the initiative. Its success relies on diversity, inclusiveness, and integration. The goal is to materialize these concepts within the program.The process of recruiting ambassadors is completely open. If anyone meets the requirements, they only need to add themselves to thisdocument, attaching their personal information along with their contributions. The TSC members will then approve the proposal.Subsequently, all ambassador information will be displayed on the AsyncAPI website once the PR has been merged. The process tries to be simple, collaborative, and transparent as possible.More about AsyncAPI Ambassador ProgramThe minimum enrollment period for ambassadors is one year with the option to renew annually. At the end of each period, the number of participants will be assessed and confirmed on a yearly basis. To qualify as an ambassador, individuals must make at least four contributions per year, which may include articles, talks, videos, podcasts, presentations, or driving initiatives, etc.Ambassadors are entrusted with some amount of responsibilities. As a token of appreciation for their work, we try to compensate them with certain perks, including exclusive swags and  conference passes.Learn more about theAmbassador Program here.We are waiting for you on board!🚀Photo byIan SchneideronUnsplash
"""
--------------------------------------------------------------------------------


Post 47
ID: https://www.asyncapi.com/blog/socketio-automatic-docs?utm_source=rss
Title: Flask-SocketIO Automated Documentation and Validation
Link: https://www.asyncapi.com/blog/socketio-automatic-docs?utm_source=rss
Summary: What is Flask-SocketIO, SocketIO?

If you are reading this blog, you are probably already familiar with SocketIO python-socketio and Flask-SocketIO. If you want to learn more about them, please check
Content:
"""
What is Flask-SocketIO, SocketIO?If you are reading this blog, you are probably already familiar with SocketIOpython-socketioandFlask-SocketIO. If you want to learn more about them, please check the following resources:https://socket.io/docs/v4/https://www.asyncapi.com/blog/socketio-part1https://www.asyncapi.com/blog/socketio-part2The problemImagine that you are working on a large project that uses a Flask-SocketIO server to handle real-time communication between the client and the server. The server was originally well-documented, but over time the documentation has become out of date as the server has evolved and new features have been added.I found myself in the same situation. I needed to maintain and constantly add more documentation to a Flask-SocketIO server. To make this process more efficient, I sought a solution to automate documentation generation from the existing codebase. This would eliminate the need for team members to manually edit the AsyncAPI specification file every time there was a change, a challenging task for those unfamiliar with AsyncAPI. By automating this process, we could save time and reduce the workload for the team.To address this issue, I decided to implement SIO-AsyncAPI. This tool allows you to generate an AsyncAPI specification from your SocketIO server and validate incoming and outgoing messages against it. This functionality is similar to how FastAPI, Flask-RESTful, and other frameworks have long provided it for RESTful servers. Now, withSIO-AsyncAPI, it is possible to apply this approach to SocketIO servers as well.How to use SIO-AsyncAPIInstead of giving you a detailed, step-by-step guide, we'll use a more exciting approach. We'll take the existing Flask-SocketIO server and add SIO-AsyncAPI. To make things even more interesting, we'll askChatGPTto generate a server for us and use it as a real-world Flask-SocketIO server.Generate a Flask-SocketIO serverI had to ask ChatGPT for multiple alterations to get the desired result. Here are my queries to ChatGPT:create python flask-socket server that provides tic tac toe game apichange previous code and add type hintsfor previous example use pydantic models instead of dictionariesAnd here is the final code that ChatGPT generated for us:1fromtypingimportList,Union23fromflaskimportFlask4fromflask_socketioimportSocketIO, emit5frompydanticimportBaseModel67app = Flask(__name__)8socketio = SocketIO(app)910games:dict[int,'Game'] = {}1112classGame(BaseModel):13board:List[List[str]]14turn:str1516classMakeMoveData(BaseModel):17game_id:int18x:int19y:int2021@socketio.on('create_game')22defcreate_game() ->None:23# Create a new game and add it to the list of games24game_id =len(games) +125games[game_id] = Game(board=[[''for_inrange(3)]for_inrange(3)], turn='X')2627# Send the game id to the client28emit('game_created', {'game_id': game_id})2930@socketio.on('make_move')31defmake_move(data: MakeMoveData) ->None:32# Get the game and make the move33game = games[data.game_id]34board = game.board35turn = game.turn36board[data.x][data.y] = turn3738# Check for a win or draw39result = check_game_status(board)4041# Update the game state and send it to the client42ifresult =='X':43emit('game_won', {'winner':'X'})44elifresult =='O':45emit('game_won', {'winner':'O'})46elifresult =='draw':47emit('game_drawn', {})48else:49games[data.game_id] = Game(board=board, turn='O'ifturn =='X'else'X')50emit('move_made', {'board': board,'turn': game.turn})5152defcheck_game_status(board:List[List[str]]) ->Union[str,None]:53# Check for a win or draw54foriinrange(3):55ifboard[i] == ['X','X','X']:56return'X'57ifboard[i] == ['O','O','O']:58return'O'59ifall(board[i][i] =='X'foriinrange(3)):60return'X'61ifall(board[i][i] =='O'foriinrange(3)):62return'O'63ifall(board[i][j] !=''foriinrange(3)forjinrange(3)):64return'draw'65returnNone666768if__name__ =='__main__':69socketio.run(app, debug=True)70It's not quite correct (e.g. data inmake_movewill be passed as a dictionary, not a Pydantic model), but it's good enough for our purposes.Generate Mermaid diagramNow let's ask ChatGPT to generate a Mermaid diagram for us as well, so we can get a better illustration of our server:create mermaid diagram for previous exampleI had to alter the given diagram a bit, but here is the final result:Add SIO-AsyncAPI to the serverNow let's imagine that this is our old server written in Flask-SocketIO and we want to add SIO-AsyncAPI. Here is how we would do it:Install SIO-AsyncAPI viapip install sio-asyncapiChange import statements1# instead of `from flask_socketio import SocketIO`2fromsio_asyncapiimportAsyncAPISocketIOasSocketIOAdd an additional argument to theAsyncAPISocketIOconstructor1socketio = SocketIO(2app,3validate=True,4generate_docs=True,5version="1.0.0",6title="Tic-Tac-Toe API",7description="Tic-Tac-Toe Game API",8server_url="http://localhost:5000",9server_name="TIC_TAC_TOE_BACKEND",10)Tell the@socketio.ondecorator to get models from the type hint.Note: you can also passrequest_modelandresponse_modelarguments to the@socketio.ondecorator instead of using type hints.@socketio.on('make_move', get_from_typehint=True)Now type annotations will be used to generate the AsyncAPI specification and validate incoming/outgoing messages. Note that the return value from a function is not data sent by theemitfunction but rather theacknowledgevalue that the client receives.Add anon_emitdecorator to register/document a SocketIO emit event. Since we are not definingemitfunction ourselves but only calling it, we need to tell SIO-AsyncAPI what to expect whenemitis called. E.g1classGameCreatedData(BaseModel):2game_id:int34@socketio.doc_emit('game_created', GameCreatedData)5@socketio.on('create_game')6defcreate_game():7...8emit('game_created', {'game_id': game_id})Get AsyncAPI specificationNow we can get the AsyncAPI specification by calling thesocketio.asyncapi_doc.get_yaml()function. Here is what the rendered specification looks like:Validation and Error handlingSIO-AsyncAPI will automatically validate incoming and outgoing messages. If a message is invalid, it will raise one of these 3 exceptions:EmitValidationError,RequestValidationError, orResponseValidationError.Flask-SocketIO has the@socketio.on_error_defaultdecorator for default error handling that we can use. E.g.:1@socketio.on_error_default2defdefault_error_handler(e: Exception):3"""4Default error handler. It is called if no other error handler is defined.5Handles RequestValidationError, EmitValidationError, and ResponseValidationError errors.6"""7ifisinstance(e, RequestValidationError):8logger.error(f"Request validation error:{e}")9return{'error':str(e)}10elifisinstance(e, ResponseValidationError):11logger.critical(f"Response validation error:{e}")12raisee13ifisinstance(e, EmitValidationError):14logger.critical(f"Emit validation error:{e}")15raisee16else:17logger.critical(f"Unknown error:{e}")18raiseeInstead of re-raising exceptions, we can return some error interpreted as anacknowledgevalue sent to the client. That's what we do in the example above when there is aRequestValidationError.This is how it looks like in FireCamp if we do not providegame_idin themake_moverequest:Because themake_moverequest may return an error in the acknowledged value now, we should add a newMakeMoveAckDatamodel and annotate themake_movefunction accordingly. This will automatically update the documentation in our AsyncAPI specification.1classMakeMoveAckData(BaseModel):2error:Optional[str] = Field(None, description='The error message', example='Invalid move')34...5@socketio.on('make_move', get_from_typehint=True)6defmake_move(data: MakeMoveData) -> MakeMoveAckData:7...Final Code and SpecificationHere is the final code of the server. I also added examples to Pydantic models to make the specification more readable.1importpathlib2fromtypingimportList,Union,Optional34fromflaskimportFlask5fromflask_socketioimportemit6frompydanticimportBaseModel, Field7fromloguruimportlogger89fromsio_asyncapiimportAsyncAPISocketIOasSocketIO10fromsio_asyncapiimport(EmitValidationError, RequestValidationError,11ResponseValidationError)1213app = Flask(__name__)1415socketio = SocketIO(16app,17validate=True,18generate_docs=True,19version="1.0.0",20title="Tic-Tac-Toe API",21description="Tic-Tac-Toe Game API",22server_url="http://localhost:5000",23server_name="TIC_TAC_TOE_BACKEND",24)2526games:dict[int,'Game'] = {}272829classGame(BaseModel):30board:List[List[str]] = Field(..., description='The game board', example=[31['X','O',''], ['','X',''], ['','','O']])32turn:str= Field(..., description='The current turn', example='X')333435classMakeMoveData(BaseModel):36game_id:int= Field(..., description='The game id', example=1)37x:int= Field(..., description='The x coordinate', example=0)38y:int= Field(..., description='The y coordinate', example=0)394041classGameCreatedData(BaseModel):42game_id:int= Field(..., description='The game id', example=1)434445classGameWonData(BaseModel):46winner:str= Field(..., description='The winner', example='X')474849classGameDrawnData(BaseModel):50pass515253classMoveMadeData(BaseModel):54board:List[List[str]] = Field(..., description='The game board', example=[55['X','O',''], ['','X',''], ['','','O']])56turn:str= Field(..., description='The current turn', example='X')5758classMakeMoveAckData(BaseModel):59error:Optional[str] = Field(None, description='The error message', example='Invalid move')6061@socketio.doc_emit('game_created', GameCreatedData)62@socketio.on('create_game')63defcreate_game():64# Create a new game and add it to the list of games65game_id =len(games) +166games[game_id] = Game(board=[[''for_inrange(3)]for_inrange(3)], turn='X')6768# Send the game id to the client69emit('game_created', {'game_id': game_id})7071@socketio.doc_emit('game_won', GameWonData)72@socketio.doc_emit('game_drawn', GameDrawnData)73@socketio.doc_emit('move_made', MoveMadeData)74@socketio.on('make_move', get_from_typehint=True)75defmake_move(data: MakeMoveData) -> MakeMoveAckData:76# Get the game and make the move77logger.info(f'Making move{data}')78game = games[data.game_id]79board = game.board80turn = game.turn81board[data.x][data.y] = turn8283# Check for a win or draw84result = check_game_status(board)8586logger.info(f'Game result:{result}')87# Update the game state and send it to the client88ifresult =='X':89emit('game_won', {'winner':'X'})90elifresult =='O':91emit('game_won', {'winner':'O'})92elifresult =='draw':93emit('game_drawn', {})94else:95games[data.game_id] = Game(board=board, turn='O'ifturn =='X'else'X')96emit('move_made', {'board': board,'turn': game.turn})9798defcheck_game_status(board:List[List[str]]) ->Union[str,None]:99# Check for a win or draw100foriinrange(3):101ifboard[i] == ['X','X','X']:102return'X'103ifboard[i] == ['O','O','O']:104return'O'105ifall(board[i][i] =='X'foriinrange(3)):106return'X'107ifall(board[i][i] =='O'foriinrange(3)):108return'O'109ifall(board[i][j] !=''foriinrange(3)forjinrange(3)):110return'draw'111returnNone112113@socketio.on_error_default114defdefault_error_handler(e: Exception):115"""116default error handler. it called if no other error handler defined.117handles requestvalidationerror, emitvalidationerror and responsevalidationerror errors.118"""119ifisinstance(e, RequestValidationError):120logger.error(f"request validation error:{e}")121return{'error':str(e)}122elifisinstance(e, ResponseValidationError):123logger.critical(f"response validation error:{e}")124raisee125ifisinstance(e, EmitValidationError):126logger.critical(f"emit validation error:{e}")127raisee128else:129logger.critical(f"unknown error:{e}")130raisee131132if__name__ =='__main__':133# generate the asyncapi doc134path = pathlib.Path(__file__).parent /"chat_gpt_asyncapi.yaml"135doc_str = socketio.asyncapi_doc.get_yaml()136withopen(path,"w")asf:137# doc_str = spec.get_json_str_doc()138f.write(doc_str)139# run the app140socketio.run(app, debug=True)141And here is the auto generated specification:1asyncapi:2.5.02channels:3/:4publish:5message:6oneOf:7-$ref:'#/components/messages/Create_Game'8-$ref:'#/components/messages/Make_Move'9subscribe:10message:11oneOf:12-$ref:'#/components/messages/game_created'13-$ref:'#/components/messages/move_made'14-$ref:'#/components/messages/game_drawn'15-$ref:'#/components/messages/game_won'16x-handlers:17disconnect:disconnect18components:19messages:20Create_Game:21description:''22name:create_game23Make_Move:24description:''25name:make_move26payload:27$ref:'#/components/schemas/MakeMoveData'28deprecated:false29x-ack:30properties:31error:32description:Theerrormessage33example:Invalidmove34title:Error35type:string36title:MakeMoveAckData37type:object38game_created:39description:''40name:game_created41payload:42$ref:'#/components/schemas/GameCreatedData'43deprecated:false44game_drawn:45description:''46name:game_drawn47payload:48$ref:'#/components/schemas/GameDrawnData'49deprecated:false50game_won:51description:''52name:game_won53payload:54$ref:'#/components/schemas/GameWonData'55deprecated:false56move_made:57description:''58name:move_made59payload:60$ref:'#/components/schemas/MoveMadeData'61deprecated:false62schemas:63GameCreatedData:64properties:65game_id:66description:Thegameid67example:168title:GameId69type:integer70required:71-game_id72title:GameCreatedData73type:object74GameDrawnData:75properties:{}76title:GameDrawnData77type:object78GameWonData:79properties:80winner:81description:Thewinner82example:X83title:Winner84type:string85required:86-winner87title:GameWonData88type:object89MakeMoveAckData:90properties:91error:92description:Theerrormessage93example:Invalidmove94title:Error95type:string96title:MakeMoveAckData97type:object98MakeMoveData:99properties:100game_id:101description:Thegameid102example:1103title:GameId104type:integer105x:106description:Thexcoordinate107example:0108title:X109type:integer110y:111description:Theycoordinate112example:0113title:Y114type:integer115required:116-game_id117-x118-y119title:MakeMoveData120type:object121MoveMadeData:122properties:123board:124description:Thegameboard125example:126--X127-O128-''129--''130-X131-''132--''133-''134-O135items:136items:137type:string138type:array139title:Board140type:array141turn:142description:Thecurrentturn143example:X144title:Turn145type:string146required:147-board148-turn149title:MoveMadeData150type:object151NoSpec:152deprecated:false153description:Specificationisnotprovided154info:155description:'Tic-Tac-Toe Game API156157<br/> AsyncAPI currently does not support Socket.IO binding and Web Socket like158syntax used for now.159160In order to add support for Socket.IO ACK value, AsyncAPI is extended with with161x-ack keyword.162163This documentation should **NOT** be used for generating code due to these limitations.164165'166title:Tic-Tac-ToeAPI167version:1.0.0168servers:169TIC_TAC_TOE_BACKEND:170protocol:socketio171url:http://localhost:5000Cover image byWindmills During DawnfromUnsplash
"""
--------------------------------------------------------------------------------


Post 48
ID: https://www.asyncapi.com/blog/2022-summary?utm_source=rss
Title: State of AsyncAPI Initiative 2022 in Numbers
Link: https://www.asyncapi.com/blog/2022-summary?utm_source=rss
Summary: tl;dr We do not see any negative trends indicating that the interest in the project got stale and that the community is not growing anymore.
Content:
"""
It is a good practice to sometimes stop and turn back. Sometimes you need to see what you left behind, what successes made you go that far, and what things you missed and never had time to enjoy or explore. The more often you do it, the better your decisions may be in the future. It is essential to do it at least once a year in open source.Omg, I don't recall when I last wrote something so clever. At least, I think it sounds clever.😃This article will take you on a journey to the past to see what happened in 2022 at AsyncAPI Initiative.If you are interested in previous project updatescheck otherProject Statusposts.SlackAt the end of 2022, we had3114members in the AsyncAPI workspace. But what does that really mean? Don't get me wrong; I like when the numbers are high, especially if I see them in my bank account.The thing is that some accounts might belong to people that joined three years ago but don't even remember that they had an account in the AsyncAPI workspace. It would be good to check how this number relates to people's activity.Another important item to understand is how come we have3114members. Did all of them join in 2016? Have we had no new people join since then? That would be a disaster and a clear indication we are doing something wrong.😅Workspace sizeBelow you can see how many members have joined AsyncAPI Slack in past years. The numbers are pretty neat! People join AsyncAPI Slack because they know:someone will answer their call for helpit is a welcoming place for first-time contributorswe participate in many mentorship programsthis is the best place to get closer together with the communityMy prediction is that it will be growing and growing cause existing members will tell others what place it is and why it is worth joining.Weekly active membersBelow I'm showing the average and median activity throughout the years. I think the median is more accurate as it eliminates super-high weeks (like typical conference-related noise) and weeks when we have lots of holidays simultaneously, like Christmas break.Last year was the first time the median value was much lower than the average. It is higher than the previous year, but not something we got used to so far. We noticed a significant increase in Slack members, but I think we can say that this number doesn't correlate well with median activity.We should look into the data more deeply and understand what happened between April 23 and June 21 when numbers got much higher than usual. For example, what the heck happened on April 29 when we had 583 active members? Was AsyncAPI Mentorship the reason?Anyway, I definitely predict that data for 2023 will show an increase in activity as we plan to do a series of meetups around the world that will bring more and more people into Slack.Channels popularityBelow you can see all-time data that show the number of messages posted on each channel in Slack.TheGeneralchannel is the oldest, and yeah, it is generally for general stuff... what a joker. Anyway, the most important is the discussion size in theToolingchannel. Specifications are boring, and people are interested more in how it works. On the other hand, tooling is most attractive to tech folks; coding and talking about it is more fun.Remember that AsyncAPI Initiative cares about both the specification and the tooling ecosystem.New members' activityAs I wrote in the intro, each community must be welcoming to new people and give them space inside so they feel comfortable interacting with others and feeling safe.Below you can see the top three members that joined the community in 2022 and were most active among other new-joiners. Their activity was clearly reflected in their contributions. In the end, all the people you can see below are now members of theAsyncAPI Technical Steering Committee.Social mediaSocial media is not a silver bullet. I think social media should only be a news interface with the community, not a marketing tool.Below data will show you that these channels should not be treated as promotion channels that convert to new users. You will see that LinkedIn and Twitter brought together 2,082 users to the AsyncAPI website. Now, compare it to this singleMozilla documentation articlethat referred to our website 5,542 users.Social media is suitable for communication with the community. Promotion should target people in a location where they look for help. In other words, mentioning AsyncAPI on a WebSocket-related website performs much better than hundreds of social media posts. So we should also try to make sure AsyncAPI is mentioned in other locations. Why not mention AsyncAPI in official docs for Kafka, MQTT, and other protocols?LinkedInI'm so damn tired of LinkedIn. Seriously, a platform that drains so much data from others and earns money from job marketing cannot afford to give users access to historical data and see more than one-year-old stats. Like seriously...We had 2,139 followers at the end of 2022. Every year's data since account creation looks like below.We are not active on LinkedIn. We only republish whatever we publish on Twitter. No engagement is created. We treat it as a news feed, although LinkedIn != Twitter.Numbers went down a lot compared to last year, but when you look two years back, numbers are very similar. Why? In 2021, we spent $1,200 on LinkedIn marketing; thus, the number spike for one year.My statement doesn't change. LinkedIn is an important presence, and even without dedicated moderation, simple reposting brings people to the project. We should continue our work there.TwitterTwitter? Seriously, the most unreliable tool ever.😃But of course, I'm biased; I do not like it. So let's look at the data. Are people really leaving Twitter because of Elon Musk?Forget about the number of followers. We have over 3.5k followers, over 500 more than last year. For me, followers number are as reliable as GitHub stars on a repository. Not much...Let's see how Twitter's presence converts to visits to the AsyncAPI website.Exactly the same situation as with LinkedIn. Numbers drop between 2021 and 2022, but again because 2021 was a special year. We experimented that year with paid marketing on Twitter too. So the numbers we should compare are for the years 2020 and 2022. As we can see no change, and it is pretty stable. It looks like Twitter was not really abandoned, at least not for now😃.My take on it. This is acceptable. I do not think we have to do more there. My observation is that tweets that perform there are not technical tweets that could bring more people to the project, but "thank you" tweets and "appreciation" tweets. And do not get me wrong, we should still create such tweets, no question about it. It proves it is a social media, not a "technical geeks knowledge exchange center." I do not think any additional investment in the platform makes sense.Google AnalyticsWe use Google Analytics onAsyncAPI websiteto understand the most valuable content for you and learn how the interest is growing. The data we get doesn't 100% reflect reality because AsyncAPI is for technical people, and many technical people use plugins in browsers to block Google Analytics or browsers that block it natively.We also have numbers that confirm that. I checked the last seven days of data from Google Analytics and compared it with the raw traffic data we get from Netlify servers. The dates I checked were February 13-20:Google Analytics noted over 24k page views.Netlify noted over 26k page views.This means we are losing around 7% of the data if I calculated it right.😃Unfortunately, with Netlify we do not have access to data older than seven days. We can dump this data for future analytics, but we need New Relic or some other service to sponsor the storage for us😃Confusing dataThe "quality" of the user visiting the website is much better. In 2022, we had no paid marketing nor any viral blog posts, and finally, data is more reliable and natural.There is a much larger increase in the amount ofPageviewsandSessionsbut no significant increase inUser visits. My theory: In 2022, we didn't have a single super viral blog post like in previous years that would bring a few thousand people in just a few days (like September 9, 2021 - over 5k readers), people that are interested in an article, and not AsyncAPI in general.I think we can say that it is the first time we have had a regular increase in users and that this increase is valuable as these users generate a lot of sessions and navigate through the website a lot. In other words, the bigger difference betweenUser visitsandPageviews, the better.It would make sense to retake the above table and check it against Google Analytics, but not base it on the total number of visits and sessions, but the median for each year. In theory, this way, we would remove the traffic that is hard to predict from the equation, as it is not up to us to decide if something will be viral.The more docs we get, the more traffic increase we will seeOne of the top goals for the AsyncAPI website should be to increase the content and benefit from the SEO. This happened in 2022, thanks to participation in Google Season of Docs. We had six dedicated docs contributors. We gained newConceptsandGeneratordocumentation in the website.In the case of Generator documentation, Florence and Pratik refactored all the documentation from the Generator repository and made sure it was published in an automated way on the website. It was published on the website on the 20th of December, almost the end of the year during Christmas break, a dead season for the website. Yet the new content managed to generate an additional 1,053 Pageviews to the website!Concepts were published to the website on different dates, some in September and some in early December. This new content generated more than 17,646 Pageviews in over three months.As you can see, more technical content, which was not even released at the beginning of the year, converted into many additional pageviews. In 2023, this content will perform even better. I know it for sure, as only in the case of Generator docs, in January 2023, Google Analytics noted 4,668 views! Well, you must admit that 48kPageviewsfor 2023 would be huge!Google Search ConsoleI believe that numbers from GSC can show how many more people hear about AsyncAPI and gain interest in the topic. In other words, the assumption is that the more people google, the more people are aware of AsyncAPI. And yes, the below numbers of impressions indicate a number higher than a million.😉In 2022 we didn't perform any specific modifications on the website to improve SEO. So the only explanation for the increase in impressions and clicks is the increased volume of documentation I wrote about in the previous section. More useful content, better ranking in search.GitHubLike on other channels, we notice growing traffic inour GitHub organization.Total contributionsIn the last three years, we increased from 301 contributors in Q1 2020 to 1,520 in Q4 2022.From 301 to 1,520 contributors for things like commits, pull requests authoring and review, or issues participation. In just three years!!!This huge difference also has a negative aspect. More contributions mean more maintenance work.Negative aspect of growthUnfortunately, the number of maintainers does not grow as much as the number of contributors. This means that the difference between the number of submitted and resolved issues will get larger and larger.Three years ago, we dreamed about having thousands of contributions. We forgot to balance that number with the proper number of maintainers. Now we need to react and make sure we also get a large number of active maintainers.npmMost of our tools are written in JavaScript/TypeScript; we host them on Node Package Manager (npm).Top packagesOur most essential packages arethe project that provides AsyncAPI JSON Schema files,the Generator,the React componentandthe Parser. Below you can see how downloads of these packages increased.You do not believe in this data? Lemme repeat what I wrote last year:The increase in numbers is insanely huge. People automatically say that it is because of build systems, local development, or that some single corporation started using it at scale. In other words, the increase could result from just one project that uses these tools as a dependency.Let me challenge you:Corporations always use mirrored versions in npm. When you work on a project in a corporate network, you will always hit the internal proxy. Not included in downloads.Most build systems cache packages downloaded are ready to improve performance. Not included in downloads.When you work with npm locally, you also have a local cache that is used if you want to install something that you already installed. Not included in downloads.An interesting observation is that in 2021 AsyncAPI Parser was the only user of the AsyncAPI spec JSON schemas project (@asyncapi/specs), as the number of downloads was almost the same. In 2022, the AsyncAPI spec JSON schemas project was downloaded five million times, three times more than the parser. This means many more tools are dependent on the project.In 2021 we could see that the AsyncAPI Parser is not only a Generator dependency; today we see the AsyncAPI spec JSON schemas project is not only a Parser dependency. This means that the increase in traffic in different channels and the growing user base also reflect the number of tools built on top of AsyncAPI tools. One of the big users of@asyncapi/specsis now Spectral. Also, GitHub tells us that@asyncapi/specsis used in 1,329 public repositoriesYouTubeTheAsyncAPI YouTube channelhad a massive increase in traffic.Watch timeYouTube is just another channel where we can see the audience is growing. The conference and other regular live streams bring a lot of watchers. In 2023, numbers might drop because we do not want to do the online conference, but yeah, let's see.Final wordsWe grow. Numbers just confirm our observation.If you plan to invest in AsyncAPI Initiative, don't worry. It is still an on-top project.It was the right call if you already invested in AsyncAPI Initiative. The community is growing.We do not see any negative trends indicating that the interest in the project got stale and that the community is not growing anymore.I also recommend below conference recording to learn more about AsyncAPI Community.Photo byHannah BusingonUnsplash
"""
--------------------------------------------------------------------------------


Post 49
ID: https://www.asyncapi.com/blog/new-asyncapi-tools-page?utm_source=rss
Title: New Tools Dashboard for AsyncAPI
Link: https://www.asyncapi.com/blog/new-asyncapi-tools-page?utm_source=rss
Summary: Announcing our newly released AsyncAPI tools dashboard!
Content:
"""
We already know that the present list of tools used inside AsyncAPI is presented onAsyncAPI Tools Overviewand it is manually maintained inside the GitHub repository. All the tools are sorted according to the different categories in which they are used and maintained by the contributors. But we don't have a way to filter the tools according to our interest🤔, like languages, technologies used in it, open-source tools, etc. Also, what if you want to add your tool to the list, what you will do🤔? Do you have to create a PR?What if I say, you don't need to make a mess of PR now😉. Yep, we're introducing a new way to add tools to our website! Keep reading below to learn all about it👇.AsyncAPI Tool FileWe have introduced a new concept of the.asyncapi-toolfile which describes the type and details of a tool related to AsyncAPI. You create such a file with a set of different information that describes your tool and then within a week such information is added to the AsyncAPI website. But the question is, where you should place such a file? Inside AsyncAPI repositories? Definitely not! Here comes the twist, this file will be created and maintained in your Tool's repository, and it won't ask for our approval. This file will follow a certain schema that you have to follow to successfully and appropriately add your tool to our brand newAsyncAPI Tools Dashboard. Theproper schema of the file is described here. You can use the tools like theOnline JSON Validatorto validate your JSON data for Tools against the schema given above. For a more detailed explanation, you can refer to ourofficial.asyncapi-toolfile documentation.Tool File StructureHere's the sample.asyncapi-toolfile structure, which can be used to structurise your tool configuration.1{2"title":"ZenWave Code Generator",3"description":"DDD and API-First for Event-Driven Microservices",4"links": {5"websiteUrl":"https://zenwave360.github.io/",6"docsUrl":"https://zenwave360.github.io/zenwave-code-generator/plugins/asyncapi-spring-cloud-streams3/",7"repoUrl":"https://github.com/zenwave360/zenwave-code-generator"8},9"filters": {10"language":"Java",11"technology": [12"Maven",13"Spring Cloud Streams"14],15"categories": [16"code-generator",17"dsl",18"mocking-and-testing",19"cli"20],21"hasCommercial":false22}23}This file structure should be used to insert your tool into the website. The fields specified above are explained below:title- Specifies the title or name of the Tool. Remember this name will be used as the official name of your tool on the website.description- Specify the tool description. It should be precise, up to 30 words only.links- Object which contains important links related to the tool.websiteUrl- This is an optional field that specifies the URL of the tool's website.docsUrl- This is an optional field that specifies the URL of the tool's documentation.repoUrl- This is an optional field that specifies the URL of the tool's GitHub repository.filters- Object that contains various fields like language, technologies, and categories to provide information about the tool.language- Specifies the primary Language in which the tool has been created. There are predefined languages listed in our documentation that are available right now and will be expanded to add new languages if needed.technology- Specifies the list of technologies that are used to create the tool. There are predefined technologies listed in our documentation that are available right now and will be expanded to add new languages if needed.categories- Specifies the list of categories that defines the type of tool. There are predefined categories listed in our documentation that can be used to list down your tool under the proper category.hasCommercial- Specifies whether the tool is a commercial product or is open source.The predefined list of technologies can be found in our repository and are listed as:Languages and TechnologiesCategoriesAsyncAPI Tools DashboardOhh! Wait a minute, have I told you about the new AsyncAPI Tools Dashboard? Then, let me present you with a brand new and astonishing AsyncAPI Tools Dashboard, which has a list of Tools presented in the form of cards. Do check it out right now -AsyncAPI Tools Dashboard. The preview of the UI is as follows:The Dashboard consists of various features like the overall information about the tools inside the ToolCard, filters to sort out the tools according to your needs, and a search bar for finding tools specific to name/type.Tool CardTaking the Tools Card under consideration, you have the following sections to detail about a Tool:Specifies the Name of the Tool.Specifies whether the Tool is Free to use or requires commercial access to use it.Specifies the Description of the Tool. Clicking on theShow Morebutton will open a small box to show full description of the Tool.Specifies the Primary Language of the Tool in which it is built.Specifies the list of Technologies used to create the Tool.View on GithubButton that directs the user to the Github repository of the Tool.Visit WebsiteButton that directs the user to the official website of the Tool.Visit DocsButton that directs the user to the official Docs of the Tool.Filters for ToolsThe Dashboard also contains various filters to search for a specific Tool according to your needs. You can now search according to the Name, Languages, Technologies, Categories, and more, as provided in respective dropdowns and radio buttons. Filters are mostly divided into 2 sections - Filter Menu and Search bar. The use of each menu is explained below under respective subheadings.Filter MenuTaking the Tools Filter Menu under consideration, you have following filters to search a Tool:This radio filter button allows you to search for either free tools available on the internet or GitHub, or search for Paid Tools.The slider filter button allows searching for the tools owned or maintained by the AsyncAPI organization.TheLanguage Filterallows you to select the languages from the dropdown on which you want to search for Tools.TheTechnology Filterallows you to select the technologies from the dropdown on which you want to search for Tools.TheClear Filtersbutton allows you to clear all filters inside the Filters Modal and will show you all the tools of selected categories (or all categories).Do remember to click on theApply FilterButton before closing theFiltersModal so that filters will be applied on the Dashboard.Search BarThe Search Bar will allow you to search the tools on the basis of their names.SummaryI completed this project during the 2022 AsyncAPI Mentorship program, mentored byLukasz GornickiandMaciej Urbańczyk. It was an amazing experience to work on this project and create an automation for AsyncAPI tools. Quite a good learning experience as I researched GitHub APIs, JSON Schema, GitHub Actions, and a lot more stuff. Moreover, I became a maintainer of the AsyncAPI website repository and started contributing to the organization in lot many ways. My work in the project consists of the following Pull Requests:feat: tools backend implementationfeat: added new /tools pagefeat: manual tools added to the Tools DashboardYou are welcome to review my work in the program and I will love to get your feedback on this. You can contact me viamy emailor DM me inAsyncAPI Slack. Thank you to AsyncAPI and its community members for providing me with this opportunity and I'll be looking for more such activities to contribute to the organization. Also, we are close to announcing the next AsyncAPI Mentorship Program in the year 2023, so stay tuned with us onAsyncAPI Slack.Photo by DEWALT hand tools:https://www.dewalt.com/products/hand-tools
"""
--------------------------------------------------------------------------------


Post 50
ID: https://www.asyncapi.com/blog/release-notes-2.6.0?utm_source=rss
Title: AsyncAPI Spec 2.6.0 Release Notes
Link: https://www.asyncapi.com/blog/release-notes-2.6.0?utm_source=rss
Summary: The release of AsyncAPI 2.6 added an exciting feature which is the support for Apache Pulsar
Content:
"""
The new version of the AsyncAPI specification - 2.6.0 - is now available.This is a minor release and doesn't bring any breaking changes. You can switch to it by modifying the following value in your AsyncAPI fileasyncapi: '2.5.0'intoasyncapi: '2.6.0'Added Pulsar Bindings and Protocol to AsyncAPI specificationThe specification now supports a new custom protocol through the bindings feature calledPulsar.Here is an example of the server representation in Pulsar:1servers:2production:3bindings:4pulsar:5tenant:contoso6bindingVersion:'0.1.0'And also an example of the channel representation in Pulsar:1channels:2user-signedup:3bindings:4pulsar:5namespace:'staging'6persistence:'persistent'7compaction:10008geo-replication:9-'us-east1'10-'us-west1'11retention:12time:713size:100014ttl:36015deduplication:false16bindingVersion:'0.1.0'Thanks toAlex Wichmannfor this incredible feature.  For more details, check out thisPulsar bindings pull requestand thebinding definition.Photo by Clem Onojeghuo:https://www.pexels.com/photo/low-angle-photography-of-metal-building-on-grayscale-175771/
"""
--------------------------------------------------------------------------------


Post 51
ID: https://www.asyncapi.com/blog/a_straight_guide_to_apis_and_architecture_concepts?utm_source=rss
Title: A straight guide to APIs and architecture concepts
Link: https://www.asyncapi.com/blog/a_straight_guide_to_apis_and_architecture_concepts?utm_source=rss
Summary: Basic concepts about APIs and architectures for beginners and non-developers.
Content:
"""
It has not been such a long journey into the technology realm for me. Then I started to work at AsyncAPI, and suddenly, I needed to understand a complex world. New terms, code, and ways of seeing things were waiting for me. Coming from other fields of knowledge, the challenge was huge. How to begin? How to have a clue?I decided to start with the basics: trying to find a way to catch the meaning of some key ideas related to APIs. I read and reread over and over again definitions and more definitions. They were full of technical terms that distanced me from them rather than bringing me closer to understanding the concepts. I found myself diving into a deep and dark ocean. And I was too squared to flow in those turbulent currents. The alphabetical order is not a natural one. A dictionary is not a good tool for starting to know a language.Then, I decided to change direction, looking for data. I thought that checking some visual and intelligible sources might clarify my head. So I could understand where to put the information, helping me start weaving a tapestry. Nevertheless, not knowing the code made it difficult for me, if not impossible, to interpret rough data.Third attempt… I just remembered that someone said that practice makes perfect. So, the next try was in that direction. Playing an instrument is a better way to understand it than reading definitions or pentagrams. See it and touch it; feel the shape directly, the stage, the environment. It was time to take action: a colleague volunteered to guide me, practicing somehow with these concepts without prior knowledge. Just making fun, as a child, looking for references, playing, and understanding the technique while finding similarities and comparisons with real situations that anyone could understand pretty well.So, let’s talk some basic concepts:APISWhat is an API?APIs are program connectors. Synchronous or asynchronous, they act as glue between different applications or programs.As cables or pipes connecting different locations to facilitate information exchange or optimize resources.How does an API work?APIs act as an intercommunicator, linking one or more programs. Let's say they could be seen as a bridge between different places connecting them and transferring the required information through them. It’s a way to exchange data or give commands to each other.Types of APIsWe can classify them into two main groups, depending on their use or their type of architecture.Types of APIs according to their useInternal APIsare those used at a local level. They focus on communicating with each other within the same system or the same computer. An excellent example of them might be the pipes contained in a house. They connect the sink to the bathroom and the washing machine to the dryer, for example.External APIs, or web APIs, are those used to communicate two or more applications over the Internet. We could exemplify it with the pipes that connect different houses in the same block of apartments or neighborhoods.Partner APIsare a middle ground between internal and external APIs. This is because they are accessible to people outside the organization but only to those with exclusive permissions. Typically, this special access is granted to certain third parties to facilitate collaboration.A good example might be when we invite friends over, and they bring their controllers to play the game console. Or when a friend comes over and connects to our wifi network.According to its architectural styleIt is essential to choose the architecture style or pattern that best fits the desired use case for the API if specific functional capabilities are required. There are several architecture styles for APIs, as well as different data formats. The following are the most common:REST(representational transfer state), this architecture style separates the needs of the API user from those of the provider, thanks to commands embedded in the underlying network protocol. For example, Twitter provides a REST API that you can query for the latest tweets.RPCs(remote procedure calls), are styles that usually demand developers to perform specific code blocks on another system or different systems. RPCs are protocol-independent, making them potentially compatible with many protocols, although they do not include the benefits of using native protocol features.For example, the Network File System (NFS) plays an essential role in Unix and Linux. This system uses RPC between client and server to mount the set of files from a remote computer on a local computer, that is, to make them partially or entirely available on the latter, allowing the user to manage the files located on a remote device as if they had them on their computer.Event-driven, real-time, asynchronous, doesn't wait for the API user to make the call before sending a response. The response is issued as soon as an event occurs.A simple example might be LinkedIn notifying us that someone wants to connect with us.ArchitecturesNow that we have seen the classification of APIs, let's focus on the most representative types of architecture.In my opinion, this is the most interesting part. Understanding different construction models bring us closer to the skeleton of the system. By understanding this part, we can better sustain the concepts of APIs, supporting them on fundamental pillars.Monolithic architectureMonolithic architecture describes a kind of construction made from a single piece of material, historically from a rock, a standing stone. Indivisible. As a menhir, the simplest megalithic monument.The same goes for the traditional structure of software applications. Monolithic is an end-to-end architecture in which all aspects of the software function as a single unit.Microservices architectureMicroservices architecture is a method for developing software applications that consist of small, autonomous services. Each microservice's code can be written in a different language and perform specific functions. Microservices communicate with each other through APIs and have their own storage systems, which avoid overloading and crashing the application.An example of the use of this kind of architecture could be Netflix. This platform has a generalized microservices architecture. Every day it receives an average of one billion calls to its different services and can adapt to more than 800 types of devices through its video streaming API, which offers a more stable service. For each request we ask, it makes five requests to different servers to never lose the continuity of the transmission.We can do a simile with the work of bees. Among other things, they extract the nectar from the flowers that each hole in the comb needs, supplying every micro need of the beehive.Serverless architectureIt is a computing model that uses the cloud as the environment for executing applications and processes, dispensing with traditional servers. In this way, the Serverless architecture facilitates the work of developers.They can dispense with tasks such as allocating server resources, and focusing solely on application development. With Serverless, the code runs directly in containers.Any task requiring executing several functions simultaneously is a good use for serverless technology. These can be applied whenever concurrent computing is required.There isn't a better graphic example than a cloud.Event-driven architectureEvent-driven architecture, also known as EDA, is a software model and architecture used to design applications. Unlike other architectures, this one is characterized by asynchronous communication, which does not occur simultaneously.That is to say, the receiver will attend to the sender's message later after receiving it, so the sender can perform other tasks without waiting for the request to be answered. For example, sending an email that might be received 5, 50 minutes, or 5 hours later just because the server was attending to other deliveries.This is the kind of architecture that AsyncAPI works with. Its main goal is to make working with EDA as easy as working with REST APIs, from documentation to code generation, from discovery to event management.A good simile could be to send a message in a bottle. The information takes more or less to reach its destination depending on the currents of the sea.So, what is an API, ultimately…It's funny to notice that we live surrounded by things that sometimes we cannot even name. After all, I have started to know what an API is after noticing that I live and share space with them. There are many events for which this API model works well. A lot of examples to understand it. These are just a few: from online translators, such as Google Translate, to the moment when the temperature of a remote thermometer changes.Every concept, even the hardest to get, might always be communicated to everyone, not minding if we talk to children or people who don’t know anything about it. Just with different layers of meaning. It is always possible to make any parallel to real life, everyday objects, or situations. It doesn’t matter if we talk about kicking a ball or ordering a pizza. Every day we are surrounded by maths, physics, technology, code, and APIs… things that we are not able to see but that make things comprehensible and our life easier, sometimes. There are always codes and structures that give them shape.Following the path I walked before, it was my turn to explain the essential concepts of the API world without technicalities, creating simple comparisons that place us in the function of each thing. Just to make us understand the place of each piece in the puzzle. In case my experience is helpful to anyone. That’s the way I get it. And once you get it, it is forever.* Cover photo byShane Rounceon Unsplash;* Photo 1 byAzka Rayhansyahon Unsplash;* Photo 2 byEric Muhron Unsplash;* Photo 3 bySophie N.on Unsplash;* Photo 4 bySendi Gibranon Unsplash;* Photo 5 bySnapwireon Pexels.
"""
--------------------------------------------------------------------------------


Post 52
ID: https://www.asyncapi.com/blog/conference-2022?utm_source=rss
Title: 2022 AsyncAPI Conference was amazing!
Link: https://www.asyncapi.com/blog/conference-2022?utm_source=rss
Summary: The 2022 AsyncAPI Conference was amazing, and I had a great time. I volunteered at this conference, not knowing what to expect, and I must say, I left with a new resolve. The organization was top-notc
Content:
"""
The 2022 AsyncAPI Conference was amazing, and I had a great time. I volunteered at this conference, not knowing what to expect, and I must say, I left with a new resolve. The organization was top-notch, from interesting sessions to an amazing community.The challengesBecause AsyncAPI is a community-first organization, I was able to follow along with the whole process of planning the conference, and I could see some of the challenges the community faced when planning to organize the conference.Here are a few of the challenges:Went from hybrid to online: The event was supposed to be an in-person and virtual event held in Barcelona, Spain. But because the foundation they partnered with couldn't find a venue within the provided date, they had to scrap the in-person idea.Fewer Sponsors: I believe the whole planning for the 2022 AsyncAPI Conference started quite late, which made it difficult to get a budget for the event in such a short time.But despite these challenges, AsyncAPI still reached the top of the mountain by giving a blast conference with the power of the community.How was it doneAsyncAPI proved how much you can do when you have an amazing and strong community behind you.Despite AsyncAPI leveraging their experience hosting online events, they also created a conference support squad where so many amazing folks from the community volunteered, including me. This squad involves two categories of volunteers: on-stage and off-stage.This approach worked like a charm, bringing over 15 members of the community to help coordinate the conference in a collaborative way which, in my opinion, was what made the conference a blast!Was it worth it?I wouldn't say it was amazing if it weren't worth it! The conference was amazing thanks to the contributions from the organization, community, speakers, and sponsors.Look at the number of views we had on Youtube alone; don't forget numbers don't lie.Day 1: 584 viewsDay 2: 325 viewsDay 3: 247 viewsBut hold on, we celebrated too early because two weeks after the conference, the number of views doubled.Day 1 views grew to 1403Day 2 views grew to 1181Day 3 views grew to 400AsyncAPI also had significant women speakers & stream hosts. Isn't this an important move in the right direction for true diversity?A sneak peekThe AsyncAPI conference was so great that some of the sessions were not all technical; we had sessions where folks talked about their journey into Opensource and shared their experiences as a part of the AsyncAPI community.We've carefully curated this type of session for you, and it can be found in this youtube playlist calledInspire & Aspire with AsyncAPI.We also have all sessions from the conference recorded and available publicly. Feel free to check it out and shareAsyncAPI Conf 2022.Meet the heroesWith the help of these amazing organizations and individuals, AsyncAPI was able to host an incredible conference, and here's a special shoutout to each and every one of them.Meet the SponsorsPlatinum SponsorGold SponsorMedia SupportSpecial thanks to Restream for supporting us with their amazing product for media coverage.Meet the volunteersAishat MuibudeenAzeez ElegbedeBarbanio GonzálezBenjamin GranadosDale LaneDeepak VermaFran MéndezKaruna TataKhuda Dad NomaniLukasz GornickiMaciej UrbańczykMissy TurcoQuetzalli WritesSergio MoyaSouvikV Thulisile SibandaWeeProduccionesA glance at the budgetThanks to the conference sponsors, we were able to get some money to fund the conference and here's an overview of how much we raised and spent.IncomePostman - $4,854.70 (Platinum Sponsor)Ably - $2,882.70 (Gold Sponsor)Leftovers from conference 2021 - $7,951.71A total sum of $15,689.11 was raised for the 2022 AsyncAPI Conference.SpendingsSwags for speakers and people that helped run the event - $2,847.81Facebook ad - $114.40Linux Foundation services (registration and schedapp) - $10,000.00Descript licenses for speakers to provide high quality recordings - $696.79Headphones for Anisat - $21.74A total sum of $13,680.74 was spent on the conference needs.What's Next?Because the AsyncAPI Conference happens yearly, it means there will be another one next year(2023). I can't wait for it to happen because the community happens to have learned from its mistake by deciding to kick off the planning as early as possible and I believe this is a big step in the right direction. So many lessons learned to put into play for next year!Wrap upI am truly honored that the community "came together." This was 100% done with the community in mind, and each party involved in the conference has been thoughtfully and intentionally positioned to ensure the project is successful! Cheers to that success!We had a great time and learned a lot from this year's conference thanks to everyone who attended, was involved, and got behind AsyncAPI in putting this event on. We value and appreciate each and every one of you for making it a blast, and we can't wait to see you all next year.
"""
--------------------------------------------------------------------------------


Post 53
ID: https://www.asyncapi.com/blog/hacktoberfest-2022?utm_source=rss
Title: Hacktoberfest was a blast!
Link: https://www.asyncapi.com/blog/hacktoberfest-2022?utm_source=rss
Summary: Hacktoberfest was a blast this year! We can't believe it's over already. We had a great time participating with you all and wanted to share a bit of our experience in a review.

Why Hacktoberfest

Hac
Content:
"""
Hacktoberfest was a blast this year! We can't believe it's over already. We had a great time participating with you all and wanted to share a bit of our experience in a review.Why HacktoberfestHacktoberfest is an annual event that encourages people to contribute to open source throughout October. AsyncAPI is an open-source project and, like many other open-source projects, built and maintained by passionate people who often don't have the staff or budgets to do much more than keep the project alive. Hacktoberfest is all about giving back to those projects, sharpening skills, and celebrating all things open source, especially those who make open source so special.Planting the seedFor us, contributions come in all shapes and sizes. From typo fixes and bug reporting to more significant improvements. But that's not all! AsyncAPI also creates time to help onboard contributors who find it difficult to start contributing to the project or provide help to contributors who get stuck while contributing.How we preparedNot gonna lie, this year's Hacktoberfest snuck up on us like Batman in Gotham City, and as soon as we realized this, we immediately started planning. We kicked off by defining our goals for Hacktoberfest as we've always done.PromoteAsyncAPI Initiativeas a place where we work not only on the AsyncAPI specification but also lots of toolsHelp members of the broader open-source community make their first contributions in a friendly environmentWe spent time writing a how-to-contribute guide for folks participating for the first time and also wrote a maintainers guide for potential maintainers.AsyncAPI is a great project to contribute to because you can learn about AsyncAPI while fixing an issue. That's why we carefully curated issues and prepared especially for Hacktoberfest. And because most of these issues are existing issues, we made sure we reached out to project maintainers to identify which of them is a good one for Hacktoberfest contributors to look intoWas it worth it?Absolutely! Even though we kicked off late, we still received an amazing contribution. AsyncAPI merged 23 PRs from 12 contributors as part of this year's Hacktoberfest! I know it's less than the previous years but let's look on the bright side because some of these contributions were fun to make.Meet the heroesThis is a huge amount of work, and we are really proud that so many wonderful people have come to help AsyncAPI to produce better software.We want to thank everyone personally who submitted improvements to our repositories. Here are the names of our heroes:Amishakumari544 -  1 PRtoukirkhan -  2 PRsaeworxet - 2 PRsmanavdesai27 - 1 PRAnkitchaudharyy -  3 PRsnawed2611 -  1 PRdhfherna - 1 PRamit-ksh - 1 PRmastdev -  2 PRscodingtenshi -  4 PRsakshatnema - 1 PRMayaleeeee - 4 PRsLate to the party?Not a problem. We've got tons of issues you can explore and start contributing to in no time. Because we are a community-first open-source project, we've made it our responsibility to make it easier for contributors to navigate through issues easily. That's why we've built the AsyncAPIcommunity dashboardto help you explore some exciting good first issues.Things to learn fromWe were overwhelmed and weren't fully prepared to handle the enthusiastic response from the community. Because we needed to curate more issues tagged Hacktoberfest, many of the issues were claimed before the mid of October, which left other contributors interested left out because of the lack of more issues.Once beaten twice shy. In order to avoid these potential pitfalls next year, we're gonna put some things in place, which include the following.Start planning earlierCreate more accessible Hacktoberfest issuesUsage of social media as an advantage to bring in more folksWrap upThank you so much to everyone who took part! We welcomed new contributors but were just as happy to see our existing contributors join in the fun, too. We hope you all enjoyed participating in Hacktoberfest as much as we did.Hacktoberfest is over, but Open Source is for lifeAre you interested in getting involved with AsyncAPI? You can always find us onAsyncAPI GitHubor ourAsyncAPI Slackworkspace. Can't wait to meet you and merge your PR!
"""
--------------------------------------------------------------------------------


Post 54
ID: https://www.asyncapi.com/blog/release-notes-2.5.0?utm_source=rss
Title: AsyncAPI Spec 2.5.0 Release Notes
Link: https://www.asyncapi.com/blog/release-notes-2.5.0?utm_source=rss
Summary: The release of AsyncAPI 2.5 brings helpful additions, such as extended Server Variables reusability and many clarifications.
Content:
"""
The new version of the AsyncAPI specification - 2.5.0 - is now available.This is a minor release, and it doesn't bring any breaking changes. You can switch to it by modifying the following value in your AsyncAPI fileasyncapi: '2.4.0'intoasyncapi: '2.5.0'Server Variables can be now referenced from inside the Server ObjectPrevious AsyncAPI 2.4.0 release came with the support ofdefining Server Variable Objects as reusable components.
Unfortunately, AsyncAPI 2.4.0 doesn't allow referencing reusableserver variable objectsfrom within theServer Object.
So we ended up in a situation where reusable server variable objects can be defined but cannot be reused.
AsyncAPI 2.5.0 remedies this deficiency by allowing the use ofReference Objects wheneverServer Variable Objects can be used inside theServer.variablesfield.The following example is now fully compliant with the updated specification:1asyncapi:2.5.02servers:3development:4$ref:'#/components/servers/myserver'5production:6$ref:'#/components/servers/myserver'7components:8servers:9myserver:10url:"{stage}.my-server.com:{port}"11protocol:ws12variables:13stage:14$ref:"#/components/serverVariables/stage"15port:16$ref:"#/components/serverVariables/port"17serverVariables:18stage:19default:dev20port:21enum:[5000,6000]22default:5000This new feature was contributed byVladimír Gorej. For more detail, seeVladimír's/spec #776pull requestand theGitHub issue where Vladimír's change toserverVariableswas discussed.Decorating Server Object with tagsTags categorize or group resources. 2.5.0 introduces support for defining tags at the Server level, which can be used for many use cases such as grouping servers by their features: environment name, cluster name, visibility, owner, etc.For example:1asyncapi:'2.5.0'2info:3title:StreetlightsKafkaAPI4version:'1.0.0'5servers:6scram-connections:7url:test.mykafkacluster.org:180928protocol:kafka-secure9description:TestbrokersecuredwithscramSha25610security:11-saslScram:[]12tags:13-name:"env:test-scram"14description:"This environment is for running internal tests through scramSha256"15-name:"kind:remote"16description:"This server is a remote server. Not exposed by the application"17-name:"visibility:private"18description:"This resource is private and only available to certain users"19mtls-connections:20url:test.mykafkacluster.org:2809221protocol:kafka-secure22description:TestbrokersecuredwithX50923security:24-certs:[]25tags:26-name:"env:test-mtls"27description:"This environment is for running internal tests through mTLS"28-name:"kind:remote"29description:"This server is a remote server. Not exposed by the application"30-name:"visibility:private"31description:"This resource is private and only available to certain users"32channels:{}This new feature was contributed bySergio Moya. For more detail, seeSergio's/spec #809pull requestand theGitHub issue where Sergio's change was discussed.Added missing IBM MQ Operation BindingWe noticed that we overlooked and did not define the Operation Bindings Object in the case of IBM MQ.
In AsyncAPI 2.5.0, the definition is empty, but its name is reserved for future use to be consistent with the rest of the bindings.This change was contributed byMaciej Urbańczyk. For more detail, seeMaciej's/spec #840pull request.Added new Google Cloud Pub/Sub BindingsThe specification is now extended to support another custom protocol through the bindings feature:Google Cloud Pub/Sub, thanks toJeremy Whitlock. For more details, check out thispull requestand thebinding definition.ClarificationsHere are notable clarifications that got into the AsyncAPI 2.5.0 release. Here is the list of notable clarifications that may have an impact on the tooling authors:ChannelItem.$ref resolution rulesAll references ofMUST be in the format of a URLsentence have been substituted withThis MUST be in the form of an absolute URL.
The meaning ofabsolute URLis now defined byRFC3986, section 4.3.Clarification around URL resolution rulesThe resolution rules aroundChannelItem.$reffield were not clearly defined. AsyncAPI 2.5.0 comes with explicit clarification that the resolution is done as defined by theJSON Reference.Tooling supportThe following official AsyncAPI tools are already updated to support the 2.5.0 specification version:JSON Schema that supports validation of AsyncAPI documents is updated in ourspecification JSON schema repository. We updated the@asyncapi/specspackage on NPM to version3.2, containing the JSON Schema document for AsyncAPI Spec 2.5.0.JavaScript Parsercan be used to parse and validate 2.5.0 documents. Upgraded tothe 1.17.0version.AsyncAPI React Componentallows you to render and validate the documentation of your asynchronous API provided in the AsyncAPI specification format. Upgraded to thev1.0.0-next.43version.HTML templateuses the latest@asyncapi/react-componentpackage. Upgraded to the0.26.0version.JavaScript Converterenables conversion from any AsyncAPI version into the 2.5.0 version of the spec. Upgraded to the1.1.0version.Generatoruses the latest @asyncapi/parser package, so while generating output, it can validate 2.5.0 documents. Upgraded to the1.9.12version.Modelinacan be used to generate typed models. Upgraded to the1.0.0-next.11version.Bundlercan be used to generate typed models. Upgraded to the0.2.3version.Cupidcan be used to generate typed models. Upgraded to the0.6.20version.Optimizercan be used to generate typed models. Upgraded to the0.1.11version.Gleecan be used to generate typed models. Upgraded to the0.10.23version.Spectral AsyncAPI Rulesetthat you can use for lining of AsyncAPI documents will be released soon.The pull requestis ready.Last but not least comes AsyncAPI Studio.Check out AsyncAPI Studio with this YAML example.Look aheadWe aim to have a quarterly cadence of releases of the AsyncAPI specification. For more information about when to expect future releases, you can see ourrelease process document.We're also working on the next major release of the AsyncAPI specification: 3.0.0. If you'd like to contribute, or just follow the discussions, you can seework on the 3.0 release issue.Photo byJeremy ThomasonUnsplash
"""
--------------------------------------------------------------------------------


Post 55
ID: https://www.asyncapi.com/blog/event-driven-api-documentation-made-simple-clientside-rendering?utm_source=rss
Title: Event driven API documentation made simple (Client-Side Rendering).
Link: https://www.asyncapi.com/blog/event-driven-api-documentation-made-simple-clientside-rendering?utm_source=rss
Summary: A simple guide for programmers looking for instructions on how to generate documentation using their AsyncAPI files.
Content:
"""
This post originally appeared onMichal's CornerThis guide is directed toward folks seeking instructions on generating documentation using their AsyncAPI files. Event-driven APIs are not the same as the synchronous APIs you usually document with OpenAPI or GraphQL. Many people use AsyncAPI now, and it is time to provide the community with a guide that shows what options the community has to render documentation on the client side.Oh, if you are still not sure about client or server side rendering, then you can read all about it hereWebsite rendering for beginners(shameless plug ).I will cover the usage for:ReactVueWeb ComponentsStandalone BundleThe AsyncAPI sample file👇is used as JSON to make it easier to use on the JS side.
All examples will use this same sample.1{2"asyncapi":"2.4.0",3"info": {4"title":"Account Service",5"version":"1.0.0",6"description":"This service is in charge of processing user signups"7},8"channels": {9"user/signedup": {10"subscribe": {11"message": {12"$ref":"#/components/messages/UserSignedUp"13}14}15}16},17"components": {18"messages": {19"UserSignedUp": {20"payload": {21"type":"object",22"properties": {23"displayName": {24"type":"string",25"description":"Name of the user"26},27"email": {28"type":"string",29"format":"email",30"description":"Email of the user"31}32}33}34}35}36}37}This is the expected look of the generated document👇All usage examples from this article are available to check on theasyncapi-docs-rendering-examplesrepository.ReactIf you wish to render documentation from your AsyncAPI file in React application, then you need to use theAsyncAPI React component.1️⃣To install theReact AsyncAPI componentrun the command:npm install --save @asyncapi/react-component@next2️⃣Now, create aindex.jsfile and type the following:1importReactfrom"react";2importReactDOMfrom"react-dom";34importAsyncApiComponentfrom"@asyncapi/react-component";5import"@asyncapi/react-component/styles/default.min.css";67import{ specMock }from"./testDoc";89constrootElement =document.getElementById("root");10ReactDOM.render(<AsyncApiComponentschema={specMock}/>, rootElement);Here we can see that theReact AsyncAPI componentis imported online 4.If you are happy with AsyncAPI styling then you need to import their CSS pattern with:import"@asyncapi/react-component/styles/default.min.css";Line 7is where the sample AsyncAPI file is imported.VueIf you wish to generate documentation from your AsyncAPI file in a Vue application, you need to use theAsyncApiStandalone bundle.The given instructions are for Vue 2.x.1️⃣The React AsyncAPI component is also required here, so you need to run the command:npm install --save @asyncapi/react-component@next2️⃣In yourApp.vuejust add this code:1<template>2<div ref="asyncapi"></div>3</template>45<script>6import AsyncApiStandalone from '@asyncapi/react-component/browser/standalone';78// AsyncAPI specification, fetched or pasted.9const schema =10'{"asyncapi":"2.4.0","info":{"title":"Account Service","version":"1.0.0","description":"This service is in charge of processing user signups"},"channels":{"user/signedup":{"subscribe":{"message":{"$ref":"#/components/messages/UserSignedUp"}}}},"components":{"messages":{"UserSignedUp":{"payload":{"type":"object","properties":{"displayName":{"type":"string","description":"Name of the user"},"email":{"type":"string","format":"email","description":"Email of the user"}}}}}}}';1112const config = {};// Configuration for component. This same as for normal React component.1314export default {15name: 'AsyncApiComponent',16props: {17msg: String18},19mounted() {20const container = this.$refs.asyncapi;21AsyncApiStandalone.render({ schema, config }, container);22}23}24</script>2526<style scope src="@/assets/asyncapi.min.css"></style>As you can see online 6, you need to import theAsyncApiStandalonebundle with commandimportAsyncApiStandalonefrom'@asyncapi/react-component/browser/standalone';3️⃣If you like AsyncAPI styling, then there is one more thing to do. You can do it in few ways:◾First way; you need to go to👉node_modules/@asyncapi/react-component/style/default.min.css.Copy that file and then paste it into yourassetsfolder.
I renamed mineasyncapi.min.css.Then, you can import this in yourmain.jsfile withimport'./assets/asyncapi.min.css'You can also import it at the end of theApp.vuefile with:<stylescopesrc='./assets/asyncapi.min.css'></style>Second way; import styles from@asyncapi/react-componentpackage:<stylescopesrc='@asyncapi/react-component/style/default.min.css'></style>Web ComponentsTo generate documentation from your AsyncAPI file, you can use it as an element of an HTML webpage or as a web component in any other web framework you choose. You can do this by usingweb-react-components.1️⃣Just create an.htmlfile, then copy and paste this code:1<script src="https://unpkg.com/@asyncapi/web-component@1.0.0-next.39/lib/asyncapi-web-component.js"defer></script>23<asyncapi-component4schema='{"asyncapi":"2.4.0","info":{"title":"Account Service","version":"1.0.0","description":"This service is in charge of processing user signups"},"channels":{"user/signedup":{"subscribe":{"message":{"$ref":"#/components/messages/UserSignedUp"}}}},"components":{"messages":{"UserSignedUp":{"payload":{"type":"object","properties":{"displayName":{"type":"string","description":"Name of the user"},"email":{"type":"string","format":"email","description":"Email of the user"}}}}}}}'56config='{"show": {"sidebar":true}}'78cssImportPath="https://unpkg.com/@asyncapi/react-component@1.0.0-next.39/styles/default.min.css">9</asyncapi-component>2️⃣If you need support for old browsers then you need to add this script as well:<scriptsrc="https://unpkg.com/@webcomponents/webcomponentsjs@2.5.0/webcomponents-bundle.js"></script>That is it!🤯Just awesome!Standalone BundleIf you want to render documentation from your AsyncAPI file without the use of any framework but with just an HTML webpage then you will need theStandalone bundle.1️⃣All you need is just a basic HTML template.2️⃣To get AsyncAPI document styling, in theheadelement enter:<linkrel="stylesheet"href="https://unpkg.com/@asyncapi/react-component@1.0.0-next.39/styles/default.min.css">3️⃣In thebodyelement type the following:1<div id="asyncapi"></div>23<script src="https://unpkg.com/@asyncapi/react-component@1.0.0-next.39/browser/standalone/index.js"></script>4<script>5AsyncApiStandalone.render({6schema: '{"asyncapi":"2.4.0","info":{"title":"Account Service","version":"1.0.0","description":"This service is in charge of processing user signups"},"channels":{"user/signedup":{"subscribe":{"message":{"$ref":"#/components/messages/UserSignedUp"}}}},"components":{"messages":{"UserSignedUp":{"payload":{"type":"object","properties":{"displayName":{"type":"string","description":"Name of the user"},"email":{"type":"string","format":"email","description":"Email of the user"}}}}}}}'7,8config: {9show: {10sidebar:true,11}12},13}, document.getElementById('asyncapi'));14</script>This fetches everything required from the bundle<scriptsrc="https://unpkg.com/@asyncapi/react-component@1.0.0-next.39/browser/standalone/index.js"></script>There is one more way to configure the AsyncAPI component.
You can do it throughconfigprops; the same as for the normal React component.MyWeb ComponentandStandalone Bundleusage examples haveconfig='{"show": {"sidebar":true}}'which turns on the sidebar, but if you change it tofalsethen your rendered document will not have that sidebar. Whatever works best for you.I almost forgot.AsyncAPI Standalone Bundle can be used in Angular 2+. Please check theofficial docsif that is something that you may need.This was only a sample of what could be done. AsyncAPI can do a lot more. Check out theAsyncAPI documentationfor more information on how to amend the sample so it will meet your expectations.I hope you liked this quick guide about the AsyncAPI client side document generation.Till next time👋.
"""
--------------------------------------------------------------------------------


Post 56
ID: https://www.asyncapi.com/blog/documenting-sqs-event-driven-apis-with-asyncapi?utm_source=rss
Title: Documenting SQS event-driven APIs with AsyncAPI
Link: https://www.asyncapi.com/blog/documenting-sqs-event-driven-apis-with-asyncapi?utm_source=rss
Summary: This post demonstrates how documenting event-driven architectures is possible, using SQS as a (real-world) example.
Content:
"""
Hey, do you remember what this field looks like in GET /operations?Ever since I started working in a team, the answer to that first question has been pretty straightforward:Sure, let’s check the OpenAPI documentation file.After two or three times, people who didn’t work with our codebase started remembering where the information was and stopped asking altogether. At least when it came to synchronous HTTP APIs. But as the previous question disappeared, another, slightly different one arose:Which are the fields we need to send in this asynchronous message?And the answer was not as easy. Finding it involved diving into the code, looking at DTO and data mapping objects, or even ancient Slack messages. While the HTTP API documentation was stored in a well-known file, everything event-driven API related was scrambled around. Wouldn’t it be nice if we could deal with both the synchronous and the asynchronous APIs in the same way? Turns out, we can!AsyncAPIAsking around, I stumbled upon AsyncAPI, a specification just like OpenAPI, but made for Event-Driven Architectures. Just like with OpenAPI, it describes how to communicate with an application, defining channels and message formats. Let’s see how to use it with an example.One of the requirements was a way to notify an event to our provider, only once. We decided to useSQS, an AWS message queueing service, into which our backend publishes messages with a specific format, and the provider listens to them.Simple diagram showing an application (our backend) which publishes messages in an SQS named OperationCreationQueue, and an external application which consumes those messages.To begin, we need to define the basics: the specification version, and our API name and version, in a new .yaml file.1asyncapi:'2.4.0'2info:3title:BestAPIintheworldOnce that’s out of the way, we’ll add a new channel, through which the messages are delivered. In our case, that channel is our SQS:1asyncapi:'2.4.0'2info:3title:BestAPIintheworld4version:0.1.05channels:6OperationCreationQueue:The next field we need is one I struggled a bit to wrap my head around. If this were an HTTP API, it would be obvious that the endpoints exposed are to be called by the client. But since our API works either by receiving or sending messages to clients, we need a way to express how the clients will interact with the application. Will the clientsreceivemessages through the SQS, or will theysendthem? Or, in other words, will the clients interact with the channel bypublishing messages, or bysubscribingto listen for new messages?In our example, operations are created in our backend and then forwarded to the provider, who will listen for new messages. Since we are documenting how others can interact with our API, the correct operation for this queue issubscribe1asyncapi:'2.4.0'2info:3title:BestAPIintheworld4version:0.1.05channels:6OperationCreationQueue:7subscribe:Once we have the basics, we can start documenting the operations as we see fit. For instance, we can add a description, expected message schema, and even protocol information if necessary. For instance, following our example:1asyncapi:'2.4.0'2info:3title:BestAPIintheworld4version:0.1.05channels:6OperationCreationQueue:7subscribe:8description:Theapplicationwillsendnewoperationnotificationmessagesthroughthischannel.9message:10payload:11type:object12properties:13operationId:14type:string15format:uuid16description:idoftheoperation17operationAmount:18type:number19description:OperationamountinArgentinianpesos.The message properties are defined usingJSON Schema.Visualization and other toolsJust like we have Swagger UI for RESTful API docs visualization, we can paste our AsyncAPI file into theAsyncAPI Studiofor pretty visualization, like this:Async API StudioThis tool will even generate basic examples for our messages, if we don’t provide our own.Additional tools, such as code generation tools, parsers, other UI components, and CI integrations, can be found on theAsyncAPI tools website page.There are many other features I have not explored in this article — I haven’t even tried most of them yet! — but this is enough to write a simple document. The question introduced in the beginning has, from now on, an answer which is easy to find!This post was originally posted in10Pines blogCover image bySafar SafarovfromUnsplash
"""
--------------------------------------------------------------------------------


Post 57
ID: https://www.asyncapi.com/blog/creating-consistency-announcing-asyncapi-spectral-together?utm_source=rss
Title: Governance for Asynchronous APIs: Announcing AsyncAPI & Spectral – Together!
Link: https://www.asyncapi.com/blog/creating-consistency-announcing-asyncapi-spectral-together?utm_source=rss
Summary: The collaboration between Stoplight’s open-source linting tool, Spectral, and AsyncAPI will be a game-changer for creating more consistency in your API program. Check out what comes with the release of the AsyncAPI ruleset!
Content:
"""
The collaboration between Stoplight’s open-source linting tool, Spectral, and AsyncAPI is going to be a game changer for creating more consistency in your API program. Check out what comes with the release of the AsyncAPI ruleset!Consistency is a top concern for companies across the globe.At Stoplight, we’re seeking to help your organization achieve consistency. We believe that API descriptions should be
treated the same way as code. APIs should have style guides with rules, and be reviewed to ensure they are descriptive,
readable, and concise for the developers who use them. Developer experience is, after all, another top concern for
companies.So, we created our open-source JSON linting tool Spectral. It promotes standards with the flexibility for custom rule
creation to validate and lint any JSON.For example, while an AsyncAPI or OpenAPI document might be entirely valid, it could be missing important fields like
descriptions for parameters or have other problematic design issues. Spectral can warn about possible improvements to
ensure API definitions can reach their full potential, without needing to have special code owners review every change
to the documents.Although Spectral is mostly referenced in the context of OpenAPI, AsyncAPI has been an integral
part of Spectral for quite some time now. In fact, last month our Spectral AsyncAPI ruleset celebrated its
second anniversary.Why AsyncAPI?While OpenAPI remains one of the top specifications, AsyncAPI is growing. And each has their ownunique benefits and
challenges. The ability to have options gives Spectral users more flexibility for their APIs.Spectral had primarily been an OpenAPI linter that was simply capable of working with other JSON documents. Now, by
enabling AsyncAPI rulesets, organizations can achieve the consistency they’re looking for with more flexibility.Introducing AsyncAPI & Spectral - Together!The release ofAsyncAPI rulesetwas more than just another feature added; it was considered a milestone. Previously,
Spectral lacked meaningful rulesets for other formats, and the number of learning resources was somewhat limited, making
the adaption of Spectral outside of OpenAPI rather minimal.Our collaboration with AsyncAPI means that we’ve given the respective AsyncAPI maintainers write access to the Spectral
repo AsyncAPI rulesets, though here at Stoplight we will still continue to operate with PRs, and ensure these get
priority.The Game ChangerThe introduction of support for another major API definition helped us further assess its level of importance as well as
initiated a notable shift in the way we perceived Spectral internally. Treating AsyncAPI ruleset as a first-class
citizen pushed us to entirely decouple our codebase from OpenAPI. The core purpose of Spectral (linting API definitions)
remained unchanged and still holds true, but from an engineering standpoint, it meant a shift in focus to the other
specs and a renewed attention on writing code that can be applicable everywhere.Back in 2018 or 2019, plenty of code was oriented around OpenAPI, tests, and naming. All were focused solely on OpenAPI,
meaning rulesets themselves couldn’t be applied easily to other formats (Spectral didn’t support them previously).With the release ofSpectral 6, that transition period wrapped up and Spectral is now more flexible than it’s ever been.Steps to Utilizing AsyncAPI & SpectralLinting AsyncAPI documents is quite similar to linting OpenAPI documents, meaning
most of the information about Spectral you’ll find on the internet will apply to AsyncAPI. Together with AsyncAPI
initiative, wemaintain a Spectral rulesetcontaining a number of useful rules you can leverage in your workflow to help
you get started.Step One:To get started, you need toinstall Spectral first. Note that you need to havenpmorYarninstalled, runningnpm install -g @stoplight/spectral-clioryarn global add @stoplight/spectral-cliis sufficient
to get Spectral.The CLI package bundles@stoplight/spectral-rulesetswhich
contains the actual ruleset we’ll use.
If you intend to use an older version of the AsyncAPI ruleset, you could additionally install a different version of @stoplight/spectral-rulesets.
However, it’s an optional step, and it's generally recommended to stick with the latest versions if possible.Step Two:Once you’ve got all the required dependencies installed, you can start by creating a simple ruleset. To do so,
create a file called.spectral.json. The following template can be used as a decent baseline:1{2// This makes sure our rules apply only to AsyncAPI documents.3// It might be handy in case you have other specs in the directory you intend to lint.4"formats": ["asyncapi2"],5// this includes the ruleset linked below6// https://meta.stoplight.io/docs/spectral/ZG9jOjUzNDg-async-api-rules7// Note that by default, only recommended rules are enabled.8// Some rules listed in the article above may not be a fit for you,9// therefore we don’t enable them by default.10"extends":"spectral:asyncapi",11"rules": {12// we can add our own rules here13}14}Step Three:To better facilitate the actual demands, Spectral allows you to create your own rules. These rules will fill the gaps
and cover use cases unique to your workflow, or style guide. While a more thoroughreference regarding custom rules is
available here, a basic rule could look as follows. The rule we’re about to implement will assert the presence and correctness of the version inside of theInfoobject.1{2"message":"Version must match 1.x.x",3// one can also define description property here,4// which is supposed to be a markdown string5// containing a more detailed explanation about the rule6"severity":"error",// or warn, or info, or hint7// any JSONPath-compliant expression8// https://goessner.net/articles/JsonPath/9"given":"$.info",10"then": [11{12"field":"version",13"function":"defined"14},15{16"field":"version",17"function":"pattern",18"functionOptions": {19"match":"^1(\\.[0-9]+){2}$"20}21}22]23}Step four:Now that we have a basic rule, we can insert it into the ruleset we previously created:1{2"formats": [3"asyncapi2"4],5"extends":"spectral:asyncapi",6"rules": {7"valid-document-version": {8"message":"Version must match 1.x.x",9"severity":"error",10"given":"$.info",11"then": [12{13"field":"version",14"function":"defined"15},16{17"field":"version",18"function":"pattern",19"functionOptions": {20"match":"^1(\\.[0-9]+){2}$"21}22}23]24}25}26}Step five:Now that we have all the pieces together, we can run Spectral. We’ll take theHello Worldexample from the AsyncAPI documentation.1# hello-world.yaml2asyncapi:2.2.03info:4title:Helloworldapplication5version:'0.1.0'6channels:7hello:8publish:9message:10payload:11type:string12pattern:'^hello .+$'To lint, execute the following command:spectral lint hello-world.yamlThanks to the built-in AsyncAPI ruleset, we receive more feedback than just the information about invalid document versions. The default configuration is usually reasonable for most, but should you want to tweak the version, please visit ourdocumentationthat explains everything in greater detail.Tada!🎉We are looking forward to the continued collaboration with AsyncAPI and the exciting things to come. Let us know your
thoughts about what you would like to see next or visit theAPI design blogfor more insights.
"""
--------------------------------------------------------------------------------


Post 58
ID: https://www.asyncapi.com/blog/2022Q1-summary?utm_source=rss
Title: Summary of things that happened at AsyncAPI Initiative from January to April, 2022
Link: https://www.asyncapi.com/blog/2022Q1-summary?utm_source=rss
Summary: New AsyncAPI brand. AsyncAPI 2.4 and work on the 3.0 spec release. Meetings organization change. 2022 conference organization. AND SO MUCH MORE!
Content:
"""
Welcome to another update from the AsyncAPI Initiative. In this article, I want to highlight the most important items contributed to AsyncAPI during the first few months of 2022.I usually ask the community if folks have anything important that I should put in my updates. Still, this is a pretty subjective article because it's based mainly on things I see in my personal bubble.😃Brand RefreshThis one is pretty easy to spot, especially if you have been with AsyncAPI Initiative for some time.😃On March 10, we announced a change to the AsyncAPI brand. Change that was needed. A refresh of this faded green that I personally never liked.😂It was a massive effort led byMissy Turco. Months of work, research, and discussions with the community.It is not all. More work in the area is needed:Design System💪- Get involved in therelated design system repositoryif you are interested in helping out.AsyncAPI Mascots refresh - We need to refresh our existing Eve and Chan mascots to match the new brand. Any help would be appreciated.For more regular news and updates on topics around brand and design in AsyncAPI Initiative, I definitely recommend you followMissy Turcoand read herregular design updates.AsyncAPI ConferenceWe want to organize our first hybrid conference, one you can watch online and participate in person. May is right behind the corner, so not much time is left. We need to start working actively on the event now.We discuss all aspects of our upcoming conference in ourCommunity Discussion for 2022 Conference Organizationopenly. Please join and actively support the effort. We need lots of volunteers to make this happen.We need to have a special task force that will focus on the subject. Please join thediscussion on hosting a conference-dedicated weekly meeting.Meetings scheduling automation and related changesBecause of the community's growth and the growing number of topic-specific meetings, we had to spend some time improving things and automating as much as possible. After some initial discussions, such asthis discussion about Google-services, some initial requirements were defined, calledMeeting as a Service.A week ago, we stopped using ourasyncapi-usersGoogle Group. We removed it, and all the members were migrated as subscribers to the AsyncAPI Newsletter. This newsletter is the new place where we'll send email notifications every Monday morning with a list of upcoming meetings.We switched to the new Google Calendar instance managed by the official AsyncAPI Google account. You should remove/unsubscribe from the old calendar andsubscribe to the new calendar,Our Technical Steering Committee (TSC)approved to sponsor 8 Zoom licenses to host official AsyncAPI meetings. So far, only 3 licenses have been assigned. We have lots of room for more meetings and hosts, if there is a need.Huge thanks toKrishna KumarandShreyansh Jain, who helped research the implementation.❤️If you want to learn more about becoming a meeting host, or something else related to meetings, get familiar with ourdedicated meetings FAQ.Oh, and I almost forgot, look at this.👇⭐️
Allinfo about AsyncAPI-related meetingsis in one beautiful place! ❤️View of dedicated community/meetings page on the AsyncAPI website.Upcoming 2.4 and 3.0 releases of the specWe released anew 2.4.0 version of AsyncAPI Specification. There are many good features, like the possibility to provide a unique Messageidfor the entire AsyncAPI file or the ability to specify that security is valid only for a given operation. You definitely need to read therelease notes.Huge shout out toSergio Moya, who was a release coordinator for the 2.4.0 release and pushed all the doors to make sure the release could go out.2.4.0 was released, but this doesn't block us from working on something much bigger, 3.0.0 version of the specification!🚀If you haven't heard about 3.0.0 yet, I highly recommend you have a look at the3.0.0 release articlewritten byHarsh Mishra.Please join these efforts, as there is much work ahead of us, but not many hands doing actual work. We meet every two weeks to sync the work efforts and discuss important topics. Feel free to join🙏I also recommend followingSergio Moyaand reaching for hisregular updates on specification-related effortsContributors onboarding initiativesOne of thegoals for our 2022 community-building effortswas to involve AsyncAPI Initiative as a mentoring organization in as many coding (but not only) events as possible. We have many maintainers here who like to help first-time contributors land their first pull requests in an open and relaxed environment.Google Summer of CodeWe did not start well. We were not accepted forGoogle Summer of Code. Don't ask me why. I really do not know. I wish I could have a clear answer from them about what failed on my end, where I made mistakes in our application.😢We never give up here at AsyncAPI, though.😃OpenForceMarch was a month where we joinedOpenForcethanks to amazing support fromHargun Kaur. As a result, we managed to onboard a few new folks and gained important contributions in exchange. There are  a few PRs still open, but here are some of the completed PRs:Namya LGintroduced a great improvement to our CI by creating dedicatedCI workflows that search for broken linksin our documentation across all repositories.Harsh Mishraintroduced aCI workflow that validates docker imagesin projects where we publish them.Abhijeet Jejurkarimproved the Kubernetes deployment for ourserver-apiservice.Samriddhicontributed anew/bundleendpoint to ourserver-apiservice.Ritik Rawalcontributed anew/diffendpoint to ourserver-apiservice.Everly Precia Sureshadded a possibility tohost API reference docs for ourserver-apiservicethrough a dedicated endpoint.It is also super important to mentionAbir Pal, who helped to coordinate efforts and was the first point of contact for the community coming from OpenForce channels.Google Season of DocsSuccess with OpenForce was followed by the unexpected announcement that AsyncAPI was accepted as an organization for Google Season of Docs (GSoD) 2022, with a $10k budget.💪An amazing success forQuetzalli Writesand an excellent opportunity for the AsyncAPI Initiative to improve its documentation big time!
On May 16, we will announce the names of six interns we want to hire to work on two different projects to have better docs. Quetzalli leads a super challenging task to interview as many candidates as possible (around 150!). Keep your fingers crossed.Quetzalli and I will be mentors for our GSoD interns in the following months. Stay tuned to watch the progress.AsyncAPI MentorshipWe did not want to give up even though the Google Summer of Code (GSoC) 2022 application was declined. We knew many community members joined and started contributing because they counted on AsyncAPI being part of GSoC.Well tl;dr, our TSC just accepted an idea to start our ownAsyncAPI Mentorshipprogram!🚀Now we have until May 15 to discuss with mentors yourmentorship ideas, understand the scope of each idea, and state clearly for which idea you are a candidate. Then we will ask TSC to vote and select 10 ideas that the AsyncAPI Initiative should sponsor this year.AsyncAPI TrainingICYMI, we run an effort to create official AsyncAPI training videos.Barbaño Gonzálezleads this topic and almost finishedtraining scripts and storyboardsfor the first set of videos.I do not think it is a secret to say that great content is created only with great input, feedback, and review from people waiting for it. Please join Barbaño's efforts with any help you can, as she is not doing it for herself but the community.I recommend youfollow Barbaño's monthly updates, especially if you want to participate.Docs Feedback FormOne of our missions is to have kick-ass documentation. Easy, right?Writing docs is easy, just like writing code (at least in my opinion😜). Well, we all know the devil is hidden in details. Details like gathering requirements, figuring out architecture, and making sure you have a well-motivated group of people working on it. And last but not least, make sure the community can easily share feedback on your work transparently.I wrote already aboutQuetzalli Writesand the efforts to get AsyncAPI into GSoD. Getting a well-motivated group of people to work on docs, checked.✅Ournew docs information architecture is almost here too. I think we can say "checked"✅to this one too.Since this week, we can also say "checked"✅to the idea ofgetting docs feedbackfrom the community.Each documentation page has a dedicated feedback form that one can fill in anonymously. The form injects the feedback into adocs-related GitHub Discussion like this example.Huge applause to:Quetzalli Writesfor leading the changeMissy Turcofor amazing support with designMaciej Urbanczykfor detailed reviewAkshat Nemafor implementation. Akshat demonstrated a lot of patience here. As an individual contributor, he waited for the merge for quite some time. There was a long discussion, many parties involved. Many contributors lost interest in such long-running PRs. Not Akshat!💪Anyway, I recommend you followQuetzalliand herregular docs-related updates.Photo byMitchell LuoonUnsplash
"""
--------------------------------------------------------------------------------


Post 59
ID: https://www.asyncapi.com/blog/release-notes-2.4.0?utm_source=rss
Title: AsyncAPI Spec 2.4.0 Release Notes
Link: https://www.asyncapi.com/blog/release-notes-2.4.0?utm_source=rss
Summary: AsyncAPI 2.4 is now released. This brings really helpful additions, such as the new `messageId` field, Server Variables reusability, and security at Operation level
Content:
"""
The new version of the AsyncAPI specification - 2.4.0 - is now available.This is a minor release, and it doesn't bring any breaking changes. You can switch to it by modifying the following value in your AsyncAPI fileasyncapi: '2.3.0'intoasyncapi: '2.4.0'Message uniqueness thanks to the new messageId fieldAs operations haveOperationId, AsyncAPI messages can now definemessageId. This new field is used to identify a message across a whole AsyncAPI document uniquely.
This new field will be helpful in tools that ask the user to select a message as input, such as validating their schema or filtering code to be generated.For example:1asyncapi:2.4.02components:3messages:4SomeMessage:5messageId:SomeMessage6payload:7type:object8properties:9name:10type:stringThis new feature was contributed byWaleed Ashraf.
For more detail, seeWaleed's/spec #751pull requestand theGitHub issue where Waleed'sMessageIdfeature addition was discussed.Server Variables can be now referenced from componentsTo allow for more flexibility in how AsyncAPI documents are structured and enable content to be reused,serverVariablescan now be defined as reusable components.For example:1asyncapi:2.4.02servers:3development:4$ref:'#/components/servers/myserver'5production:6$ref:'#/components/servers/myserver'7components:8servers:9myserver:10url:"{stage}.my-server.com:{port}"11protocol:ws12variables:13stage:14$ref:"#/components/serverVariables/stage"15port:16$ref:"#/components/serverVariables/port"17serverVariables:18stage:19default:dev20port:21enum:[5000,6000]22default:5000These are added to the many other aspects of the AsyncAPI specification which can be declared as reusable components. You can see the full list in theComponents Object section of the AsyncAPI specification.This new feature was contributed byDaniel Kocot. For more detail, seeDaniel's/spec #717pull requestand theGitHub issue where Daniel's change toserverVariableswas discussed.Security can now be defined at Operation levelUntil today, Security requirements were defined at Server level. That restricted the security requirements to be the same for all channels linked with a Server, and for all operations of those channels.
In fact, when setting Security in both the Server and the Operation, both should be satisfied.For example:1asyncapi:2.4.02servers:3production:4url:"mykafkacluster.org:8092"5protocol:kafka-secure6security:7-service_auth:8-auth:write9-auth:read10channels:11some/events:12servers:13-production14subscribe:15# This operation level security implies the ability to subscribe to messages from16# `some/events` channel with Authorization headers17# that have `auth:read` scope. Note that an operation level security must still satisfy18# security requirements specified at the server level.19security:20-service_auth:21-auth:readThanks toSekharbans, is now possible to increase security granularity by defining a set of security requirements at Operation level. For more detail, seeSekharban's/spec #584pull requestand theGitHub issue where Sekharban's suggested feature was discussed.Reusability of Servers defined in Components is clarified in the specificationReusability of Servers was introduced inAsyncAPI 2.3.0. However, the change was not fully clarified in the specification, leading to confusion.Thanks toVladimir Gorej, this is now clarified by mentioning that elements for the Servers Object can be either Server Object or a Reference Object.
For more detail, seeVladimir's/spec #706pull requestand theGitHub issue where Vladimir's Servers Object change was discussed.Tooling supportThe following official AsyncAPI tools are already updated to support 2.4.0 version of the specification:JSON Schema that supports validation of AsyncAPI documents is updated inthisrepository. Also@asyncapi/specspackage has been updated on NPM to version2.14.0, and it contains the 2.4.0 JSON Schema.JavaScript Parseruses latest@asyncapi/specspackage and can be used to parse and validate 2.4.0 documents. Upgrade to1.15.0version.HTML templateuses the latest@asyncapi/react-componentpackage. Upgrade to0.24.9version.JavaScript Converterenables conversion from any AsyncAPI version into the 2.4.0 version of the spec. Upgrade to0.11.0version.Generatoruses the latest @asyncapi/parser package, so while generating output, it can validate 2.4.0 documents. Upgrade to1.9.3version.Last but not least is the AsyncAPI Studio.Check out the Studio with this example.Look aheadWe aim to have a regular cadence of releases of the AsyncAPI specification, four times a year. For more information about when to expect future releases, you can see ourrelease process document.We're also working on the next major release of the AsyncAPI specification: 3.0.0. If you'd like to contribute, or just follow the discussions, you can seeWork on 3.0 release issue.Photo byAlexandru TudoracheonUnsplash
"""
--------------------------------------------------------------------------------


Post 60
ID: https://www.asyncapi.com/blog/google-season-of-docs-2022?utm_source=rss
Title: 📑 Google Season of Docs 2022 at AsyncAPI
Link: https://www.asyncapi.com/blog/google-season-of-docs-2022?utm_source=rss
Summary: Check out the Docs project proposal we're submitting to GSoD 2022! You won't want to miss out.
Content:
"""
¡Hola, AsyncAPI community!For today's blog post about AsyncAPI Docs📑, I wanted to share with all technical writers about our organization’s plan for participation inGoogle Season of Docs 2022 (GSoD). Any and all technical writers are welcome to come participate with us for GSoD 2022 season, regardless of tech background or years of experience! At AsyncAPI, we love mentoring folks who want to get involved in OSS, tech, and Docs. ❤️As some of you may remember from myGist Docs update for 31 Jan - 11 Feb 2022, I noted that GSoD 2022 was coming up and that AsyncAPI wanted to participate in the application process once it opened on February 23, 2022.In anticipation of this, I also created a new AsyncAPI Slack channel named#temp-gsod-2022that anyone can join! First,join our Slack workspace☎️and please respectour slack etiquette.🙂 Then join thetemp-gsod-2022channel, our temporary channel to coordinate GSoC 2022 setup. I'll publish regular updates on where we are in the application process, so stay tuned as the process continues.😄Join the#temp-gsod-2022slack channel for:mentees identificationmentors identificationideas identificationmentees and ideas and mentors matchingBelow is theproject proposalwe're submitting toGSoD 2022and then we close with a reminder of how to get started as an AsyncAPI Docs contributor:Update Docs Information Architecture - AsyncAPI InitiativeAbout AsyncAPIAsyncAPI (currently version 2.3.0, first released in 2016) is an Apache License 2.0 libraryunder the Linux Foundationthat seeks to improve the current state of Event-Driven Architectures (EDA). The AsyncAPI Initiative is a specification and growing set of open-source tools to help developers define asynchronous APIs, and build and maintain event-driven architectures. Developers familiar with OpenAPI (aka Swagger) for RESTful APIs will see strong similarities when using AsyncAPI. One common use case is generating documentation (HTML or Markdown) of an asynchronous API. The specification is both platform and language agnostic. Current tooling includes support for common message brokers such as Apache Kafka and RabbitMQ, and languages including Python, Java, and Nodejs. Our long-term goal is to make working with EDAs as easy as working with REST APIs. That goes from documentation to code generation, from discovery to event management, and beyond. Our 150+ Open-Source (OSS) contributors are EDA enthusiasts from all around the world.About our Docs projectOur current Docs problemOur current Docs and their Information Architecture (IA) needs a major makeover. The current content buckets are far from ideal and much basic content is missing to help onboard new contributors. Users new to our API spec need/Conceptualdocs that explain our spec terminology in more detail with engineering diagrams: people often learn visually! We also have to move our CLI docs under the Docs upcoming newReferencecontent bucket; currently, we have a README version of CLI docs only. Similarly, we're adding a new and broader/Toolssection of documentation for our tools in individual tools' GitHub repositories, under a/docsdirectory. Those should still remain there and continue to be maintained, but they also need to be documented in our Docs in a less informal way than what you see in a README. In time, we also need to add many more tutorials (i.e. Websocket, Kafka, etc) and Use Cases and Troubleshooting Guides, under a newHow-Tosection.We also need to re-structure theGenerator tooldocs. Because this is one of our main tools, it's big enough to be it's own independent project for 2022 GSoD. Currently, our Generator docs need a major update, to better explain every single functionality of the Generator.Our Docs project’s scopeWe're already invested in utilizing theDiátaxis methodologyfor determining ourcontent buckets(Concepts, Tutorials, Tools, How-To Guides, Reference). Along with this change, it makes sense to add new landing pages that introduce each content bucket. Each content bucket landing page could include cards featuring requested content from the community that still needs contributions. Then each card will read, "Contributors Needed."AsyncAPI has several CLI and Tools markdown README documentation in miscellaneous GitHub repositories that we plan to migrate over to the main Docs site. This task is part of our goal for finalizing our 2022 AsyncAPI Docs Information Architecture makeover. We explain this in more detail in our previous OSS blog post titled"Change is coming to our AsyncAPI Developer Documentation". It's also extensively documented in ourAsyncAPI Docs GitHub Project Board.In addition, we want to also target improving theGenerator tooldocs that are only READMEs in a repo right now. The Docs for this one tool are a big enough job to merit being our 2nd proposed project for 2022 GSoD.We're also writing voluntary OSS bi-weekly updates via GitHub Gists to speak about the latest updates made in the AsyncAPI Docs Ecosystem. Due to our commitment to investing time in gaining interest in our community and getting Google excited about us, we've made sure to maintain updates about ourGoogle Season of Docs 2022application too! In fact, you can take a look at the latest three where we made said mentions here inAsyncAPI Docs update (31 Jan - 11 Feb 2022),AsyncAPI Docs update (14 Feb - 25 Feb 2022), andAsyncAPI Docs update (28 Feb - 11 March 2022).Measuring our Docs project’s successWe will partially measure success in the Docs project by capturing specific feedback about the IA changes via our soon-to-come newDocs Feedback card. We need this specific and granular feedback to make sure we listen and make changes according to what the community requests from Docs. In previous AsyncAPI Docs Gist updates, we've mentioned that Design contributors were teaming with Docs on/websiteissue#453for the ideation and development of our newfeedback cardthat will be added at the bottom of each Docs page. What the community decided over the last 2 weeks was that theSubmit feedbackbutton in the card will publish the feedback anonymously via the AsyncAPI bot and create a newGitHub Discussionwith said feedback:The other way we would consider the project successful is the number of our contributors and Docs PRs increased from 3 to 6 community members. Currently, a majority of our OSS contributor community focuses only on contributing code, but we would like to instill a greater interest in contributing to documentation that provides value for everyone.TimelineThe project itself will take approximately 4-6 months to complete, depending on the different levels of knowledge from diverse technical writers (TW) that might get involved. (At AsyncAPI, we want to work with any TW, regardless of their years of experience. We have a passion for mentorship, and we do not wish to have a bar that would prevent any TW from contributing to our OSS Initiative. In fact, we look forward to potentially mentoring TW(s) who are completely new to tech and making them feel welcome!)For our 2 projects, we would like to request a minimum of 2 TWs, so that we can work on both the CLI/Tools and Generator Docs.The timeline would look as follows:May:Orientation on how to contribute to AsyncAPI Inititiave, how Docs issues are organized, detail how we're migrating our CLI and Tools Docs, and assign goodfirst-time-ticketsto get each new TW contributor started.June - August:Each TW goes through designated issues marked for both first time contributors and work set aside forGSoD 2022. Each TW starts creating documentation for their individual issues assigned/selected.September - October:We determine if we're going to be able to complete both CLI and Tools Docs plus the Generator Docs, depending on how many TWs are in our group and how much they've been able to complete so far. We re-align priorities as needed and asses what is missing to reach our 2022 IA change goals for AsyncAPI Docs.November:Project completion and all contributors receive some swag!Project budgetWe have set aside 2 mentors for now, for our 2 projects: improving our IA and re-structuring our Generator Docs. Should we be selected, AsyncAPI would like to request from Google a US $5000 budget for each project. For both projects, the request then totals for a $10,000 budget.Budget itemTotal AmountTechnical writer updates, reviews, edits, and publishing new documentation for the IA improvements.$5000Technical writer updates, reviews, migration, and publishing improved Generator tool documentation.$5000Get started contributing to AsyncAPI Docs TodayLast but not least, don't forget thatCode isn't the only way to contribute to OSS; Dev Docs are ahugehelp that benefit the entire OSS ecosystem. At AsyncAPI, we value Doc contributions as much as every other type of contribution.❤️To get started as a Docs contributor:Familiarize yourself with ourproject's Contribution Guideand ourCode of Conduct.Head over to ourAsyncAPI Docs Board.Pick an issue you would like to contribute to and leave a comment introducing yourself. This is also the perfect place to leave any questions you may have on how to get started.If there is no work done in that Docs issue yet, feel free to open a PR and get started!Docs contributor questionsDo you have a documentation contributor question and you're wondering how to tag me into a GitHub discussion or PR? Never fear!Tag me in your AsyncAPI Doc PRs orGitHub Discussionsvia my GitHub handle,quetzalliwrites🐙.-Q.W.👩🏻‍💻and Canela🐕‍🦺
"""
--------------------------------------------------------------------------------


Post 61
ID: https://www.asyncapi.com/blog/async-api-spec-3.0-release?utm_source=rss
Title: AsyncAPI Spec 3.0 is coming!
Link: https://www.asyncapi.com/blog/async-api-spec-3.0-release?utm_source=rss
Summary: Announcing the start of work on AsyncAPI Spec 3.0. Check out all the potential new features coming to AsyncAPI 3.0 and how you can get involved!
Content:
"""
AsyncAPI is a specification for describing your event-driven architecture. Our specification allows you to describe and document your message-driven APIs into a human-readable format. The AsyncAPI community is currently inching towards a 3.0 release that will bring together multiple features, enhancements, and breaking changes. We followrelease cadenceand we will continue to release the Spec to the community as we continue to build on it.Potential ChangesMany new features for AsyncAPI Spec 3.0 are being planned, written, and discussed. Among them are:Introduce Schema VersioningIntroducing Data Format bindingsMaking servers aware of their service nameSolving publish/subscribe confusionWhat does an AsyncAPI file meanFixing schema inconsistenciesDefining a schema format other than the default oneRemove$reffield fromChannel Item ObjectApplication of message traits (intentionally) replacing existing attributesAddress perspective and channel reuse issues through introducing 'endpoint' conceptThe tooling issues and pull requests which are tied up with the Spec 3.0 release are:Implement intent-driven Parser APISplitting out definitions into separate filesMove binding JSON schema files to main JSON schema repositoryWe are usingthis GitHub milestoneto track down all the issues related to Spec 3.0 release. If you are willing to take up an issue, filter the issues withneeds championlabel and drive the initiative forward. We also have arelease journalfor the upcoming Spec 3.0 release to keep note of all the references, build the right documentation, and track the progress for the upcoming release.Contributing to the releaseAsyncAPI is a community-driven project and we welcome all kinds of contributions! To get started, join ourSlack workspace. After joining, reach out to us on the#03_specificationchannel and participate in the conversations.To better understand AsyncAPI and how the Spec 3.0 release will play out, we recommend watching ourpast meeting recordings. To know how you can contribute, we recommend checking out ourcontributing guidelines. If you wish to keep track of all the work that is happening on the Spec 3.0 release, we recommend checking out ourGitHub issue.Before landing in your contributions, make sure you follow ourCode of Conductand the pull request you raised isdescribed properly. To know how we collaborate using Git & GitHub, follow theGit workflowthat we have developed for contributors.When will the release happen?We are yet to arrive at a date but the community is working towards releasing this by the end of 2022. Currently, we meet every two weeks to discuss the upcoming Spec 3.0 release and share updates and you are welcome to join it! We are going to have our next meeting onUTC 16:00 on March 16, 2022. You can access theAsyncAPI Calendarand explore our upcoming meetings.The release will happen gradually, where the new specification and tooling will live in coexistence until there is a collective consensus that everything is ready. This gives everyone an easy way to test out the new changes and provide feedback before the release. Finally, after rigorous testing, we will make an official announcement about our release!Join us and help make the upcoming release a successful one!(Cover picture byAndrew CoelhoonUnsplash)
"""
--------------------------------------------------------------------------------


Post 62
ID: https://www.asyncapi.com/blog/openforce-2022?utm_source=rss
Title: AsyncAPI at OpenForce
Link: https://www.asyncapi.com/blog/openforce-2022?utm_source=rss
Summary: Two years ago, the AsyncAPI Initiative participated in Hacktoberfest to help folks start their journey in open source. Hacktoberfest was a very successful event. We got feedback that the level of comm
Content:
"""
Two years ago, the AsyncAPI Initiative participated in Hacktoberfest to help folks start their journey in open source. Hacktoberfest was a very successful event. We got feedback that the level of commitment that we presented makes us perfect candidates for Google Summer of Code.Last year, we participated in Google Summer of Code and again in Hacktoberfest. It went great! We onboarded many new, super enthusiastic contributors that stayed with us longer.This year won't be different. We want to do it again and yet again, on a larger scale. Thus, active participation in initiatives focused on introducing new folks into open source becameone of our main goals for 2022.Thanks to one of our contributors,Hargun Kaur, we learned aboutOpenForceand decided to join it in March 2022.What we offerAsyncAPI maintainers prepared some GitHub issues that are easy enough to be completed in one month. We offer full support in discussing possible solutions and on-time review in pull requests.The AsyncAPI community is a safe place for your first open source contribution. Many folks are open to supporting your first steps in this great world.In exchange, every person that completes these tasks will get an AsyncAPI t-shirt!How to connectJoinour Slack workspace. Just make sure to follow ourSlack etiquetteandthe code of conduct.We will also haveAbir Palpresent in the OpenForce Discord channel, in case you need help on your way to AsyncAPI.List of issues you can work on [TODO]CI/CDWorkflow that updates every PR with clear info about conventional commitsReadme links checkCI on PR's should build the Docker imageK8S/HelmAutomate Helm chart release version bumpCreate better Kubernetes liveness, readiness and startup ProbesAdd livenessProbe and readinessProbe to K8s DeploymentTypeScriptAdd asyncapi bundle command in AsyncAPI CLIAdd asyncapi optimize command in AsyncAPI CLIRemove usage of Parser, validation and update docs from AsyncAPI bundlerAdd support for Markdown output in AsyncAPI DiffAdd support for HTML output in AsyncAPI DiffAdd implementation for /bundle pathAdd implementation for /diff pathServe openapi.yaml file as documentation pageEnable validation of an example payloadShow how to integrate Modelina in an AsyncAPI generator templateShow how to integrate Modelina in a websiteAdd support for WebSocket clientsJavaScriptSwitch for rendering whole channels by template parameterCreate eslint plugin for organization repositoriesGoSupport Kafka- Also includes JavaScript work.Create Avro schema parserOthersDefine a better API that can be used by other applicationsIdea: Using EventGateway Websocket with GrafanaPhoto byOpenForce
"""
--------------------------------------------------------------------------------


Post 63
ID: https://www.asyncapi.com/blog/2021-summary?utm_source=rss
Title: AsyncAPI Initiative 2021 in Numbers
Link: https://www.asyncapi.com/blog/2021-summary?utm_source=rss
Summary: AsyncAPI Initiative growth presented in different metrics from different channels in 2021.
Content:
"""
This article is a continuation of a tradition where once a year, we summarize all the metrics that we can collect from our different tools to see how we are growing as a community.It is good to see how we are doing, how are we growing🚀If you are interested in previous years, look atthis 2020 summary article.SlackWe noted 1846 members at the end of 2021:20202021New members490877(79% increase)In 2021 we also went through reorganization of the channels setup, created etiquette, and most importantly, got a standard subscription from Slack. We definitely are not going away from Slack.Weekly active membersSlack is our primary community channel, a kind of direct connection between community members. In my opinion, it indicates the community's growth that is more active in the initiative.For this year, I removed the stats about the number of posted messages. We have many messages posted by bots (about GitHub activity, for example) affecting the numbers. They are big but do not indicate only Slack activity.Data is shown weekly and not daily, so the numbers are not affected by usually silent weekends.20202021Active members weekly81 average77 median174 average(114% increase)173 median(125% increase)Active members posting messages weekly20 average19 median40 average(100% increase)41 median(116% increase)I think the median is accurate not only because it shows higher numbers. It basically eliminates super high weeks (like when we organized conferences) and weeks when we have lots of holidays simultaneously, like Christmas break.LinkedInLinkedIngrows like other channels. We mostly attract folks with job functions related to engineering (51%). Other are also tech but related to business development or product management.I personally wish we actually reach more product managers (PM) than 2%. As a person that was a PM in the past, I remember how much specs and APIs were important for products and hope other PMs go that path too.Followers and impressionsAt the moment, we have 1534 followers. Unfortunately, LinkedIn memory is short and remembers only numbers one year back. I do not have access to January 2021 data.In the case of a percentage increase, I take only numbers related to organic growth.20202021Followers61157 from payed marketing745(34% increase)Impressions80 095248 571146 252 from payed marketing(28% increase)We published 265 posts on LinkedIn, and with a growing number of followers, it converted into many users visiting ourwebsite.20202021Users7151 857(160% increase)New Users6561 699(159% increase)Sessions1 0422 511(141% increase)Sponsored marketingWe spent $1200 on paid marketing on LinkedIn to increase awareness about AsyncAPI Hackathon and Conference. We noticed a large increase in impressions on our sponsored posts. These sponsored posts did not link to our AsyncAPI website but to the conference registration site. To summarize, $1200 converted into 763 visits to the registration website and ... wait for it ... wait for it ... 15 registrations. I have to tell you that 2021 taught me that there is nothing better than organic marketing. Better pay $1200 to contributors for their work rather than give it out to LinkedIn.I recommend everyone to maintain a relationship with the community also on LinkedIn. This social media is changing. Many folks that are not active on Twitter are active on LinkedIn, and you should target them. In the end, reposting stuff you have for Twitter to LinkedIn is not very time-consuming.In Q4 of 2021, we also started streaming different meetings to LinkedIn. In three months, we noted 1180 views of our streaming content. So we basically enabled over 1k users to watch the content they would probably not watch if LinkedIn was their only social media channel. Think about it, omnichannel is the only way to build the community,Google AnalyticsWe use Google Analytics onAsyncAPI websitebecause we want to understand what content is most valuable for you, and we want to learn how the interest is growing.Traffic got much higherThe interest is growing by a lot! Our website handles it well with the support ofNetlify, which is free for open-source projects.201920202021Users visits27 09083 655(208% increase)131 802(57% increase)Sessions50 405147 409(192% increase)235 321(60% increase)Pageviews143 059362 686(153% increase)590 501(63% increase)Top blog postsAsyncAPI blogis a place where the AsyncAPI Community can publish articles. Anyone can share knowledge, experience, and showcase their work there. Justlet us know what you want to write about.What is the benefit of writing/republishing on the AsyncAPI blog? Visibility among the AsyncAPI community plus our activities to make your work go viral. Just look at the below table to see our top 3 viral posts.PostUnique pageviewsAuthorAsyncAPI vs OpenAPI: Answers to Your Burning Questions About Two Leading API Specs(September 2021)8 107Jesse MenningUnderstanding AsyncAPIs with a Practical Example(March 2021)6 161Dunith DhanushkaCreating AsyncAPI for WebSocket API - Step by Step(April 2021)5 049Lukasz GornickiGoogle Search ConsoleIn 2021 we integrated our Google Analytics with Google Search Console (GSC). I believe that numbers from GSC can show how many more people hear about AsyncAPI and gain interest in the topic. In other words, the assumption is that the more people google, the more people are aware of AsyncAPI.The last data we have access to is from the 20th of September 2020. So we cannot fully compare 2020 and 2021. We know we had 1 230 000 (OVER ONE MILLION) impressions and 104 000 clicks in 2021 in total, but in the table below we only compare data between the 20th of September and the 31st of December.20202021Total clicks19 20034 400(79% increase)Total impressions300 000350 000(17% increase)Impressions conversion into clicks6.4% average9.8% averagePosition in search results31.3 average29.7 averageWe can compare only three months, so numbers for 2022 will definitely be better than 2021.We did somesuper basic SEO improvementsin mid 2021, which sure took effect on increased click rate. We also published a few articles with topics that people google for together withasyncapi, WebSocket, and OpenAPI.I think we have proof that all additional activities planned for 2022, such as rework of existing documentation, should improve numbers even more.If you have more ideas on improving, just open up an issue inthe website repository, and let's discuss how we can get better.TwitterBy the time I gathered data for this blog post, we had 2997 followers on Twitter. 1 564 increase since the last time we had published such metrics in mid-December 2020. It is78% more followers in a year compared to 2020.I'm not gonna hide, I'm not a Twitter fan, really.😃Who cares about my preferences, though, our community is present there, and we must too. In the end, Twitter led 2 478 new users to AsyncAPI website.What I can tell you for sure. Do not spend your money on Twitter marketing. We tried it for AsyncAPI Conference. Of course, I might configure something in a bad way, but does it change anything? We spent $560.21 on sponsored tweets that converted into 16 471 visits to the conference registration page. Guess what,0 folks registered.Now yes, of course, might be that tweets were not targetted properly, might be that registration page was not attractive. But I challenge you with a question: is it worth spending many extra hours and money on this classical marketing instead of the community?GitHubWe notice growing traffic inour GitHub organizationlike on other channels.Most popular repositoriesOur most popular repositories contain the AsyncAPI specification and the AsyncAPI Generator that the community can use to generate documentation and code.The AsyncAPI Specification repositorythat had 1 357 stars in 2020 jumped to 1 870.The AsyncAPI Generator repositorygrew from 198 to 417. So the number of fans doubled.The number of contributors also increased, but the problem is I no longer have access to tools that can help me get exact numbers, like the ones I got last year.The good news is that we should get access to Linux Foundation Insights tool around April. It will enable us to look deep into not only GitHub stats in one place. We will definitely get more accurate numbers for 2022.npmThe majority of our tools are written in JavaScript/TypeScript, and we host them on Node Package Manager (npm).Top packagesOur most important packages arethe project that provides AsyncAPI JSON Schema files,the Generatorandthe Parser. Below you can see how downloads of these packages increased.201920202021Generator21 536136 994396 766Parser18 591187 4751 460 275Module with JSON Schema files for specification(new@asyncapi/specs& oldasyncapi)79 527215 0161 483 839!The increase in numbers is insanely huge. People automatically say that it is because of build systems, local development, or some single corporation started using it at scale. In other words, the increase could result from just one project that uses these tools as a dependency.Let me challenge you:Corporations always use mirrored versions in npm. When you work on a project in a corporate network, you will always hit internal proxy. Not included in downloads.Most build systems cache packages that are downloaded already to improve performance. Not included in downloads.
When you work with npm locally, you also have a local cache that is used if you want to install something that you already installed. Not included in downloads.An interesting observation is that Generator uses Parser and Parser uses the package with AsyncAPI specs. So you can read from this data that packages with specs are primarily used in the AsyncAPI Parser. You can also see that Parser is a backbone for many more projects than just the AsyncAPI Generator.Do you see it? Last year Generator and Parser download numbers were super close to each other, now the difference is much higher, 1 MILLION!YouTubeTheAsyncAPI YouTube channelhad a massive increase in traffic.Watch timeYouTube is the only channel where numbers were not higher than in previous years. The main reason is that in 2020, our conference took place in March, while in 2021, it was November. We only released like 1/5 of all presentations. Let's see if I'm right. Numbers in 2022 should get up.201920202021Views5278 83010 444Watch time29.9h1 900h1 672.9hSubscribers35396292Open CollectiveWe earned and spent lots of money this year.🤑Huge applause👏to allour sponsors!SourceExpensesBalanceAsyncAPI Hackathon & Conference$1,200.51 LinkedIn marketing$563.00 Twitter marketing$2,200.53 Daily.dev marketing (converted into 22 registrations out of 369 visits)$11,023.92 Hackathon prizes$1,972.31 Swags for Hackathon participants and Conference presenters$8,146.63AsyncAPI Initiative$15,093.31 Marketing and Maintainance$3,000.00 Donation toJSON Schema$56 252.68We also have a good amount of money thanks to the new Platinum sponsor that joined last year, IBM. Also, RedHat joined as a Gold sponsor. We also had other donations.Final wordsWe grow. Numbers just confirm our observation. We grow not only because people love to build a community around the specification. We grow because AsyncAPI Initiative is attractive for contributors because we also host tools related to AsyncAPI.If you want to look at more data, some of it is availablein this spreadsheetand for others you just need to contact me directly.In 2022, we need to establish a stronger bond with the community. We have many folks that give back a lot of time into the project, and it is time to give back. The main goals we have:Meet in person for AsyncAPI ConferenceSetup Ambassador program to give back to most active community membersGet involved in more events like Google Summer of CodeJoin us so we can work on these together!Photo byAlternate SkateonUnsplash
"""
--------------------------------------------------------------------------------


Post 64
ID: https://www.asyncapi.com/blog/radical-transparency?utm_source=rss
Title: Radical Transparency
Link: https://www.asyncapi.com/blog/radical-transparency?utm_source=rss
Summary: There are multiple ways to manage an open-source project. At AsyncAPI, we chose the Open Governance model for many good reasons that Lukasz explained in his article Finding a Good Open Governance Mode
Content:
"""
There are multiple ways to manage an open-source project. At AsyncAPI, we chose the Open Governance model for many good reasons that Lukasz explained in his articleFinding a Good Open Governance Model for AsyncAPI.However, there's more than"just"doing Open Governance.If something can't easily be found, then it's not really transparent and, therefore, not truly open.We not only chose Open Governance butRadical Transparency.What is Radical Transparency?radical/ˈradɪk(ə)l/(especially of change or action) relating to or affecting the fundamental nature of something; far-reaching or thorough.Forming an inherent or fundamental part of the nature of someone or something.transparency/tranˈsparənsi,trɑːnˈsparənsi/(of an organization or its activities) the condition of beingopen to public scrutiny.Radical transparency is about doing every single thing in public. It's about empowering the community with the necessary tools and information to scrutinize everything we do.What does it mean for me as the Executive Director?Believe it or not, it's relieving. Most people —including myself in the past— would have been scared of letting so much power go and opt for radical transparency.I often get a lot of pressure from different companies to do something for them. Here are some examples:Invite someone to the TSC in exchange for aPlatinum Sponsorship.Exchange logos on our websites. Oh my! It just happened as I'm writing these lines😂Donate some money only if they get "something" in return. These people don't get open-source, do they?😄So Radical Transparency is actually making things easier for me. I just have to say something like this:I'm sorry, but I can't do what you're suggesting. If you're still interested in a similar deal, please head over tohttps://www.github.com/asyncapi/communityand open an issue with your proposal. We can happily discuss it there.All of a sudden, it's not just my responsibility. It'sthe TSCwho gets to decide if their proposal moves forward or doesn't. This makes the TSC (including myself) accountable for the decision. And most important, it's all registered and accessible to anyone in the community to scrutinize.Radical Transparency is removing all these trouble-makers for me. Whoever is truly interested in making an honest proposal, will also suggest it publicly. This system allows me to get rid of those whose interest is not making the project better and are only seeking profit. And, so far, these people stand for 100% of the cases.Of course, I'm still happy to take private calls and emails when they make sense. E.g. they contain sensitive information, you don't speak English, you're shy to propose things in public, they're not related to AsyncAPI, etc.What does it mean for the community?Whether you are a user, a contributor, or a code owner, everyone must make decisions in public. For code, we use pull requests. Use issues or discussions on the related repo when it's something else. And, if there's no related repo, usethe community one.Whatever we do, needs to have its associated public record. That doesn't mean we don't do video calls to discuss complex topics. We actually encourage them when the writing form is not enough or too difficult. We never take decisions on meetings because that would be leaving many people out. E.g., those in other time zones, having other meetings at the same time, those on holidays or sick, etc. In any case, whatever is discussed in the meetings should be reflected in its correspondent issue or discussion on GitHub.Of course, the "downside" of this is that the whole process becomes slower and more bureaucratic, but I don't think it's really a downside but a feature. By doing this, we make sure to behave as a community, as a group, as a huge team. And you don't want to leave any teammate out, right? It's a matter of respect, after all.Challenge us!That said, we're always looking for ways to improve. We're already radically transparent, but I'm sure we can improve some things. So here's a challenge for you, find something we're not doing transparently enough and let us know. Or, even better, join us to improve it!Thanks for reading!(Cover picture byAnh Tuan ToonUnsplash)
"""
--------------------------------------------------------------------------------


Post 65
ID: https://www.asyncapi.com/blog/release-notes-2.3.0?utm_source=rss
Title: AsyncAPI Spec 2.3.0 Release Notes
Link: https://www.asyncapi.com/blog/release-notes-2.3.0?utm_source=rss
Summary: AsyncAPI 2.3 is now released. This brings enhancements allowing new ways of structuring AsyncAPI documents and support for describing Solace APIs.
Content:
"""
The new version of the AsyncAPI specification - 2.3.0 - is now available.This is a minor release, and it doesn't bring any breaking changes. You can switch to it by modifying the following value in your AsyncAPI fileasyncapi: '2.2.0'intoasyncapi: '2.3.0'Servers and channels can now be defined as reusable componentsTo allow for more flexibility in how AsyncAPI documents are structured and enable content to be reused,serversandchannelscan now be defined as reusable components.For example:1asyncapi:2.3.02servers:3production:4$ref:'#/components/servers/myserver'5channels:6some/events:7$ref:'#/components/channels/myChannel'8components:9servers:10myserver:11url:"http://localhost:5000/ws"12protocol:ws13channels:14myChannel:15description:"mychannel"These are added to the many other aspects of the AsyncAPI specification which can be declared as reusable components. You can see the full list in theComponents Object section of the AsyncAPI specification.This new feature was contributed bySergio Moya. For more detail, see thispull requestand theGitHub issue where this change was discussed.New protocol bindingsThe specification is now extended to support another custom protocol through the bindings feature:Solace, thanks toMichael Davis.
For more details, check out thispull requestandbinding definition.Other enhancementsRegular expressions are now Unicode-compliant. This enhancement to the specification fromSergio Moyameans that regular expressions (found inpatternandpatternPropertiesfields) are now Unicode-compliant (according to ECMA-262).This improves compatibility with some JSON Schema parsers. For more details, check out thepull request.DeprecationsThe$reffield inChannel Item Objectis now deprecated from AsyncAPI 2.3.0.The current plan is that the$reffield will be removed fromChannel Item Objectin AsyncAPI 3.0, and replaced withReference Object.For more detail, you can see thediscussion about this issue in GitHub.Tooling supportThe following official AsyncAPI tools are already updated to support 2.3.0 version of the specification:JSON Schema that supports validation of AsyncAPI documents is updated inthisrepository. Also@asyncapi/specspackage has been updated on NPM to version 2.13.0, and it contains the 2.3.0 JSON Schema.JavaScript Parseruses latest@asyncapi/specspackage and can be used to parse and validate 2.3.0 documents. Upgrade to 1.14.0 version.HTML templateuses the latest@asyncapi/react-componentpackage. Upgrade to 0.24.7 version.JavaScript Converterenables conversion from any AsyncAPI version into the 2.3.0 version of the spec. Upgrade to 0.7.0 version.Modelinanow also accepts AsyncAPI documents valid against the 2.3.0 version of the spec. Upgrade to 1.46.0 version.Generatoruses the latest @asyncapi/parser package, so while generating output, it can validate 2.1.0 documents. Upgrade to 1.9.0 version.
Last but not least is the AsyncAPI Studio. Check new studio withthis example.Big thanks toMaciej UrbanczykandJonas Lagonifor updating most relevant tooling.Look aheadWe aim to have a regular cadence of releases of the AsyncAPI specification, four times a year. For more information about when to expect future releases, you can see ourrelease process document.We're also working on the next major release of the AsyncAPI specification: 3.0.0. If you'd like to contribute, or just follow the discussions, you can see themilestone on GitHub.Photo byAndrew RidleyonUnsplash
"""
--------------------------------------------------------------------------------


Post 66
ID: https://www.asyncapi.com/blog/asyncapi-and-apicurio-for-asynchronous-apis?utm_source=rss
Title: AsyncAPI and Apicurio for Asynchronous APIs
Link: https://www.asyncapi.com/blog/asyncapi-and-apicurio-for-asynchronous-apis?utm_source=rss
Summary: This post originally appeared on https://novatec-gmbh.de



The OpenAPI specification has already established itself in many project and application areas. It can be applied to describe HTTP APIs in a
Content:
"""
This post originally appeared onhttps://novatec-gmbh.deTheOpenAPIspecification has already established itself in many project and application areas. It can be applied to describe HTTP APIs in a standardized way, understandable for humans and computers. While OpenAPI is mainly intended for synchronous interfaces, asynchronous communication places new demands on the interface definition.Asynchronous architectures can build on different types of protocols, e.g., Kafka, AMQP, or MQTT. Additionally, communication often includes a messaging broker, which maintains several topics or channels. Another difference is the communication style: OpenAPI only allows specifying one-to-one connection links. In contrast to that, asynchronous communication often involves multiple communication partners. Therefore, common patterns like publish/subscribe require a new approach to defining APIs.AsyncAPIwas developed as an extension of OpenAPI to meet these new requirements of asynchronous communication and interfaces.This articlehighlights the differences between OpenAPI and AsyncAPI in more detail.As another aspect, large projects usually include multiple teams working and developing together. Therefore, standardized development of APIs is a central aspect of cross-team application development. At the same time, the API definitions need to be available and easy to access for all teams. These demands are also addressed byApicurio Registry. It supports registering different document formats, e.g., OpenAPI, AsyncAPI, GraphQL, Apache Avro, or Protobuf.Since AsyncAPI is developing quite fast, we want to have a look at what the specification and corresponding tools currently cover. Additionally, we will shortly examine how Apicurio and AsyncAPI can work together at the moment. Nevertheless, there are many new tools and features for AsyncAPI on the roadmap. For this reason, this article can only be a snapshot. So stay tuned until the end of this post to get an outlook on what is next to come.Elements of an AsyncAPI DocumentComing to the basics of AsyncAPI: How does an AsyncAPI definition look? AsyncAPI allows using YAML or JSON for document definition. A document consists of the following elements:In practice, the definition can become quite long. Consider the below example from AsyncAPI’s GitHub to get an impression of how such a definition can look:asyncapi: '2.2.0'
info:
title: Streetlights Kafka API
version: '1.0.0'
description: |
The Smartylighting Streetlights API allows you to remotely manage the city lights.
license:
name: Apache 2.0
url:https://www.apache.org/licenses/LICENSE-2.0servers:
test:
url: test.mykafkacluster.org:8092
protocol: kafka-secure
description: Test broker
security:saslScram: []defaultContentType: application/jsonchannels:
smartylighting.streetlights.1.0.event.{streetlightId}.lighting.measured:
description: The topic on which measured values may be produced and consumed.
parameters:
streetlightId:
$ref: '#/components/parameters/streetlightId'
publish:
summary: Inform about environmental lighting conditions of a particular streetlight.
operationId: receiveLightMeasurement
message:
$ref: '#/components/messages/lightMeasured'components:
messages:
lightMeasured:
name: lightMeasured
title: Light measured
summary: Inform about environmental lighting conditions of a particular streetlight.
contentType: application/json
payload:
$ref: "#/components/schemas/lightMeasuredPayload"schemas:
lightMeasuredPayload:
type: object
properties:
lumens:
type: integer
minimum: 0
description: Light intensity measured in lumens.
sentAt:
$ref: "#/components/schemas/sentAt"
sentAt:
type: string
format: date-time
description: Date and time when the message was sent.securitySchemes:
saslScram:
type: scramSha256
description: Provide your username and password for SASL/SCRAM authenticationparameters:
streetlightId:
description: The ID of the streetlight.
schema:
type: stringIf you want to look at it in a more readable way, you can copy and paste the definition to theAsyncAPI Studioor theAsyncAPI playground(Remark: AsyncAPI Playground will soon be archived and replaced by AsyncAPI Studio). More examples are available onGitHub.I do not want to dive too deep into the exact details of the specification because thedocumentationis already helpful enough for this. But I want to highlight some parts of the specification that could be the icing on the cake when considering it.Besides some general information about the API, like the title and the description, the "Info" object can contain a"Contact" object. Especially when thinking about multiple groups working together, the responsible team and how to reach them can be linked at this place. In the example from above, this would look like this:asyncapi: '2.2.0'
info:
title: Streetlights Kafka API
version: '1.0.0'
description: |
The Smartylighting Streetlights API allows you to remotely manage the city lights.
contact:
name: API Support
url:https://www.asyncapi.org/supportemail:support@asyncapi.orglicense:
...The fixed structure defined by the specification might not be sufficient for all use cases. Therefore, it is possible to link external documentation for nearly every object in the AsyncAPI definition. Additionally, user-defined properties can be set toextend the specification. This can be done by simply prepending an "x-" at the field name. For example, we could add the internal team or project name:...
contact:
name: API Support
url:https://www.asyncapi.org/supportemail:support@asyncapi.orgx-project-name: Future-Light-X10
x-team-name: Kafka Streetlights Team
...For long and detailed API definitions, the document can become messy fast. As an improvement for this, it is possible to include references to internal and external resources (using the $ref field). They enable us to reuse objects, add schemas and add definitions from external sources.As another use case, let’s assume there are already event-driven applications using an Avro schema for their messages. For example, the schema is registered at Confluent Schema Registry or Apicurio Registry. Using $ref, it is possible to reference this Avro schema within a message object in the AsyncAPI definition:...
messages:
lightMeasured:
name: lightMeasured
title: Light measured
summary: Inform about environmental lighting conditions of a particular streetlight.
contentType: avro/binary
schemaFormat: application/vnd.apache.avro+json;version=1.9.0
payload:
$ref: 'http://schema-registry:8081/subjects/topic/versions/1/#LightMeasuredPayload'
...AsyncAPI also offers anAvro schema parserwhich collects local Avro references or remote files from Confluent Schema Registry and inserts them into the definition.Kafka, AMQP, MQTT or HTTP: Protocol-Specific PropertiesAs already mentioned at the beginning of this post, asynchronous communication can involve different types of protocols. As this is a fundamental aspect of your API definitions, AsyncAPI supports adding protocol-specific properties.These protocol-specific properties can be necessary on different levels: server level, channel level, operation level, and message level. For these levels, AsyncAPI allows defining protocol-specific objects, so-called bindings. Thisrepositoryprovides a complete list of all bindings and their specification details.For example, it is possible to add a key for Kafka messages:...
channels:
smartylighting.streetlights.1.0.event.{streetlightId}.lighting.measured:
description: The topic on which measured values may be produced and consumed.
parameters:
streetlightId:
$ref: '#/components/parameters/streetlightId'
publish:
summary: Inform about environmental lighting conditions of a particular streetlight.
operationId: receiveLightMeasurement
message:
bindings:
kafka:
key:
type: string
enum: ['Germany', 'Austria', 'Switzerland']
bindingVersion: '0.1.0'
$ref: '#/components/messages/lightMeasured'
...Unfortunately, for many protocols, there are a lot of binding objects which are not specified yet. E.g., for Kafka, there are no specifications for the Server and Channel Binding objects. In the case of Kafka, relevant but missing properties could be the number of partitions or the delivery guarantee. These properties would be a good use case forspecification extensionsthatcurrently cannot be used in binding objects.In addition, someconventionsfor the specification of bindings are on the roadmap. As protocol-specific bindings are still in the alpha version, this feature will become mature with continuous development.AsyncAPI and Apicurio: A Match?In contrast to theConfluent Schema Registry, Apicurio is not limited tomessage schemas but also supports API specifications. Apicurio could therefore also replace the Confluent Schema Registry.However, this is probably only true if the architecture does not mainly base on a Confluent ecosystem. But depending on the use case, Apicurio can be a helpful addition to the Schema Registry due to the additionally supported formats.Apicurio Registry allows registering AsyncAPI definitions, which can then be searched and browsed. At the moment, unfortunately, AsyncAPI documents are not rendered to make them more readable. External references (like in the example above) are currently not resolved automatically either. Orientation for this could be theAsyncAPI playground, where this is already possible. However, Apicurio Studio already offers this functionality for OpenAPI, and support for AsyncAPI in Apicurio Studiois already planned.At the same time, Apicurio also offers theData Models Library, which allows reading, writing, and modifying AsyncAPI and OpenAPI documents. TheDereferencer-classresolves external references to other documents and inserts them into the definition. It is also possible to add your implementations of theIReferenceResolverinterface for custom resolution of references.When testing the library, I noticed that it cannot resolve all references in a document yet: The AsyncAPI specification also allows references in the payload object of a message (as shown in the example above). The library only checks objects for links that also implement theIReferenceNodeinterface. However, thepayload objectdoes not yet implement this interface, and therefore, references in this object remain unresolved.There already is aGitHub issuewhich will hopefully resolve this soon.For Avro schemas, Apicurio Registry supports schema validation and a compatibility check. However, this seems to be still missing for AsyncAPI, even when the user interface suggests the opposite (see screenshot below). I tested this feature with syntactically invalid AsyncAPI definitions (which were classified as invalid by AsyncAPI playground), which were not recognized as wrong by Apicurio Registry. Also, definition updates, including breaking changes, were not recognized as so. Nevertheless, thisGitHub issuesuggests that support is planned.The Data Models Library of Apicurio and Apicurio Registry gives a first idea of what can be done with AsyncAPI. Nevertheless, the functionalities and use cases are still limited. When I tested the Data Models Library, I hoped for more features that could be used at runtime. In fact, it is currently cumbersome to extract message schemas from the AsyncAPI definition. Therefore, I would not recommend the library for this use case.However, one possibility would be to use Confluent Schema Registry or Apicurio Registry for Avro schemas. Messages could be serialized and deserialized with the schemas from there. The AsyncAPI definition can then reference these schemas. In addition, Apicurio Registry can be used as an API catalog. Developers could then use this catalog to work on new services or to mock applications.Besides these aspects, you should consider that Apicurio has little to no competition. At least I could not find another established open-source registry on the market that supports both schemas and APIs and so many formats. Feel free to leave a comment if you know more about this!As an alternative, it is also possible to build your own AsyncAPI catalog to support missing features. E.g., you could use existing AsyncAPI libraries and modules like theAsyncAPI React componentto render definitions. If you want to know how this could look, have a look atthis repositorywhere I implemented this myself. In this prototype, I used the React component with Angular. In case you feel more comfortable with other frameworks, it is also possible to integrate it in Vue or NextJS.If you want to test how Apicurio works, check out this smallquick start guide. It starts an Apicurio container and deploys some AsyncAPI example files.The Roadmap: What is Next to ComeIf you take a closer look at theGitHub repositoriesof AsyncAPI, you will quickly notice that a lot is happening here right now. There are many exciting and promising ideas, and the community seems to grow steadily. For example, anevent gatewayis currently being developed that will make it possible to validate and modify messages even before they arrive at the broker. Another idea is theGlee framework, which ensures that AsyncAPI definition and code match. At first glance, an unexpected project is theAsyncAPI Chatbot. It helps to create an AsyncAPI document without having to know the specification yourself.Besides these innovative ideas, there are also tools to enable validation and compatibility checks. TheCLItool validates AsyncAPI files. Also, theDifftool points out breaking changes to ensure backward compatibility. A combination of these projects would be helpful, as it is already requested onGitHub. These two tools could also be integrated into Apicurio Registry to add missing features.The AsyncAPI website also lists toolsdeveloped by the community. Many of these and several tools by the core team mainly support JavaScript - so ideally, you should not have a problem with that. Nevertheless, it is to be hoped that other programming languages will be supported in the future. This would make it easier for the community to access them.Many other official projects of the AsyncAPI team are still in the alpha or beta phase. Therefore, most of them cannot yet be used to their full potential. But since companies like eBay and Slack already use AsyncAPI, we can expect a lot more to come.If you want to dive a bit deeper, I recommend having a look at the recording of the AsyncAPI conference in November 2021. There were many interesting talks on how AsyncAPI can be used in projects and with other tools. For more details on how to use schemas, schema registries, and API registries with AsyncAPI, listen to my conference talk below.
"""
--------------------------------------------------------------------------------


Post 67
ID: https://www.asyncapi.com/blog/july-december-2021-at-asyncapi?utm_source=rss
Title: 2nd half of 2021 at AsyncAPI
Link: https://www.asyncapi.com/blog/july-december-2021-at-asyncapi?utm_source=rss
Summary: It has been a while since the last update on the things at AsyncAPI Initiative. Lots of things have happened since June. You better have a read or listen to the podcast.
Content:
"""
Around August, I communicated that because vacation is a dead season (in Poland we call it cucumber time) I will not do my monthly updates or write a single vacation summary.Well, the thing is that vacations were not as quiet as I expected. In September, a carousel started that was impossible to stop.I started writing status updates bi-weekly in early 2020. These were about simple improvements in specific libraries, very detailed on libraries release level. Back then, I basically knew every single new thing happening in the initiative. This year I switched to monthly updates as there was simply too much happening, and I could not really do those bi-weekly. I also started picking the most important news as there were too many things happening.I submit my official apologies to those awaiting my update-related articles. Honestly, looking at the size of the community and the growth that we are noticing, I don't know how I'll manage to publish these regularly in 2022. Maybe we should start writing those as a collective.What I can promise for sure is that in January 2022, I will write a summary article about AsyncAPI growth in 2021.More regular live-streamsWe started two live streams under the AsyncAPI brand:Thinking Out Loudis hosted by AsyncAPI Founder (Fran Mendez). He invites different community members to talk about AsyncAPI specification. All recordings are availablein the official YouTube playlist. Fran plans to continue doing them in 2022 as well.Contributor-firstis strictly targeted at new or existing contributors. Any AsyncAPI Technical Steering Committee member can volunteer as a host and talk about specific contribution-related topics. We aim to have it as frequently as possible, at least once a week. All recordings are availablein the official YouTube playlist. Based on the community feedback, the live stream will be renamed toLet's talk about contributingin 2022.Hosting these live streams is all possible thanks to the great support from theRestream.iofolks who gave us free access to the tool that enables us to live stream directly to all our social media channels.All official meetings are always listed in our:Community repositoryofficial Google CalendarThe best way to learn about a new event is to joinour official Google Groupthat we use as a mailing list for invites.Solving publish/subscribe confusion aka possible AsyncAPI 3.0 release in 2022It was hard to find someone in the community that was not confused by the semantics related to thepublishandsubscribeoperations when learning about the AsyncAPI specification. Many people were asking in Slack. People were also opening pull requests to fix our documentation, assuming we mixed things up by accident.There are cases where education is not enough. You can have great docs and education materials. Still, some stuff just needs to be improved and cannot be fixed by documentation.At the beginning of my tech career, I learned a sentence from an experienced developer: "documented bugs become features". Sometimes you do not have a chance to learn from the best😅This is causing too much confusion and needs to be solved in 2022. It is probably not possible without a breaking change in the specification.Please join us and help us improve not only the specification but also update the tooling:Proposal to solve publish/subscribe confusionThe many meanings of an AsyncAPI fileGoogle Summer of Code SummaryWe closed holidays 2021 with massive success of theGoogle Summer of Codeparticipants. All participants not only finished their projects, but they also became members of AsyncAPI Technical Steering Committee and also got a chance to present their work at the 2021 AsyncAPI Conference.Aayush SahucreatedDiffKhuda Dad NomanicreatedOptimizerArjun GargcreatedCupidElegbede Azeez Wahab aka AcecreatedChatbotNektarios FifescreatedSimulator. He could not unfortunately join us at the AsyncAPI Conference to talk about his work, but I'm sure he will be open to answer any of your questions asked through GitHub Issues.It was a pleasure to work with these folks and see them staying with us after GSoC ends. I, thereforeproposed we do it again in 2022 on a larger scale.Technical Steering Committee members setupAfter joining theLinux Foundation (LF)and applying theopen governance model, it was time for us to start setting up a Technical Steering Committee (TSC).So here we are, 9 months after joining LF, we already have 24 members. Check out thecomplete list of all the TSC members. Pay attention to those that are marked asAvailable for hire. Don't let folks work for free. Pay them to work on open-source. Be good humans.Do you want to be on that list? Watch the following👇presentation.There are many things still missing, such as a TSC list synchronization, voting process automation, and more. Other things still need a lot of work. If you want to contribute to the project and you are a fan of automation, this is the right topic to help with.Welcome Studio and Goodbye PlaygroundWe released a new application that you can use to work on your AsyncAPI files.Before, you could use the AsyncAPI Playground, but now we are redirecting traffic to a new, beautiful👉AsyncAPI Studio👈The new Studio has a bright future, and you should expect lots of new features coming there. I definitely recommend checking outStudio's GitHub repository.The cool stuff is that it is also integrated with theAsyncAPI CLI:1#install CLI2npm install -g @asyncapi/cli3#create new file using an example4asyncapi new --file-name=asyncapi.yml --example=default-example.yaml --no-tty5#start studio that picks up asyncapi.yml file from the context it runs in6asyncapi start studioRepository withPlayground source codewill most probably be archived and moved toorganization with old archived projects.HackathonThis year, we hosted our firstAsyncAPI Hackathon. Even though we did not have a dedicated marketing campaign, and even though AsyncAPI is not trivial and requires experience to build tools for it, we received 9 submissions.Souvik Dewon first prize withAsyncAPI Bundler. Check out Souvik talking about the AsyncAPI Bundler at AsyncAPI Conference.We also had 2 folks that tied in 2nd place:AcesubmittedAsyncAPI BlocksGreg MeldrumsubmittedEvent Discovery AgentCongrats to all of you folks!Check outthis discussion to get more details on the Hackathon voting process.P.S. During the Hackathon, we also had a lot of people engaging with us because of Hacktoberfest. We got30 issues resolved and merged.ConferenceCOVID-19 is still here. Thus, we decided to host the 2021 AsyncAPI Conference this year only in online mode. It was a three-day event with lots of great content, and most importantly, with the 1st day dedicated to contributors only.The conference was live-streamed. Full-day recordings were released immediately, and individual talk recordings will follow. All will be listed under thededicated Conference playlist.Check out the current sum of people that watched it during the conference and after as recordings:Day 1:YouTube: 1119Twitch: 89 (during event only, later Twitch removes old videos)LinkedIn: 148Twitter: 692Total:2048Day 2:YouTube: 737Twitch: 56 (during event only, later Twitch removes old videos)LinkedIn: 49Twitter: 283Total:1125Day 3:YouTube: 521Twitch: 26 (during event only, later Twitch removes old videos)LinkedIn: 29Twitter: 312Total:888These numbers are great if we compare them against a total of 600 registrations!Personally, the best number that I discovered was when I started listing the names of all the people who helped during the hackathon and conference organization. I think 62 is now my favorite number❤️Picture showing names of all people that helped in event organization.What about 2022? People during the conference voted for a hybrid approach:Picture showing that out of 25 voters, 18 (72%) voted for a hybrid conference that is both online and in-person.Joinrelated discussion and help organize it.Photo byIan SchneideronUnsplash
"""
--------------------------------------------------------------------------------


Post 68
ID: https://www.asyncapi.com/blog/changes-coming-docs?utm_source=rss
Title: Change is coming to our AsyncAPI Developer Documentation
Link: https://www.asyncapi.com/blog/changes-coming-docs?utm_source=rss
Summary: Did you know that you can contribute Docs to AsyncAPI as well? Code isn't the only way to contribute to OSS; Dev Docs are a huge help that benefit the entire OSS ecosystem.
Content:
"""
🦄Hola, soy Quetzalli Writes¡Hola!😄AsyncAPI community, it's an absolute pleasure to meet you. My name is Quetzalli. I was born and raised in México🇲🇽, so my first language is Spanish.I’m a Senior Technical Writer👩🏻‍💻recently hired by Postman to focus solely on the Open-Source (OSS)AsyncAPI initiativeas primary owner for our AsyncAPI Dev Docs 📄 .I also recentlyjoined our initiative's Technical Steering Committee (TSC)! The TSC is responsible for the oversight of the AsyncAPI Initiative, helping make decisions on a higher level, or when maintainers cannot find a consensus.By the second day, I was already working on community Pull Requests (PRs) and getting to know more of our community members. This direct engagement with community feels amazing, because I reallydowant to help as much as I can. I'm excited to listen what our OSS community thinks needs to be documented first.Before I tell you more details about upcoming changes to the Docs and how you can contribute to them, I also want to share more granular details about my work here within our OSS community.👩🏻‍💻What I do for AsyncAPI DocsOwn the docs for the AsyncAPI feature set— documenting this specific area of our Open Technologies function and driving all docs efforts around it.Plan documentation in conjunction with OSS community feedback— working with open-source communities to learn about a feature from specifications and user research.Collaborate closely with Developer Relations to ensure docs, educational, and learning materials align with community needs:this includes assisting with documentation, tutorials, and all education efforts within AsyncAPI.Conduct editorial reviews on community doc drafts— providing constructive and kind feedback that helps colleagues to grow.Liaise with stakeholdersacross the AsyncAPI Initiative to establish and address docs needs.MaintainAsyncAPI Docs GitHub Discussions.💄AsyncAPI Docs are getting a makeover!Now that I've introduced myself, my role, and high-level goals, I wanted to tell you more about some of the cool stuff coming up for AsyncAPI Docs. Pretty big changes are coming to our Dev Docs; in fact, our first "big" item to tackle will be giving the Information Architecture (IA) a makeover!😭Why do we need to make so many changes?The current docs and repo READMEs were(are) made with much care and love, but with growth comes change, and with change comes improvements!In our case, we need to add...Conceptual docsthat explain our spec terminology in more detail that includeengineering diagrams: people often learn visually!Many more tutorials.(i.e. Websocket tutorial)CLI docsunder aReferencecontent bucket.Atools section! Currently we have documentation for our tools in individual tools' GitHub repos, under a/docsdirectory. Those should still remain there and continue to be maintained, but they also need to be documented in our Docs in a less informal way than what you see in aREADME.UsecasesandTroubleshooting Guides, under a newHow-Tosection.🪣Agnostic Content Buckets, coming right upEngineering Documentation can and should be divided intoagnosticcontent buckets.Currently, our documentation has the following content buckets:Getting StartedTutorialsSpecificationCommunityIn upcoming months, the plan is to change it to the following content buckets instead:ConceptsTutorialsReferenceHow-ToToolsWhy, you wonder?It was important (and exciting!) to me to introduce best practices from theDiátaxis Frameworkfor our new content buckets.Photo fromDiátaxisonDiátaxis frameworkThe Diátaxis engineering documentation system classifies content under 4 mainagnosticbuckets. This approach for Information Architecture (IA) and User Flows in dev docs is currently upheld widely within the tech industry.(i.e. One current live example is GatsbyJS, which also uses the Diátaxis system for their Dev Docs. If you want to see a longer list of companies using it, go overhere.)The Diátaxis 4-Part Classification System:concepts:Defining concepts within a technology's features and capabilities.how-to:Solve a problem or advanced use case by doing.tutorial:Learn a beginner process or concept by doing.reference:Learn how to set up your development environment, CLI, APIs, etc.💁🏻‍♀️How does the Diátaxis system apply to an actual technology?Let’s take a look at the following Mind Map.Here we see that the AsyncAPICLIandSpecfall under theReferencebucket. TheConceptsbucket details AsyncAPI's specification concepts and terms that deserve to be covered in more detail. But when it comes to understanding the difference between what fits under aTutorialvs. aHow-Tobucket, it feels harder to understand.Let’s make the subtle difference between the audiences forTutorialandHow-Tobuckets clearer.The Tutorial bucketThink of a Tutorial as something that you need to teach a user that is new to your technology.A first-time AsyncAPI user.A user who is new to APIsANDAsyncAPI.The How-To bucketThink of a How-To as the bucket to address problems and advanced scenarios that you already know your users will encounter. These problems tend to fall under unique usecases or advanced troubleshooting guides that a more active user would encounter.How to generate documentation from an AsyncAPI fileHow to generate a standalone static website with documentationHow to generate documentation in a component that you can embed in an existing websiteHow to generate markdownHow to generate PDFsHow to reuse schema definitions from an OpenAPI file with an AsyncAPI fileOrganising your AsyncAPI filesGenerating documentation from your AsyncAPI filesDescribing WebSocket APIs with AsyncAPI👉🏽How to contribute to AsyncAPI DocsDid you know that you can contribute Docs to AsyncAPI as well?Code isn't the only way to contribute to OSS; Dev Docs are ahugehelp that benefit the entire OSS ecosystem. At AsyncAPI, we value Doc contributions as much as every other type of contribution.❤️To get started as a Docs contributor:Familiarize yourself with ourproject's Contribution Guideand ourCode of Conduct.Head over to ourAsyncAPI Docs Board.Pick an issue you would like to contribute to and leave a comment introducing yourself. This is also the perfect place to leave any questions you may have on how to get started.If there is no work done in that Docs issue yet, feel free to open a PR and get started!Docs contributor questionsDo you have a documentation contributor question and you're wondering how to tag me into a GitHub discussion or PR? Never fear!Tag me in your AsyncAPI Doc PRs orGitHub Discussionsvia my GitHub handle,quetzalliwrites🐙.🙂Talk to meI want and need to listen👂🏽to all of your perspectives and ideas. Please don't be shy to express to me what you think needs to be documented first or what is missing.📝There's a lot of good work ahead, butyoudetermineour content roadmapbecause the OSS community needs should always come first.✨
"""
--------------------------------------------------------------------------------


Post 69
ID: https://www.asyncapi.com/blog/asyncapi-discovery-intro?utm_source=rss
Title: Align Production Reality and Event Documentation with the AsyncAPI Discovery Tool
Link: https://www.asyncapi.com/blog/asyncapi-discovery-intro?utm_source=rss
Summary: The idealized world of AsyncAPI is neat and tidy:

Interface definitions show developers exactly what events are exchanged amongst producers and consumers.
Event contracts only change when permitted b
Content:
"""
The idealized world of AsyncAPI is neat and tidy:Interface definitions show developers exactly what events are exchanged amongst producers and consumers.Event contracts only change when permitted by well-defined governance processes.Bindings fill in the implementation details for open-source brokers like Kafka (including Confluent) and RabbitMQ along with closed-source brokers like IBM MQ and Solace.The real world is often messier.This postAlign Production Reality and Event Documentation with the AsyncAPI Discovery Toolappeared first onSolace.In the decades-long absence of an asynchronous API spec, teams adopted (or didn’t adopt, or chose to ignore) different API definitions and governance. The result is a twisted mess of event producers, consumers, data paths, and multiple broker technologies, from on-premises to cloud connections.Oftentimes, removing an event topic or queue requires nerves of steel, for fear it might disrupt key functionality. Many a middleware engineer has found religion during a production broker clean-up.Thankfully, the AsyncAPI Discovery Tool offers a better way.How the AsyncAPI Discovery Tool WorksThe AsyncAPI Discovery Tool analyzes event traffic passing through brokers like Kafka, RabbitMQ, IBM MQ, Solace, and more. After learning how the broker distributes events, the AsyncAPI Discovery Tool generates a correspondingAsyncAPI specification. The generated spec can be used for code generation, documentation, visualization, infrastructure deployment, and more.It’s a great starting point for getting events catalogued and governed.It’s not perfect (more on that later), and there’s a lot more work to be done, but the AsyncAPI Discovery Tool helps your enterprise align production reality with AsyncAPI documentation. And perhaps relieve some tension for middleware engineers.Getting Started with AsyncAPI Discovery ToolGetting started means a trip to theSolaceLabs GitHub, where you can find detailed instructions and documentation. (While Solace created the AsyncAPI Discovery Tool, it’s open-source with an Apache 2.0 license.)The AsyncAPI Discovery Tool runs as a stand-alone Java Jar, so getting it running requires only Java and Maven. Once it’s up and running, AsyncAPI has its own self-contained UI, offering fill-in-the-blanks configuration. You can read more details about the UI (here).Here’s an example for Kafka:Just fill in the configuration, asking your friendly local administrator for help if needed, and then click the “Start Scan” button. After grinding away, the AsyncAPI Discovery Tool returns a consolidated spec file. The AsyncAPI file describes the channels and schemas of events passing through the broker. From there, the world is your oyster: generate code, create infrastructure, or start governing your events.The Future of the AsyncAPI Discovery ToolThe most obvious place to improve the AsyncAPI Discovery Tool is to expand the number of supported brokers. Right now, it supports:Apache KafkaSolace PubSub+NATSRabbitMQHiveMQFortunately, the tool was built with extensibility in mind. There is a documented plug-in architecture just itching to have more brokers added. If you’re interested, the people who maintain the tool welcome pull requests.The confusingpublishandsubscribeverbs in the output.The requirement that a single file must represent a single application makes it tough to get a high-level understanding of the architecture.As the spec matures, the tooling will hopefully be close behind.ConclusionIn the meantime, the AsyncAPI Discovery Tool can be a huge help to enterprises that are new to AsyncAPI but experienced with event-driven architecture and messaging. The AsyncAPI Discovery Tool can start you down the road from a tangled event mess to a well-organized, fully documented, tightly governed architecture.If you have more questions or want to share your experience with these standards, you can let us know in theAsyncAPI Slackor theSolace Community Forum.
"""
--------------------------------------------------------------------------------


Post 70
ID: https://www.asyncapi.com/blog/the-reference-rabbit-hole?utm_source=rss
Title: The Reference Rabbit Hole
Link: https://www.asyncapi.com/blog/the-reference-rabbit-hole?utm_source=rss
Summary: Sergio and I went down a bit of a rabbit hole the last couple of days while discussing Fran's proposal to solve the publish/subscribe confusion; I thought I would share the journey. 

A lot of this ca
Content:
"""
Sergioand I went down a bit of a rabbit hole the last couple of days while discussingFran's proposal to solve the publish/subscribe confusion; I thought I would share the journey.A lot of this can be seen as nitpicking... And I totally get this, as we need to venture deep into the specifications to fully understand the differences.I'm going to try to not use any complex words and explanations so that everyone can understand the problems, whether you're a novice or an experienced AsyncAPI user.So let's split up the understanding of what references are, where references can be used, and what's down this rabbit hole.AsyncAPI referencesIn AsyncAPI, we have something called aReference Object, which simply enables reusability in your AsyncAPI documents. This is possible through the simple keyword$ref. If we take a look at thestreetlight tutorial, to utilize reusability, we could changethe documentto:1asyncapi:'2.2.0'2...3channels:4light/measured:5publish:6summary:Informaboutenvironmentallightingconditionsforaparticularstreetlight.7operationId:onLightMeasured8message:9$ref:'#/components/messages/LightMeasured'10components:11messages:12LightMeasured:13name:LightMeasured14payload:15$ref:'#/components/schemas/LightMeasurement'16schemas:17LightMeasurement:18# Ignore the specifics here for now.Here you can see that we simply reference where the definition of messages and payload schema is located.Schema Object referencesAs seen in the streetlight example, to define your message payloads in AsyncAPI, we use aSchema Object, which is a superset ofJSON Schema draft 7.Whatsupersetmeans is we follow the JSON Schema draft 7 specification, but with a few modifications and additions to keywords.The messageLightMeasured, contains a keyword calledpayload, which is by default defined as aSchema Object.This is where the confusion starts, what behavior does the$refkeyword follow? More precisely, which specification?The confusion creeps inLet's take a closer look at theSchema Objectto see if we can figure out the answer.Further information about the properties can be found in JSON Schema Core and JSON Schema Validation. Unless stated otherwise, the property definitions follow the JSON Schema specification as referenced here.So what this means is that unless stated otherwise in theSchema Object, it should follow the official JSON Schema draft 7 specification. So let's try to read further, to see if anything is stated about references.Alternatively, any time a Schema Object can be used, aReference Objectcan be used in its place. This allows referencing definitions in place of defining them inline.Okay... So that must mean that if we ever encounter a reference, we follow theReference Objectdescription.Well, that was easy; I see no rabbit hole here, Jonas!?Welcome to the rabbit holeDuring the discussion, Sergio brought up that Fran was using an illegal reference, as he, in one of the examples, was using aReference Objectfor a server, which was not allowed.  More specifically, it was this example where he references themosquittoserver:1...2servers:3mosquitto:4$ref:'common.asyncapi.yaml#/components/servers/mosquitto'My immediate reaction was "wait... It's not?!"I had always used$refquite extensively in my AsyncAPI documents and specifically used a reference for servers. And I knew that the tooling had no problems with the$refas long as it was a valid reference.But Sergio was absolutely right; a second look at the specification showed thatserversare defined using theServers Object, which is defined by using a map ofServer Objects.NOTServer Object | Reference Objectas I expected.After that, we started to realize that there is quite a big difference between when and whereReference Objects are allowed. For the full list of discrepancies, check outspec #650.But... Why did I think it was allowed to do so?Discrepancies in AsyncAPI ToolingSo back to my own experience, why was I so sure that the tooling allowed for me to useReference Objects for servers?Well, as it turns out, it's because theJS parserdereferences before it validates the AsyncAPI document. This means that if I defined my AsyncAPI document as follows:1asyncapi:'2.2.0'2...3servers:4test-server:5$ref:'./servers/testServer.yaml'6...Together withtestServer.yaml:1url:ws://mycompany.com/ws2protocol:wsValidating the AsyncAPI document using a tool such asajvagainst theJSON Schema representation for 2.2.0, it would reject it.However, because the parser dereferences first, the document that is being validated is this:1asyncapi:'2.2.0'2...3servers:4test-server:5url:ws://mycompany.com/ws6protocol:ws7...Checkoutparser-js #405for more information.What about$idkeywordOne of the key differences between ourReference Object, and how$refis resolved in JSON Schema Draft 7, is the$id keyword. This allows you to define a URI that is used as a base URI. This means that for example a message such as this:1asyncapi:'2.2.0'2...3channels:4test/channel:5publish:6message:7schemaFormat:application/schema+json;version=draft-078payload:9$id:https://example.com/schemas/test10type:object11properties:12address:13$ref:"address"14...This will result in the reference for theaddressproperty, to be looked up athttps://example.com/schemas/address, because it uses the Base URI in$idfrom the parent schema (https://example.com/schemas).I tried a little test in thenew Studio tool(Studio uses the parser, so it could be used for an easy test),which showed that this was not supported by the parser. The library tries to resolve the reference athttps:///addresswhen it should have tried to resolve it fromhttp://example.com/schemas/address. Seeparser-js #403for more information.What about$schema?Before getting into$schemaI first need to mention a keyword in AsyncAPI calledschemaFormat which is part of the Message Object. What this keyword is used for is to change what format the payload is defined with. By defining it withapplication/vnd.aai.asyncapi+yaml;version=2.2.0it is the same as the default format.In JSON Schema Draft 7, and in theSchema Object, there exists a keyword, similar to whatschemaFormatis for AsyncAPI, that can be used to define what version of JSON SchemaLightMeasurementfollows.So what if both are defined at the same time, and they contradict each other?1asyncapi:'2.2.0'2...3components:4messages:5LightMeasured:6name:LightMeasured7schemaFormat:application/vnd.aai.asyncapi+yaml;version=2.2.08payload:9$ref:'#/components/schemas/LightMeasurement'10schemas:11LightMeasurement:12$schema:'http://json-schema.org/draft-04/schema#'13...With such contradicting information, how should tooling handle this? This sparkedspec #655.What about extra keywords?Following that, by taking a closer look at theJSON referencespecification theReference Objectfollows, we find thesentence:Any members other than "$ref" in a JSON Reference object SHALL be ignored.What this means, is that if we have a reference defined such as:1...2components:3messages:4LightMeasured:5payload:6type:boolean7$ref:'#/components/schemas/LightMeasurement'8schemas:9LightMeasurement:10type:stringThetypeproperty for the message payload, should be completely ignored. So let's try and see what happens when we try this inStudio.Once the schema is parsed, all that remains istype: boolean, and not the expectedtype: stringfrom the referenced schema. This is clearly the opposite of what the specification defines. For more information seeparser-js #404.We then asked ourselves, what about JSON Schema, does it define a different behavior? The answer to this question can be foundhere:All other properties in a "$ref" object MUST be ignored.Luckily, they both match the same behavior in terms of extra keywords. Both Reference Object and JSON Schema should ignore extra keywords.But, what if I use one of the newer JSON Schema versions, what then?Upgrading to JSON Schema draft 2020-12We started to correlate the findings with the feature request fromMaciejabout updating AsyncAPI Schema Object to point towardsJSON Schema Draft 2020-12.What would this mean for our little$refkeywords?OpenAPI have in its most recent version 3.1, switched its default JSON Schema version to Draft 2020-12, the exact feature request for AsyncAPI. This, however, introduced a huge change to how you bundle references. I don't want to spend much time on this asBenandMikedescribed this entire change and what it means in terms of bundling in this great blog postBundling simple external resources. Besides this, the release notes for Draft 2020-12 also offers some guidance which can be found here:https://json-schema.org/draft/2020-12/release-notes.htmlBesides having a bunch of new keywords that change the referencing behavior, such as$dynamicRef,$dynamicAnchor,$anchor, one of the key differences is that inJSON Schema draft 2019-09, they changed their behavior of references so that extra keywords are now allowed adjacent to$ref.But what does this mean exactly? Does this mean$refoverwrites any duplicated properties? Or is it the other way around?Well, there is one thing we need to remember about JSON Schema. It is primarily built for validation rules and how a validator can take input data and determine whether that input is valid against the Schema.This means, that if you have a JSON Schema using$refsuch as:{"$ref":"./test.json","minLength":7,"maxLength":12}andtest.jsonis defined as:{"minLength":5,"format":"email"}JSON Schema draft 2019-09, assumes that the references are resolved similar to:{"$ref": {"minLength":5,"format":"email"},"minLength":7,"maxLength":12}This is because in validation, you want to validate that the input data is valid against the referenced schema and shouldnotbe seen as a kind of merging behavior:{"format":"email","minLength":7,"maxLength":12}This behavior is different from what is assumed when using AsyncAPI, as the last option, is more aligned with expected behavior.Furthermore, now, each schema can define it's own$schemathat they follow, instead of ONLY being available at the root...This leaves the question, how can we make sure that we stay consistent and don't introduce more confusion into the AsyncAPI specification? This difference is what triggered the last issue inspec 649.Hard to find toolingThis leaves us with one huge deficit, that there are so many different behaviors for references that tooling mix and matches between the specifications and what they solve.One of the most used tooling for dereferencing stuff in JS, and the one we are using is fromAPIDevTools called json-schema-ref-parser. We actually use this tool to ensureANYencounters of$refare dereferenced, so the tool has direct access to the schema, without it having to look elsewhere for it.However, the tool started out being builtONLYfor dereferencing$refbased on theJSON Reference specification and the JSON Pointer specification.  At least it was, now it's not easy to figure out what it is for, asit allows extra propertiesbut$id is not taken into account.This leaves us in a bit of a struggle, asthere are not many alternatives; JS@hyperjump/json-schema-corelooks promising, but there's no tooling that ourGo parsercan use.And with no official or community tooling, we are left with having to develop it ourselves to adopt the spec... There are luckily efforts being made inJSON Schema to adopt to such a change.Final wordThat concludes the rabbit hole that Sergio and I went down, for a simple$refkeyword... (ONE KEYWORD!😅)If you have any comments or issues with what was described here, please go into the respective issues and make a comment - also if you think we are wrong!In case you are interested, we are also looking for contributors, to help us solve these issues. If you want to take one up, just write a comment in the respective issue.Overview of issues:spec #650, highlights the discrepancies when the Reference Object can be used.spec #649, tries to solve the core issue that$refmeans two different things, depending on when it's used.spec #655, what do you do when encountering$schemaand Message ObjectschemaFormat, especially when they are contradicting.parser-js #405, highlights that the parser accurately validates incorrect AsyncAPI documents, because it bundles references before validating.parser-js #404, highlights that the parser allows for keywords to be defined together with$refand are not being ignored.parser-js #403, highlights that the parser does not care about$idin the Schema Object when it should.Photo byNigel TadyanehondoonUnsplash
"""
--------------------------------------------------------------------------------


Post 71
ID: https://www.asyncapi.com/blog/socketio-part2?utm_source=rss
Title: The journey of documenting a Socket.IO API (Pt 2)
Link: https://www.asyncapi.com/blog/socketio-part2?utm_source=rss
Summary: This post originally appeared on https://dedouss.is



In the opening part of this series we outlined the basics of Socket.IO and discussed the importance of documenting Socket.IO APIs. Now it’s time
Content:
"""
This post originally appeared onhttps://dedouss.isInthe opening part of this serieswe outlined the basics ofSocket.IOand discussed the importance of documenting Socket.IO APIs. Now it’s time to bringAsyncAPIinto play.In this post we’re going to cover:A modelling exercise, in which Socket.IO semantics are mapped to AsyncAPI structuresA tutorial involving the creation of an AsyncAPI specification given an existing Socket.IO APIAsynction, a Socket.IO server framework driven by the AsyncAPI specificationModelling the Socket.IO protocol using AsyncAPIDon’t let the title of this section intimidate you. This modelling exercise ended up being relatively straightforward and I think it makes a great example of how AsyncAPI was designed to fit any event-driven protocol. If you are not interested in the thought process behind this exercise, you may jump straight to theSummaryparagraph of this section, which presents the solution.I will approach this problem by traversing the AsyncAPI object structure, attempting to map each of the objects to a semantic of the Socket.IO client API.The root object of the specification is theAsyncAPI Object. The fields of this object that require special attention arechannelsandservers.ChannelsTheChannels Objectis a map structure that relates a channel path (relative URI) to aChannel Item Object.1channels:2/:{}# Channel Item Object3/admin:{}# Channel Item ObjectChannels are addressable components where messages/events flow through. The specification suggests that a server may support multiple channel instances enabling an application to separate its concerns. This sounds very much like the definition of the Socket.IOnamespace. Namespaces are indeed addressable components that follow the relative URI convention. Since Socket.IO supports multiplexing, a client may emit messages to multiple namespaces over a single shared connection. However, it could also force a separate connection per namespace (using theforceNewoption). Thus, a Socket.IO namespace could either be a virtual or physical channel.Given that connections are established on the namespace level, theChannel Item Objectis the only object of the specification that MAY includebindings. For a Socket.IO API, theChannel Bindings Objectshould only contain thewsfield, in which one can specify the handshake context (HTTP headers and query params) that a client should provide when connecting to that particular channel/namespace.1channels:2/:3publish:{}# Operation object - Ignore this for now4subscribe:{}# Operation object - Ignore this for now5bindings:6ws:7query:8type:object9properties:10token:11type:string12required:[token]Since a single connection (and thus binding) is going to be used across multiple channels, there is no need to repeat the samebindingsobject under each channel/namespace. We can introduce the convention of always including bindings under the main (/) namespace but omitting them under the custom ones. At this point I would also like to propose the following bonus semantic: If a custom namespace includes bindings, then the client should alwaysforce a new connectionwhen connecting to it.You have probably noticed that I chose to stick to theWebSockets Channel Bindingas the only possible binding that a Socket.IO API may define. One could ask why not use anHTTP Channel Bindingobject alongside the WebSockets one, since the protocol could also be implemented via HTTP long-polling. There are 2 answers to this question:The current latest version of theAsyncAPI bindings specificationsdoes not allow HTTP bindings to be defined at the channel level.The HTTP long-polling implementation of Socket.IO is essentially a pseudo WebSocket. It is implemented in such a way to resemble the WebSocket implementation. The same HTTP headers and query params are sent to the server no matter the transport mechanism.Hence, it is safe to use the ws bindings even for the HTTP long-polling fallback. However, in an ideal world, we would have AsyncAPI supporting SocketIO bindings through an explicitsocketiofield. In fact, I have createda github issueto pitch this proposal.Along withbindings, theChannel Item Objectincludes thepublishandsubscribefields, in which one defines the operations that a namespace supports. ThepublishOperation Objectlists all the possible events that the client may emit (socket.emit), while thesubscribeoperation defines the events that the client may listen to (socket.on).A Socket.IO event can be expressed using theMessage Object, where thenamefield describes theeventNameand thepayloadfield describes the schema of theargsthat the client passes as part of thesocket.emitinvocation:socket.emit(eventName[, …args][, ack]). Forsubscribeevents,payloaddefines the structure of the arguments that the event handler callback expects:socket.on(eventName, (...args) => {}).The structure of the payload value depends on the number of arguments expected:ScenarioSender-side codePayload value structureAsyncAPI Message ObjectNo args expectedsocket.emit("hello")n/a — Payload field should be omittedname:helloSingle arg expectedsocket.emit("hello", {foo: “bar”})Anytypeother thantuplename:hellopayload:type:objectproperties:foo:type:stringMultiple args expectedsocket.emit("hello", {foo: “bar”}, 1)Tuple typename:hellopayload:type:arrayprefixItems:-type:objectproperties:foo:type:string-type:numberTo account for multiple events (Message Objects) per namespace, themessagefield of eachOperation Objectallows theoneOfarray structure. For example, in the message of the publish operation of the/adminnamespace, theoneOfarray lists all the availableeventNameandargspayload pairs that a client can pass to theadminNamespace.emitcall:1channels:2/admin:3publish:4message:5oneOf:6-$ref:"#/components/messages/MessageOne"7-$ref:"#/components/messages/MessageTwo"Now, let’s move on to the acknowledgement semantics of the protocol: The basic unit of information in the Socket.IO protocol is the packet. There are 7 distinctpacket types. The payloads of the publish and subscribe Message Objects described above correspond to theEVENTandBINARY_EVENTpacket types. These are essentially the packets that are transmitted when the Socket.IO sender invokes theemitAPI function of the Socket.IO library (regardless of implementation). In turn, the Socket.IO event receiver handles the received event using theonAPI function of the Socket.IO library. As part of theonhandler, the receiver may choose to return an acknowledgement of the received message. This acknowledgement is conveyed back to the sender via theACKandBINARY_ACKpacket types. The ack data is passed as input to the callback that the message sender has provided through theemitinvocation.Socket.IO ack sequence diagramIn order to express the above semantics, the Message Object (eventName and args payload pair) should be linked to an optional acknowledgement object. Since the specification in its current form does not support such a structure, I am proposing the followingSpecification Extension:Message Objects MAY include thex-ackfield. The value of this field SHOULD be aMessage Ack Object.Components ObjectMAY include thex-messageAcksfield. The value of this field should be of type:Map[string, Message Ack Object | Reference Object].Message Ack ObjectField NameTypeDescriptionargsSchema ObjectSchema of the arguments that are passed as input to the acknowledgement callback function. In the case of multiple arguments, use the array type to express the tuple.In the case of apublishmessage, thex-ackfield informs the client that it should expect an acknowledgement from the server, and that this acknowledgement should adhere to the agreed schema. Likewise, forsubscribemessages thex-ackfield encourages the client to send a structured acknowledgement, for each message it receives.ServersTheServers Objectis – surprise surprise – a map of Server Objects. EachServer Objectcontains aurlfield from which the client may infer the custom path to the Socket.IO server. This custom path should then be provided via thepathoption upon theinitialisation of the Socket.IO connection manager, alongside theurlarg. Theprotocolfield of theServer Objectis also required, and specifies the scheme part of thaturlarg. Its value should equal any of thews,wss,httporhttpsprotocols. For a Socket.IO client, it does not really matter whether the scheme is http or ws, due to the upgrade mechanism. Thus, for Socket.IO APIs, the only purpose of theprotocolfield is to indicate the use (or absence) of SSL.SummaryWe made it to the end of the modelling exercise the outcome of which is the following table, relating Socket.IO semantics to AsyncAPI structures.Socket.IOAsyncAPINamespaceChannel(described through theChannel Item Object)IO optionsWebSockets Channel BindingnamespaceSocket.emit(eventName[, …args][, ack])Operation Objectdefined under thepublishfield of aChannel Item Object. The availableeventName&argspairs for thisemitinvocation are listed under themessagefield, through theoneOfarray structure.namespaceSocket.on(eventName, callback)Operation Objectdefined under thesubscribefield of aChannel Item Object. The availableeventName&callbackargument pairs for thisoninvocation are listed under themessagefield, through theoneOfarray structure.EventMessage(described through theMessage Object)eventNameThenamefield of theMessage Object)EventargsThepayloadfield of theMessage ObjectackThex-ackfield of theMessage Object. Requires anextension of the specification. The field may be populated for bothpublishandsubscribemessages.Custom path (pathoption)Theurlfield of theServer ObjectUse of TLS (regardless of transport mechanism)Theprotocolfield of theServer ObjectIn practiceWith the modelling exercise out of the way, I’m now going to guide you through the process of creating an AsyncAPI spec from scratch given an existing Socket.IO API. For the purposes of this simple tutorial, let’s usethis minimal chat application, which is one of the get-started demos featured in the Socket.IO website.Below is the source of our Socket.IO server:1// Setup basic express server2constexpress =require("express");3constapp = express();4constpath =require("path");5constserver =require("http").createServer(app);6constio =require("socket.io")(server);7constport = process.env.PORT ||3000;89server.listen(port,() =>{10console.log("Server listening at port %d", port);11});1213// Chatroom14letnumUsers =0;1516io.on("connection",(socket) =>{17letaddedUser =false;1819// when the client emits 'new message', this listens and executes20socket.on("new message",(data) =>{21// we tell the client to execute 'new message'22socket.broadcast.emit("new message", {23username: socket.username,24message: data,25});26});2728// when the client emits 'add user', this listens and executes29socket.on("add user",(username, cb) =>{30if(addedUser) {31cb({error:"User is already added"});32return;33}3435// we store the username in the socket session for this client36socket.username = username;37++numUsers;38addedUser =true;39socket.emit("login", {40numUsers: numUsers,41});42// echo globally (all clients) that a person has connected43socket.broadcast.emit("user joined", {44username: socket.username,45numUsers: numUsers,46});47cb({error:null});48});4950// when the client emits 'typing', we broadcast it to others51socket.on("typing",() =>{52socket.broadcast.emit("typing", {53username: socket.username,54});55});5657// when the client emits 'stop typing', we broadcast it to others58socket.on("stop typing",() =>{59socket.broadcast.emit("stop typing", {60username: socket.username,61});62});6364// when the user disconnects.. perform this65socket.on("disconnect",() =>{66if(addedUser) {67--numUsers;6869// echo globally that this client has left70socket.broadcast.emit("user left", {71username: socket.username,72numUsers: numUsers,73});74}75});76});7778// Admin7980io.of("/admin").on("connection",(socket) =>{81lettoken = socket.handshake.query.token;82if(token !=="admin") socket.disconnect();8384socket.emit("server metric", {85name:"CPU_COUNT",86value:require("os").cpus().length,87});88});I’ve slightly tweaked the original source located athttps://github.com/socketio/socket.io/tree/master/examples/chatto include acknowledgments and bindings, so that I can showcase the full spectrum of the AsyncAPI specification.Let’s start by defining the version of the specification as well as the info object which provides metadata about the service:1asyncapi:2.2.023info:4title:Socket.IOchatservice5version:1.0.06description:|7This is one of the get-started demos listed in the socket.io website:https://socket.io/demos/chat/Moving on to the servers section, where one should provide connectivity information for all the instances of their service. In the case of our simple chat application, there is only one demo server accessible atsocketio-chat-h9jt.herokuapp.com:1servers:2demo:3url:socketio-chat-h9jt.herokuapp.com/socket.io4protocol:wssThings get a bit more interesting when it comes to channels. Skimming through the server code we find 2 namespace instances (default and /admin), which means that the channel mapping should consist of 2 entries:1channels:2/:{}3/admin:{}Within each namespace connection block, there are multiplesocket.on, andsocket.emitreferences. For each unique reference, we need to append a Message Object under the publish and subscribe operations respectively:1channels:2/:3publish:4message:5oneOf:6-$ref:"#/components/messages/NewMessage"7-$ref:"#/components/messages/Typing"8-$ref:"#/components/messages/StopTyping"9-$ref:"#/components/messages/AddUser"10subscribe:11message:12oneOf:13-$ref:"#/components/messages/NewMessageReceived"14-$ref:"#/components/messages/UserTyping"15-$ref:"#/components/messages/UserStopTyping"16-$ref:"#/components/messages/UserJoined"17-$ref:"#/components/messages/UserLeft"18-$ref:"#/components/messages/LogIn"19/admin:20subscribe:21message:# No need to use `oneOf` since there is only a single event22$ref:"#/components/messages/ServerMetric"From the server code, we can also see that the connection handler of the admin namespace applies some very sophisticated authorization based on thetokenquery parameter. The spec should hence document that the API requires the presence of a valid token query param upon the handshake:1channels:2/:3publish:4# ...5subscribe:6# ...7/admin:8subscribe:9# ...10bindings:11$ref:"#/components/channelBindings/AuthenticatedWsBindings"Putting everything together into a single document:1asyncapi:2.2.023info:4title:Socket.IOchatdemoservice5version:1.0.06description:|7This is one of the get-started demos presented in the socket.io website: https://socket.io/demos/chat/89servers:10demo:11url:socketio-chat-h9jt.herokuapp.com/socket.io12protocol:wss1314channels:15/:16publish:17message:18oneOf:19-$ref:"#/components/messages/NewMessage"20-$ref:"#/components/messages/Typing"21-$ref:"#/components/messages/StopTyping"22-$ref:"#/components/messages/AddUser"23subscribe:24message:25oneOf:26-$ref:"#/components/messages/NewMessageReceived"27-$ref:"#/components/messages/UserTyping"28-$ref:"#/components/messages/UserStopTyping"29-$ref:"#/components/messages/UserJoined"30-$ref:"#/components/messages/UserLeft"31-$ref:"#/components/messages/LogIn"32/admin:33subscribe:34message:# No need to use `oneOf` since there is only a single event35$ref:"#/components/messages/ServerMetric"36bindings:37$ref:"#/components/channelBindings/AuthenticatedWsBindings"3839components:40messages:41NewMessage:42name:newmessage43payload:44type:string45Typing:46name:typing47StopTyping:48name:stoptyping49AddUser:50name:adduser51payload:52type:string53x-ack:# Documents that this event is always acknowledged by the receiver54args:55type:object56properties:57error:58type:[string,"null"]59NewMessageReceived:60name:newmessage61payload:62type:object63properties:64username:65type:string66message:67type:string68UserTyping:69name:typing70payload:71type:object72properties:73username:74type:string75UserStopTyping:76name:stoptyping77payload:78type:object79properties:80username:81type:string82UserJoined:83name:userjoined84payload:85type:object86properties:87username:88type:string89numUsers:90type:integer91UserLeft:92name:userleft93payload:94type:object95properties:96username:97type:string98numUsers:99type:integer100LogIn:101name:login102payload:103type:object104properties:105numUsers:106type:integer107ServerMetric:108name:servermetric109payload:110type:object111properties:112name:113type:string114value:115type:number116117channelBindings:118AuthenticatedWsBindings:119ws:120query:121type:object122properties:123token:124type:string125required:[token]The modified server source code is pushed athttps://github.com/dedoussis/asyncapi-socket.io-example, along with the above AsyncAPI spec, which can be viewed using theAsyncAPI playground.Note that there is no point in documenting thereserved eventssince all Socket.IO APIs support these by default.AsynctionIn parallel to this exercise I have been developingAsynction, a Socket.IO python framework that is driven by the AsyncAPI specification. Asynction is built on top of Flask-Socket.IO and inspired by Connexion. It guarantees that your API will work in accordance with its documentation. In essence, Asynction is to AsyncAPI and Flask-SocketIO, what Connexion is to OpenAPI and Flask.Inthis example, I forked the minimal chat application that we documented above and re-implemented the server in python, using Asynction. Be mindful of thex-handlerandx-handlersextensions that have been introduced to relate AsyncAPI entities (such as message or channel objects) to python callables (event handlers).You may find extensive documentation of Asynction at:https://asynction.dedouss.isThe framework is still at a beta stage, so please get in touch before using it in a production setup.Any piece of feedback would be much appreciated.The endFor any questions, comments, or corrections, feel free to reach out to me atdimitrios@dedouss.is.A special shout out toderberq,quetzalliwrites, and the wider AsyncAPI community for being particularly helpful and responsive.🙇Photo byMatt HowardonUnsplash
"""
--------------------------------------------------------------------------------


Post 72
ID: https://www.asyncapi.com/blog/release-notes-2.2.0?utm_source=rss
Title: AsyncAPI Spec 2.2.0 Release Notes
Link: https://www.asyncapi.com/blog/release-notes-2.2.0?utm_source=rss
Summary: 2.2 release of AsyncAPI specification is here. The long-awaited feature for assigning channels to servers is finally here.
Content:
"""
I'm happy to share that AsyncAPI specification 2.2.0 is here. Check out all the goodies that it brings.This is a minor release, and it doesn't bring any breaking changes. You can switch to it by modifying the following value in your AsyncAPI fileasyncapi: '2.1.0'intoasyncapi: '2.2.0'Assigning channels to serversThis feature allows the definition of AsyncAPI documents for applications with more selective use of channels and servers. An example is message protocol adapters that consume messages from one server (say, Kafka) and publish those messages to another server (say, Anypoint MQ).Now you can add a newserversproperty toChannel Item Object. It must be a list of server names provided as a string.1description:ThisapplicationpublishesWebUICommandmessagestoanAMQPqueueonRabbitMQbrokersintheStagingandProductionenvironments.2servers:3-rabbitmqBrokerInProd4-rabbitmqBrokerInStaging5subscribe:6message:7$ref:"#/components/messages/WebUICommand"8bindings:9amqp:10is:queueNames of servers must match the names of the servers defined in theServers Object. This new property is optional, so moving from 2.1.0 to 2.2.0 is as easy as changing the specification version in your current AsyncAPI file. Ifserversis absent or empty, the given channel must be available on all servers defined in the Servers Object, like the previous version.For more details, check outthis pull request.We heard some community members asking for this feature. It wasGerald Loefflerthat decided to champion the proposal and lead it until it got released. Thank you🙏.New protocol bindingsThe specification is now extended to support the following custom protocols through the bindings feature:Anypoint MQ, thanks toGerald Loeffler. For more details check outthis pull requestandbinding definition.Become a contributorPushing things through into the specification is not an easy process. It requires a lot of time and patience, but it is worth it. Have a look at ourcontribution guideand start contributing.ConclusionsAre you wondering how we managed to release 2.2.0 just three months after 2.1.0? I recommend you familiarize yourself with theAsyncAPI release process. The next release is scheduled for January 2022. Later releases are in April, June and September, according to the agreedrelease cadence.Does the above meme give you mixed feelings? Are you afraid of possible changes, or actually happy to see it coming? Don't overthink it! Join ourSlackand talk to us, or check out the3.0.0 milestone.Photo byJeremy ThomasonUnsplash
"""
--------------------------------------------------------------------------------


Post 73
ID: https://www.asyncapi.com/blog/socketio-part1?utm_source=rss
Title: The journey of documenting a Socket.IO API (Pt 1)
Link: https://www.asyncapi.com/blog/socketio-part1?utm_source=rss
Summary: This post originally appeared on https://dedouss.is



My recent adventures with Socket.IO took me off on a tangent, exploring the world of AsyncAPI as a means of documenting Socket.IO APIs. This is t
Content:
"""
This post originally appeared onhttps://dedouss.isMy recent adventures withSocket.IOtook me off on a tangent, exploring the world ofAsyncAPIas a means of documenting Socket.IO APIs. This is the first part of a series of blog posts covering the modeling of the Socket.IO protocol using AsyncAPI objects, followed by a step-by-step tutorial on how to create a specification YAML file given an existing Socket.IO API.Setting the sceneEarlier this year my team undertook the task of re-implementing the backend of a realtime chat application-mentioningre-implementingandbackendin the very first sentence is probably a PTSD trigger for many of you, but thankfully this post has nothing to do with rewriting-from-scratch horror stories. The app was originally built using a 3rd party push-notifications platform which allowed us to deliver a functional MVP in a relatively speedy manner. However, as new requirements started creeping in from the business, it was clear to the team that this 3rd party dependency was not really worth it anymore. We thus had to take the (arguably not so easy) decision to implement our own realtime API to gain complete control of each server connection. The design meeting would soon follow, to answer questions like“What framework should we use?”or“Would serverless make sense?”. The stack of the team, namely Python,FlaskandKubernetes, pointed us in the direction ofFlask-SocketIO, making Socket.IO the protocol of choice. Although pragmatic, this stack driven design approach felt very unorthodox. The tooling dictated the choice of the client<->server communication protocol rather than the other way around. It was a decision primarily based on the stack and the expertise of the backend team. What if the Socket.IO client library for Swift is not maintained anymore? What if Socket.IO is a very verbose protocol, not friendly for clients with limited network connectivity? Thankfully, this is not the case and Socket.IO happens to be a well supported and carefully designed protocol. Nonetheless, the decision was made and the development of a Socket.IO API was about to commence.In the spirit of not repeating the sins of the past (i.e. not focusing on the client<->server interface), I started looking into how one can document a Socket.IO API. By document, I mean putting together some sort of spec or contract that can be agreed upon and shared with the consumers of the API. To my surprise, I couldn’t find a lot of resources on the topic. Coming from the REST world (whereOpenAPIis nowadays the de facto standard) and from theGraphQLworld (where everything is strictly typed), I found myself rather disappointed. It felt like the industry had been treating the documentation of event-driven APIs, such as Socket.IO or WebSocket ones, as a niche area not worth standardising. This felt odd, given how popular event-driven architectures had become over the past decade.After getting over the initial shock of this realisation, I finally managed to put together some properly worded google searches and came acrossAsyncAPI. Apparently, there is a growing community out there that serves this exact purpose of documenting event-driven APIs! Since 2017, the AsyncAPI folks have been developing a protocol agnostic specification for asynchronous APIs (inspired by OpenAPI), along with tooling such as spec parsers and code generators. Diving deeper into my google search, I looked for articles and tutorials on how one may express a Socket.IO API using the AsyncAPI specification. The only single resource I managed to find on the public cyberspace wasthis(not very comprehensive) StackOverflow answer. It was at this point when I realised that I was on my own, facing the problem of modelling the Socket.IO protocol using the AsyncAPI semantics. I decided to take on the challenge and if successful, write a blog post documenting my journey. So here we are.What is Socket.IO?Before jumping to the AsyncAPI part of the problem, let’s first try to establish some common understanding of what Socket.IO is.Many would argue that Socket.IO is a library rather than a protocol. In fact,its wikipedia entrydefines Socket.IO as a JavaScript library for realtime web applications. However, I regard this as an outdated definition. I see Socket.IO as a protocol of its own, with a JavaScript library being the reference implementation. It is a protocol enabling duplex, event-driven communication, treating the underlying WebSocket and fallback HTTP long-polling mechanisms as an infrastructure layer that the user should never be bothered with. The protocol is implemented in various languages (Java,Python,C++andRustto name a few) and has an official specification sourced athttps://github.com/socketio/socket.io-protocol.The caveat is that a user of Socket.IO (client or server) should never interact with the protocol directly, but instead use the Socket class API of the respective implementation library. The Socket class implements the following symmetrical interface:socket.on(eventName, callback):Registers a new handler (callback) for a given event.Implements a subscribing operation.The return value of the callback is sent to the sender party as an acknowledgement.socket.emit(eventName[, …args][, ack]):Emits an event to the receiver party.Implements a publishing operation.Theackcallback is invoked only if the receiver returns an acknowledgment.A more advanced concept of Socket.IO isNamespace, which enables multiplexing capabilities. A Namespace has its own event handlers (and potentially its own dedicated connection). Socket.IO uses the main Namespace (/) by default, but it is possible to set up multiple custom Namespaces.At this point one may wonder:This is all great, but why do we even need to document a Socket.IO API?TheeventNamegranularity allows Socket.IO to dispatch messages (args) based on event names. This means that a Socket.IO server could be supporting any amount of custom event names per namespace. Also note that the event payload (args) along with the ACK (callbackreturn value) can be of any type as long as it is serializable. Now imagine the very likely scenario of the Socket.IO client being developed from a completely separate team (or even company) to the one developing the server. How would the client know what namespaces and event names the server supports? And even if it was aware of the supported events, how would it know what data structures the server expects for each of those? Does the client need to acknowledge the messages it receives? If yes, what would be the structure of the acknowledgement payload? I wouldn’t want to live in a world where the answers to all of these questions would only be agreed verbally through some meeting. A piece of documentation should stand as the source of truth.Note that the scope of this documentation is limited to the interface between the client and the server, and does NOT cover the functionality of the server itself. Hence, we are not interested in server specific Socket.IO concepts such asroomsorbroadcasting events.What's nextStay tuned for the next (and most exciting) part of this series which adds AsyncAPI into the equation. In the meantime, you can check outAsynction, a python Socket.IO micro-framework driven by the AsyncAPI specification.Special thanks toderberqandquetzalliwritesfor reviewing this post!🙏Photo byMatt HowardonUnsplash
"""
--------------------------------------------------------------------------------


Post 74
ID: https://www.asyncapi.com/blog/hackathon-faq?utm_source=rss
Title: AsyncAPI Hackathon FAQ
Link: https://www.asyncapi.com/blog/hackathon-faq?utm_source=rss
Summary: Answers to all the questions you ever wanted to ask about the AsyncAPI Hackathon 2021
Content:
"""
Last year was the first time we hosted the AsyncAPI Conference. This year, we're going to host our first AsyncAPI Hackathon. This article tries to address the many questions coming from our community.😀When is the Hackathon?1st - 31st of October, 2021.We wanted you to have an entire month to complete your idea. This way, you don't have to stress and overwork yourself over the weekend. Instead, enjoy a relaxed month and remember it's about having fun!🤩What is the main theme for the Hackathon?The goal of the Hackathon is to provide MVP solutions that can help AsyncAPI Community in ways like:Ease education and getting started with the project.Bring new AsyncAPI-related solutions that can solve the existing challenges the community is facing with event-driven architectures.Extend existing tools, reuse them for some scenarios, and add the extra implementation on top.Do I need to register for the event?No, you do not need to register for the event.🙂Anybody can join the Hackathon, whenever they want! No pressure, in case you realize you can't deliver what you had originally planned.Is it a team competition or only for individuals?Both.You can work solo or form a team if you want! Just keep in mind that if you win with a team, the prize is divided amongst the entire team.I want to participate, but I don't have a good ideaNo worries, look at the ideas thatcommunity members are sharing in our public community discussion thread; you can pick one of them and/or get some inspiration.Can there be multiple submissions with the same idea?Yes.We do not set any limits here. The same idea can be done by multiple teams. Just keep in mind that if there are two excellent submissions for the same idea, I doubt judges will vote for both to let other ideas shine, although this is not an official rule.What is the scope of the submission? What does finishing my solution on time really mean?Your solution must be fully open-sourced and stored in a repository under your GitHub profile. Please do not use Bitbucket or GitLab as it will increase complexity for our community members that will review submissions.Your repository must havean open sourcelicense. If it helps, at AsyncAPI Initiative we always use Apache 2.0😉.It cannot integrate with a commercial solution that has no free tier.You must submit it before the deadline. Evaluation of the solution will not take into account any commits pushed to the repository after the deadline.How do I submit my task?Create a new discussion itemhere. Make sure there is:Overview of what the solution is about.Screenshots/Video/Diagrams/Code snippets (anyOf😉) that helps judges to quickly understand the solution and encourage them for further review.Link to the repository where the full solution can be found.If you win, you get to present your idea at our upcoming 2021AsyncAPI Conference in November.How will solutions be scored?A selected group that will represent the community will review all solutions. They will be obligated to only provide YES comments for ideas they liked the most and explain why. Each judge has 3 votes.Submissions and scores are public, and we reserve the right for judges to not make public NO comments, for the respect of all involved parties.The solution with the highest score wins!😀How do I get help? Who can help with further understanding of AsyncAPI and the entire tooling landscape?Join one ofContributor Firstmeetings. These will be streamed throughout the entire month of October, 2021. Add this calendar withGoogle Calendar formatoriCal format.  TheContributor Firstmeetings will take place every Wednesday, twice a day, at 8AM UTC and 4PM UTC.Join ourSlack. We are a very friendly and responsive community.Create an issue inone of the repositoriesand explain what help you need.What prizes are there?$5000 for the winner, $3000 for the runner-up, and $1000 for 3rd place.There will also be additional swag-packs for other participants.How do I get the winning prize money or swag?After the AsyncAPI Conference, you must submit an expense to Open Collectiveherewith an invoice that indicates the amount of money you have won.For swags, we will ask you directly to share your postal address with us that we will share with the agency responsible for swag-pack production.Who owns the intellectual property (IP)?AsyncAPI Initiative doesn't claim the IP of submitted solutions. Nevertheless, we welcome projects donations. Contact us if you want to continue working on your submission further after the Hackathon, and you want to do it under the GitHub organization owned by the AsyncAPI Initiative.Photo byEmily MorteronUnsplash
"""
--------------------------------------------------------------------------------


Post 75
ID: https://www.asyncapi.com/blog/openapi-vs-asyncapi-burning-questions?utm_source=rss
Title: AsyncAPI vs OpenAPI: Answers to Your Burning Questions About Two Leading API Specs
Link: https://www.asyncapi.com/blog/openapi-vs-asyncapi-burning-questions?utm_source=rss
Summary: AsyncAPI and OpenAPI are different ways of defining application programming interfaces (APIs), also commonly known as API specs. Both API specs serve a crucial role in defining and governing distribut
Content:
"""
AsyncAPI and OpenAPI are different ways of defining application programming interfaces (APIs), also commonly known as API specs. Both API specs serve a crucial role in defining and governing distributed computing systems, but AsyncAPI and OpenAPI are used for different styles of integration, as seen here:This postAsyncAPI vs OpenAPI: Answers to Your Burning Questions About the Two Most Popular API Specsappeared first onSolace.This post answers the following common questions about AsyncAPI vs OpenAPI and APIs in general…What are Application Programming Interfaces (APIs)?Application programming interfaces, or simply “APIs”, are a key part of modern programming that make it easier to exchange information between applications. APIs tell you what information an application expects to receive, and what information an application sends, without needing to know what the internal details of an application.As long as the API doesn’t change, different teams can invoke the application’s functionality without worrying about the messy details underneath. Because of this, separate teams can work independently on implementations.When did APIs start?APIs have been around for a while. For instance, the painful Simple Object Access Protocol (SOAP) used APIs in the early 2000s, but they really started getting interesting when representational state transfer (REST) came along. REST, which used the ubiquitous HTTP protocol, was lightweight and fun to work with.Did REST solve all the problems of SOAP by being lightweight, fun, and easy? Not quite, because it was a little too lightweight in some cases.What is Swagger and how does it relate to REST APIs?There was no great way to tell people in your company or a partner what needed to be in REST requests, and what they could expect as a reply. Whether the request needed a PUT or a POST was a constant source of confusion, and without a standard way of describing REST APIs, you had to resort to emailing.Something needed to happen. Swagger and WADL to the rescue! The goal of these competing standards was to standardize a way of documenting what a REST API looked like that was both readable by humans (somewhat, anyway) and could programmatically validate incoming requests and generate code.What happened to Swagger? And what is OpenAPI?The Swagger specification was renamed OpenAPI in 2016 when the Linux Foundation acquired it from the fine folks at SmartBear. Somewhat confusingly, Swagger lives on as a toolset for creating and manipulating OpenAPI specs.Implementing OpenTelemetry typically means instrumenting code so that it can emit monitoring information. This information is then aggregated in a backend system, either on-premises or through monitoring as a service provider.Are REST API and OpenAPI the same thing?They are related but different. OpenAPI describes and documents how a REST API operates in a standard way so that it can be shared widely.Why do Microservices Architecture and IoT benefit from  Asynchronous Communications?Microservices architecture is the new, cool kid on the street. Its purpose is to split up huge globs of code into tiny, manageable pieces, so different teams can work on them simultaneously.Typically, if a company wants to create something new, it glues different combinations of microservices together using REST calls. This method for microservices architecture worked… to an extent. People eventually realized that REST wasn’t always the best glue, and recognized the need for a new kind of glue that facilitated asynchronous communication.Establishing asynchronous communication between microservices makes them more reliable, faster, easier to scale, and more agile to adopt.Here’s a great video explaining why.The internet of things also changed things up. Mycoffee cupis connected to the Internet now. Which is fantastic. But internet connected gadgets like cars and stoves and refrigerators don’t always have solid internet connections. Again, asynchronous communication seemed like a better way to connect.With asynchronous communication, if a device is inaccessible, the information can be stored until it comes back online. Asynchronous communication can also help handle the surge of data than can come from connected devices. For example, think about all the coffee mugs firing up at 7am in the morning…Why do Microservices Architecture and IoT benefit from  Asynchronous Communications?You may be wondering why OpenAPI struggles with asynchronous APIs. Well, prior to version 3.1*, OpenAPI assumed two things:There is a single client connecting to a single server or application.The client requests something from the other server or application.*(OpenAPI 3.1 introduces some async capablities through the ability to define webhooks)As you can see here, that only covers about 25% of the ways that APIs can be implemented.Asynchronous communications do not satisfy those assumptions in numerous ways, but two stand out:Information is frequently shared with many consumers at the same time.In the case of one-way notifications, there may not be a request at all. With event-driven architecture, applications proactively send notifications about things that have occurred without being asked for that information.How does AsyncAPI describe asynchronous APIs?Without diving too deep, AsyncAPI adapts many of the core structures of OpenAPI to the asynchronous world. Rather than assuming that information flows in a request-reply style between a single client and server pair, messages are assigned to “channels” that many applications can send messages to, or receive messages from. If you want to learn more, check out theprimer on the AsyncAPI website.With the combination of OpenAPI and AsyncAPI, many more API possibilities are covered, as you can see in this diagram:Can an API gateway be asynchronous?There’s no reason it can’t be, which is one of the reasons many companies are focusing more on evented API products, along the lines of more traditional API products. Companies like Slack are already letting outsiders use evented APIs.If REST is all about HTTP, what protocols does AsyncAPI use?One of the cool things about AsyncAPI is that you can use a variety of different protocols that are defined by “bindings”. Right now, there are AsyncAPI bindings for over a dozen protocols including Apache Kafka, AMQP, IBM MQ, MQTT, SNS, WebSockets, and JMS.How can I create an Asynchronous API with AsyncAPI?If you want to see examples of how AsyncAPI can help you create an asynchronous API, there’s a great series withWebSockets examples, and you can check out thiscode generation example from Solace. If you’re looking for how to create an AsyncAPI API from scratch, the easiest way is with theAsyncAPI playground.What's next for API specs?AsyncAPI and OpenAPI are now both part of the Linux Foundation, which means:Both are well supported and have a stable futureBoth will be open standards with community governanceBoth should continue to be integrated with open-source tooling and commercial products
"""
--------------------------------------------------------------------------------


Post 76
ID: https://www.asyncapi.com/blog/events2021?utm_source=rss
Title: AsyncAPI Hackathon and Conference - Get Yourself Ready
Link: https://www.asyncapi.com/blog/events2021?utm_source=rss
Summary: It is official! October is an AsyncAPI Hacking Fest! and November 16-18 a 2nd online AsyncAPI Conference
Content:
"""
AsyncAPI Community organizes two important events in the second half of 2021:Hackathon in OctoberOnline conference on November 16-18We do not have the website ready yet.We do not have the call for proposals opened yet.Don't worry though, all logistics are in progress.What we do know so farWe do know these events will take place for sure!Hackathon will be month-long, and there will be a prize for winners. Its goal is to provideMVPsolutions that can help AsyncAPI Community in different ways:Ease education and getting started with the projectBring new AsyncAPI-related solutions to challenges the community has with event-driven architectures.Extend existing tools, reuse them in some scenarios, add the extra implementation on topConference will be 3 days long. The first day we will have a contributors summit where:Current maintainers can showcase projects that they maintain and explain how to contributeGoogle Summer of Code participants will be invited to showcase their projectsWe will explain in detail how to become a contributorDay 2 and 3 of the conference setup highly depends on the number of proposals, source (vendors, tooling providers, or end-users), and topics.What you can do alreadyJoin detaileddiscussionabout the event!Start talking to your employer.We need some cash from sponsorsto give it away to the community and spend some on event marketing.Start working on a proposal for a conference talk. The call for proposals is not yet officially opened, but you can already draft the initial proposal.Start brainstorming on your hackathon project as it's only one month left for the event:You want to be part of it? Feel free todiscuss your idea with othersif you are not sure it makes sense,You don't have time? That is fine, at leastdrop your ideas, maybe others will pick them upThat's all for now folks. Stay tuned!Photo bySamuel PereiraonUnsplash
"""
--------------------------------------------------------------------------------


Post 77
ID: https://www.asyncapi.com/blog/json-schema-beyond-validation?utm_source=rss
Title: Using JSON Schema Beyond Validation
Link: https://www.asyncapi.com/blog/json-schema-beyond-validation?utm_source=rss
Summary: What is JSON Schema, why is it important and why is it so hard to use beyond validation? 

For those unfamiliar with Asyncapi we use a superset of JSON Schema as the default format for defining operat
Content:
"""
What is JSON Schema, why is it important and why is it so hard to use beyond validation?For those unfamiliar with Asyncapiwe use a superset of JSON Schemaas the default format for defining operation payloads, headers, channel parameter schemas, etc.Even though formats such as Avro, OpenAPI 3.x and Swagger 2.x, RAML schemas, etc, are allowed in its place, as soon as it hits the parser (which most tooling utilizes), said formats are converted toJSON Schema draft 7to ensure acommon structure for tooling.However, in tooling, many times you do not want to validate data, but to represent the data in a structured manner so it is easier to interact with, such as classes that represent a message payload. How can you achieve this with validation rules?Quick intro to JSON SchemaLet's try and take a look at an example. Given the following, I have defined a schema representing the validation rules that the data should comply with.Displays the overall process of validating data using JSON Schema.The JSON Schema defines that the JSON data should be an object, which requires a property calledsomeRequiredPropertyto always be present and an optional property calledsomeOptionalProperty.someRequiredPropertyshould validate against an integer andsomeOptionalPropertyagainst an arbitrary string. The schema also dictates that no additional properties ("additionalProperties": false) may be allowed. There is also some metadata defined, called$idand$schema, but they are not important for this example.If we then take a look at the example data instances (below the JSON Schema in the figure), the first one contains the required property, and the second one has both the required and the optional property.The data and the JSON Schema can then together, validate whether the data is an instance of the schema, i.e., validate if the data comply with the validation rules and give a simple true or false statement if they are compatible.JSON Schema is an extremely powerful tool that allows you to create complex validation rules for data and is the standard specification used in not only AsyncAPI but also OpenAPI, however it has its challenges in tooling when used beyond validation.Challenges using JSON Schema for data definitionsMany of the JSON Schema keywords are forJSON instance validation, which means specifying validation rules that data should comply with. However, what if you wanted to know the definition of the data rather than what it should validate against?This is currently not something the JSON Schema specification provides to you, even though it is such an important part of tooling. First, let me show you how to interpret data definition from the above example for then to move into a more complex JSON Schema.Interpreting data definition from a JSON Schema is not always complex. For our previous example, I can almost interpret it as is. If I wanted a class in TypeScript that represented the data, it could look something like this (gonna use TS syntax as examples throughout). Notice how the$idkeyword is used to define the naming of the class.1classSomeIdForSchema{2publicsomeRequiredProperty: number;3publicsomeOptionalProperty?:string;4}In theory, I use the very same validation rules and interpret them, such that the output gives us the definition of what form the data may take. Sounds easy enough right?😅The problem is that JSON Schema –which might seem simple on the surface— is complex underneath when you start to interpret the recursive keywords such asnot,if,then,else,allOf,oneOf, etc. This causes the possibilities to be endless in terms of how the JSON Schema document can be structured (at least endless in principle).Ideally, all keyword possibilities MUST be supported with no restrictions. So let's take a look at a more complex example, that introduces thenotkeyword. We aren't interested in why one would define something like this, but merely the possibility of doing so.1{2"$schema":"http://json-schema.org/draft-07/schema#",3"type":"object",4"$id":"SomeIdForSchema",5"additionalProperties":false,6"properties": {7"someOptionalProperty": {8"type": ["string","number"]9}10},11"not": {12"properties": {13"someOptionalProperty": {14"type":"number"15}16}17}18}Take a moment and think about what data would you say is valid against this schema?In the very simplest form the JSON Schema could be converted to the following:1{2"$schema":"http://json-schema.org/draft-07/schema#",3"type":"object",4"$id":"SomeIdForSchema",5"additionalProperties":false,6"properties": {7"someOptionalProperty": {8"type":"string"9}10}11}Where the propertysomeOptionalPropertymay only be of typestring. But, let's try and break the complex schema down step by step, to show how the validation would work against the data:1{2"someOptionalProperty":"string"3}Notice how thenotkeyword reverses the validation result of step 5, which is why the inner schema is validated before the keyword itself.1{2"$schema":"http://json-schema.org/draft-07/schema#",3"type":"object",//Step 14"$id":"SomeIdForSchema",5"additionalProperties":false,//Step 26"properties": {7"someOptionalProperty": {//Step 38"type": ["string","number"]//Step 49}10},11"not": {//Step 612"properties": {13"someOptionalProperty": {14"type":"number"//Step 515}16}17}18}Step: accept, as the input is of type object.Step: accept, as no additional properties have been defined.Step: accept, as the property exists.Step: accept, as the property is of type string.Step: reject, as the property is of type string and not number.Step: accept (negate step 5), as the validation of the inner schema is negated.With thenotkeyword it means that it is not only a matter of interpreting what form the data may take but also which it may not. If we had to represent a class for this Schema it would be the following:1classSomeIdForSchema{2publicsomeOptionalProperty?:string;3}The interpretation of JSON SchemaSo, how can we create an algorithm that will enable us to consistently and accurately represent the underlying data model for the JSON data? How can this be standardized across all versions of JSON Schema (as we might not stay on Draft 7 forever)?Some of the alternatives to JSON Schema is specification such asTypeSchemaorJTD, that instead of focusing on validation, you focus on the definition of data models. Using these as the standard definition for payloads would indeed solve the problem in terms of data definitions in tooling. However, doing so neglect many important features of JSON Schema that simply cannot be done by defining the models, and we are left with the very same problem of transformingJSON Schema -> TypeSchemaorJSON Schema -> JTD, which to some extent is the process we are trying to figure out.In terms of the algorithm, it is highly work in progress😃ForModelinawe have our own process, but... It is something we are trying to solve collectively (as AsyncAPI is not the only one with this problem,OAI, IBM, etc) in the JSON Schema organization.Therefore I started adiscussionto trigger some initial thoughts on the subject and aJSON Schema SIGhas been formed to tackle this problem.This blog post is as much a call for help as it is to enlighten you about the problem of using JSON Schema beyond validation. If you want to help tackle this problem, test the process, review changes, or make some kick-ass documentation, just reach out, cause we want your help!Photo byHalGatewood.comonUnsplash
"""
--------------------------------------------------------------------------------


Post 78
ID: https://www.asyncapi.com/blog/mistake-odyssey?utm_source=rss
Title: Mistake Odyssey
Link: https://www.asyncapi.com/blog/mistake-odyssey?utm_source=rss
Summary: Experience with Git, GitHub, VS Code and Markdown for non-developers within AsyncAPI.
Content:
"""
The human being for many centuries delegated the responsibility of preserving a great part of their culture, of the most precious information, in the capacity of keeping in their memory the data, the names, the places, the details...In the Ancient Greece, Homer was the first to leave written traces of what until then were only remembered words, poems heard and recited from generation to generation. All this with the invaluable help of the muses. What a relief! He must have thought. What enormous risk and stress must have been in the atmosphere of those times. What would happen if amnesia came, the sudden loss of information. To forget is human. To err is human.The age of errorUndoubtedly, in our time, a recurring nightmare that we have all had is the one in which, after having done a work on our computer, just when we have to present it, a failure in the system makes everything written in the last minutes disappear... sometimes hours. Re-writing a previously written text is a hard exercise of memory, between frustration and despair. It will never be the same. Muses hardly come to the rescue. We are not Homer.Such suffering could be avoided in an ideal, utopian world where we would all keep backup copies of our documents every second. But the reality is that neither the obsession with saving versions in the cloud or on external disks is infallible. The danger of losing a moment of inspiration is part of all of us. Some say that we live in the age of error. Some of them made by us, others by the machines.For a writer or content creator, this nightmare can be especially hurtful, since the ability to write good texts and communicate information does not imply being an expert in computers or in the operation of the software that serves as a platform on which to shape texts.Getting out the comfort zoneWhen we are trained, we learn tools for our profession that we tend to hold on to tightly. Our first jobs are usually done with those initial tools and little by little we discover new ones that open up a world of infinite possibilities. Of course, it is not always easy to let go of the everyday to tackle new challenges with different methods. Homer first learned to recite by heart... at some point he would learn to write... and to read verses.Sometimes opportunities appear when you least expect them. Thus AsyncAPI appeared in my life and the opportunity to contribute to this project arose. Initially it was an exciting and challenging idea in a totally unknown sector for me, coming from the world of communication. I began to familiarize myself with the concepts and objectives covered by the project and little by little I started to get into it until I came across new tools and working methods that were new to me. Outside my comfort zone, an incomprehensible world was opening up before me. Are there maps for the desert? Who brought me here? Why learn something new if I have already internalized the mechanisms of my previous work?Learning from mistakesAsyncAPI is an open, free and collaborative project so the community needs to work with tools that allow working from transparency and horizontality creating an agile system. We are talking about Git, GitHub and VS Code, three free and open source software tools.When it comes to writing, the project relies on plain text, specifically the use of Markdown. It is considered a language that has the purpose of allowing the creation of content in a simple way of writing, and that at all times maintains a readable design. VS Code is the text editor in which we will work with Markdown. And then Git and GitHub conform the system that allows to store the information and easily retrieve it in case of loss, failure or error, as well as to consult the changes and revert them at any time.Evidently my immersion in these programs was for weeks an odyssey through the vast ocean of ignorance, or what is the same, an odyssey through the purest science of trial and error in which, apparently, there were only errors. Empirical learning is hard.Fortunately AsyncAPI has a community that works as a great team, in it I found people who help me to dispel my doubts and solve my mistakes. I take this opportunity to thank you from these lines, especially@anbreakerfor your patience😅.The end of a nightmareMultidisciplinarity is increasingly on the rise. It has been amply demonstrated that the convergence of different disciplines in the same project achieves a more successful and impactful result. This peculiarity makes us get closer and closer to disciplines that work with different tools than the ones we are used to.Beyond the mistrust or distrust derived from leaving our comfort zones, all this can be approached as an opportunity for learning. Ultimately, we discover new tools that make our work easier and more productive. A treasure hunt. An unexpected return to Ithaca. The odyssey comes to an end.The stress generated by the loss of information when writing is over for me. There is no concept of "unrecoverable text" in my new work environment thanks to the copies made by Git. There is a map where there are traces of everything that was done before. The nightmare has come to an end. We Homer wannabes can finally rest peacefully... waiting for the muses to arrive in our dreams.Photo byCarolinie CavallionUnsplash
"""
--------------------------------------------------------------------------------


Post 79
ID: https://www.asyncapi.com/blog/june-2021-at-asyncapi?utm_source=rss
Title: June 2021 at AsyncAPI
Link: https://www.asyncapi.com/blog/june-2021-at-asyncapi?utm_source=rss
Summary: 2.1.0 spec released, GSoC started, CLI released, other tools under heavy development. June was a hell of a ride.
Content:
"""
ReadMay 2021 at AsyncAPIfor the update from May.Specification 2.1.0 releaseThe eagle has landed. The new version of the AsyncAPI specification is here. For more details, readAsyncAPI Spec 2.1.0 Release Notes.For more details on security improvements introduced into the spec byDale Lane, readthis interactive article.For more details on new properties in examples, check out the demo of the latest version of Microcks whereLaurent Broudouxshows them in action in the new release:A significant side effect of the release is that we automated the process of publishing the specification. NowAsyncAPI Websitealways reflects the latest version of specification document fromthe spec repository. Thank youAayush Kumar Sahufor the hard work.The next release is scheduled for September. It is not decided if it is going to be a major or minor. It depends on the changes in the spec. Patch releases will be automatically released as 2.1.1 etc.Google Summer of Code (GSoC) kicked offBy courtesy ofPostmanthat agreed to list AsyncAPI-related ideas on their list ofGSoCideas, the AsyncAPI Initiative entered the event a big time.In June, we started at GSoC with five different project!DiffAayush Kumar Sahustarted working onthe AsyncAPI Diff library. It will show differences between two different AsyncAPI files as a list of breaking and non-breaking changes.Later it will be used in AsyncAPI CLI and Studio. It will be a standalone library, browser compatible, so the community can also integrate it in other use cases.OptimizerKhuda Dad Nomanistarted working onthe AsyncAPI Optimizer library. It is meant to optimize your AsyncAPI documents, such as finding duplications that can be changed into references or removing unused components. Very useful, especially for use cases where the AsyncAPI document is generated from code.Later it will be used in AsyncAPI CLI and Studio. It will be a standalone library, browser compatible, so the community can also integrate it in other use cases.App Relations DiscoveryArjun Gargstarted working onthe AsyncAPI App Relations Discovery library. It can discover relations between different applications in the system. As input, you provide a set of AsyncAPI documents provided for multiple applications.Except of default map of relations you will be able to also get a diagram of relations. Some ready examples based onthis flight system use case:Figure 1: Flow diagram using Mermaid syntax.Figure 2: Class diagram using PlantUML syntax.Simulator aka Fluffy RobotNektarios Fifesstarted working onthe AsyncAPI Simulator. It is a library that can simulate real traffic against your system basing on provided AsyncAPI documents and initial information of the traffic that should be generated. As a result, you will get a set of statistics.ChatBotAcestarted research on implementing aChatBotthat could help new AsyncAPI users to create first AsyncAPI documents. Throughout a conversation with a bot, you would get a generated AsyncAPI document in return.New CLI releasedThe initial version of theAsyncAPI CLIis finally here🚀.Jorge Aguiar Martínfinished his hard work on initial setup of the CLI with first initial feature for AsyncAPI documents validation:The next features are on their way. Feel free to join and work on it together with us.Modelina supports GoOur model generation library is under heavy development. I want to explicitly mention one change among all the recent changes inModelina.Sergio Moyaenabled support for model generation for Go💪It is a 4th language that is supported by the library.1const { GoGenerator} = require("@asyncapi/modelina")23const generator = new GoGenerator();45const doc = {6$id:"Address",7type:"object",8properties: {9street_name:    { type:"string"},10city:           { type:"string", description:"City description"},11house_number:   { type:"number"},12marriage:       { type:"boolean", description:"Status if marriage live in given house"},13pet_names:      { type:"array", items: { type:"string"} },14state:          { type:"string", enum: ["Texas","Alabama","California","other"] },15},16required: ["street_name","city","state","house_number","state"],17};1819async function generate() {20const models = await generator.generate(doc);21models.forEach(function (model) {22console.log(model.result);23});24}2526generate();2728//outputs2930/*31// Address represents a Address model.32type Address struct {33StreetName string34City string35HouseNumber float6436Marriage bool37PetNames []string38State *State39}40// State represents an enum of string.41type State string42*/You can also try out this code onRunKit.React component vs HTML template and where are weReact componentis still under development towards 1.0.0 release. Keep in mind that we are already using release candidates in theHTML template, and you can give it a try too:npminstall--save@asyncapi/react-component@v1.0.0-next.11In June, a couple of release candidates were released. Most important to notice is a new standalone bundle that makes it super easy to reuse React component inAngularandVueprojects. In addition, we now provide not onlycjsbut alsoesmandumdmodules. As a result, it is much easier to use React component withNext.jsprojects. In addition, the component supports the whole specification, exceptdiscriminator.Few more items left for the official 1.0.0 release:Custom theming that isright behind the cornerComponents extensibilityNew playground aka editor that will be available as a standalone package and used by use in a new AsyncAPI Studio (new AsyncAPI Playground)If you are interested in more details, follow therelease milestoneand the work done byMaciej Urbanczyk.JobsIf you missed it, we have aJobsboard on our website where different companies can share opportunities involving working with AsyncAPI. There are 4 open positions at the moment.We also generate anRSS feed, so you can subscribe for notifications on new jobs only.Good learning materialsJune was super rich in good learning content. Below you can find a list of all the articles and videos, but I'd like to explicitly point you to thiskids book about Kafka:Designing your APIs with AsyncAPI (Part 1)Simulating CloudEvents with AsyncAPI and MicrocksAsyncAPI and Its Horizontal Working SystemThe journey of documenting a Socket.IO API (Pt 1)Photo byRahul PanditonUnsplash
"""
--------------------------------------------------------------------------------


Post 80
ID: https://www.asyncapi.com/blog/release-notes-2.1.0?utm_source=rss
Title: AsyncAPI Spec 2.1.0 Release Notes
Link: https://www.asyncapi.com/blog/release-notes-2.1.0?utm_source=rss
Summary: The eagle has landed! Check out all the changes the AsyncAPI specification introduces in the new v2.1.0 release
Content:
"""
The last AsyncAPI release (2.0.0) took place on the 11th of September, 2019. In 2020 the focus went into growing community and adoption and stabilization of basic tooling for specification. This year was a year of "formalizm"😃aka getting into the foundation, setting up governance model and contribution guide to enable work on next spec release. We are good to go forward. The 2.1.0 release is out in the wild🎉Message examples object extended with additional fieldsThanks to work done byLaurent Broudoux, you can now clearly describe message examples. New propertiesnameandsummaryare optional. These properties help not only to properly describe the example in documentation but make it easier to work with mocking and testing tools (likemicrocks), so you can better identify what example to use for mocking and what it does.Example of new properties added to existingWebSocket example for Gemini API:1components:2messages:3marketData:4summary:Messagewithmarkeddatainformation.5description:|6The initial response message will show the existing state of the order book. Subsequent messages will show all executed trades, as well as all other changes to the order book from orders placed or canceled.7payload:8$ref:'#/components/schemas/market'9examples:10-name:updateMessage11summary:Exampleofanupdatemessagethatcontainsachangeinpriceinformation.12payload:13type:update14eventId:3690223336215timestamp:161976967316timestampms:161976967352717socket_sequence:66118events:19-type:change20side:bid21price:'54350.40'22remaining:'0.002'23delta:'0.002'24reason:place25-name:heartbeatMessage26summary:Exampleofadditionalheartbeatmessagewhenyouenablethem.27payload:28type:heartbeat29socket_sequence:1656Rendering of new example properties in React component and HTML template:For more details, check outthis pull request.New protocol bindingsThe specification is now extended to support the following custom protocols through the bindings feature:Mercure, thanks toKévin Dunglas. At the moment, no specific bindings are necessary for this protocol. For more details, check outthis pull requestandbinding definition.IBM MQ, thanks toDale LaneandRichard Coppen. For more details check outthis pull requestandbinding definition.Custom schema formats mandatory vs recommendedSupport for Avro and OpenAPI schemas changed from mandatory to recommended through contribution fromFran Mendez. For more details, check outthis pull requestNew security schemesThanks toDale Lane, you can now describe secured Kafka clusters with SASL security schemes (scramSha256,scramSha512,gssapi). For more details, check outthis pull request.Old new defaultContentType property in root objectWe used and supporteddefaultContentTypeproperty to specify the default content type when encoding/decoding a message's payload.Lucas Blockspotted that we do not have it defined in the specification. For more details, check outthis pull request.Tooling supportThe following official AsyncAPI tools are already updated to support 2.1.0 version of the specification:JSON Schema that supports validation of AsyncAPI documents is updated inthisrepository. Also@asyncapi/specspackage has been updated on NPM to version 2.8.0, and it contains the 2.1.0 JSON Schema.JavaScript Parseruses latest@asyncapi/specspackage and can be used to parse and validate 2.1.0 documents. Upgrade to 1.7.0 version.AsyncAPI Generatoruses the latest@asyncapi/parserpackage, so while generating output, it can validate 2.1.0 documents. Upgrade to 1.8.0 versionGenerator filtersfunctionsgetPayloadExamplesandgetHeadersExamplessupport new message example properties. Upgrade to 2.0.0 version.React componentsupports rendering of new message example properties. Upgrade to v1.0.0-next.10 version.Markdown templatesupports rendering of new message example properties. Upgrade to 0.14.0 version.HTML templateuses the latest@asyncapi/react-componentpackage. Upgrade to 0.23.0 version.JavaScript Converterenables conversion from any AsyncAPI version into the 2.1.0 version of the spec. Upgrade to 0.5.0 version.Modelinanow also accepts AsyncAPI documents valid against the 2.1.0 version of the spec. Upgrade to 0.16.0 version.Last but not least is the AsyncAPI Playground. Check new playground that uses latest HTML template and Markdown template withthis example.Big thanks toMaciej UrbanczykandJonas Lagonifor updating most relevant tooling.This is not all! Not only official AsyncAPI tools are updated. Thanks toLaurent BroudouxalsoMicrocksnow supports version 2.1.0 and its new example's properties. Upgrade to 1.3.0 version.Thank youI want to send a special thank you toAayush Kumar Sahu, who helped us to automate the part of the release responsible for updating the specification Markdown document on the AsyncAPI website, right after triggering the release, even the release candidate. Thank you🙇.Photo byDoug SwinsononUnsplash
"""
--------------------------------------------------------------------------------


Post 81
ID: https://www.asyncapi.com/blog/may-2021-at-asyncapi?utm_source=rss
Title: May 2021 at AsyncAPI
Link: https://www.asyncapi.com/blog/may-2021-at-asyncapi?utm_source=rss
Summary: We have JSON Schemas for bindings and some great community tools, one that was donated to AsyncAPI Initiative
Content:
"""
ReadApril 2021 at AsyncAPIfor the update from April.JSON Schemas for the bindingsAsyncAPI is protocol agnostic. It doesn't mean that you cannot specify some protocol-specific information in the AsyncAPI document. It is possible through abindingsfeature. In different parts of the AsyncAPI document, you can provide specific details for Kafka, MQTT, and other protocols. Definitions of bindings are maintained separately from the main AsyncAPI specification in thebindings repository.The current challenge with bindings is that they are hard to validate because they are written in Markdown, human-readable form only. Support in tooling is also pretty limited because of this. We had to start maintaining the JSON Schema, as we do with the main AsyncAPI specification.Thanks to a monumental effort fromKhuda Dad NomaniI'm proud to say that all 15 bindings now have their JSON Schemas. So for exampleKafka bindinghas itsJSON Schemas. The next step is to figure how to link these JSON Schemas with the main AsyncAPI specification JSON Schema and support it in parsers.For more details, have a look atthis issueand help us out to drive it further.Bindings are getting more and more adoption and interest. Many interesting discussions are happening that are shaping the bindings feature. I highly recommend joining them, like, for example, the debate started byIan Cooperto getconsistency between protocol configurations using bindings.InfoQ Architecture and Design 2021I don't think I need to write more than you can spot in this tweet😃. 2021 is very generous for AsyncAPI.Assigning channels to serversI want to suggest you pay attention to the proposal fromGerald Loefflerthat introduces a way toassign a channel to a specific server. This proposal would enable you to have a single AsyncAPI document with multiple different servers supporting different protocols. You could specify that your application is subscribed to channel A on the Kafka server and that it publishes messages to Channel B on the MQTT server.It is a feature that many asked for in the past. Please jump into the discussion. Even if you have no comments, then at least leave some emoji, so we know it was viewed and what people have an opinion.VSCode PluginIván García Sainz-Ajadonated to AsyncAPI Initiative the plugin he developed for the VSCode to enable you to preview AsyncAPI documents using our HTML template directly in the IDE. We need to do some cleanup and rebranding now, and then we will be ready with further development.Any help will be highly appreciated, so please check outthe repository.New AsyncAPI-related toolsWe have new tools onour listof tools created by the AsyncAPI Community:EventBridge AtlasfromDavid BoyneIt parses AWS EventBridge schemas into documentation solutions, shows rules matched to your events, adds metadata to each event property, support slate, AsyncAPI, and docuowl output, and more...AsynctionfromDimitrios DedoussisThe purpose of Asynction is to empower a specification first approach when developing SocketIO APIs in PythonTests coverage tracking in toolingTo increase the quality of our tools now and maintain it in the future, we started exploring tools for tracking test coverage. We integratedCoverallswith theModelinaproject.Jonas Lagonithat actively maintains the library gave Coveralls a score of 8 out of 10. Now we need to roll it out to other projects. If you were looking for some good first issue to start contributing to AsyncAPI, thenthis issueis a good one.Modelina is a data models generator that supports AsyncAPI and JSON Schema. Its goal is to make it easier to write code generators. Jonas released many improvements in May and still does, so it is best to try it out now and provide feedback.Slack reorganizationWe are growing fast, and it was the right time to do some reorg in our Slack workspace to get some structure, clean up, and properly structure discussions. In the end, yes, we are still using Slack because we got accepted as an exceptional organization and receivedStandardsubscription for free❤️.All the official Slack channels are listed below:I think that actually, the most important thing is that we defined our first version of theSlack etiquette.Photo byRahul PanditonUnsplash
"""
--------------------------------------------------------------------------------


Post 82
ID: https://www.asyncapi.com/blog/designing_your_apis_with_asyncapi_part_1?utm_source=rss
Title: Designing your APIs with AsyncAPI (Part 1)
Link: https://www.asyncapi.com/blog/designing_your_apis_with_asyncapi_part_1?utm_source=rss
Summary: How can you utilize code generation to speed up the development process and only focus on what is important - the business logic? In this miniseries, I will explore the ways AsyncAPI and code generati
Content:
"""
How can you utilize code generation to speed up the development process and only focus on what is important - the business logic? In this miniseries, I will explore the ways AsyncAPI and code generation can work hand in hand beyond generating documentation.Structure of the miniseries:Part 1: Designing your APIs with AsyncAPIPart 2: Implementing your applications using code generationPart 3: Black-box testing the applications using code generationPart 4: Introducing new changes when using code generationPart 5: The path to 1 billion players - Scaling the applications and finding bottlenecks with toolingDon't see this blog post series as anything other than an example workflow. This is purely how I do it with my applications and how I use AsyncAPI and its tooling to my advantage. Use this as an inspiration to finding an approach that works for you.BackstoryBack in 2019 when I started contributing to the tooling of AsyncAPI, I was still in university studying for a master's in software engineering and had at that point been a student developer at a company calledEURISCO, for about 3 years. Besides that, I have always had side projects that I worked on in my spare time, and it was one of these side projects that sparked my need for AsyncAPI.My side project at that time was aRustgame server plugin that collected in-game events, such as when a player farms resources, kills another player, loots a container, etc, and send them to a backend. Later these could be extracted by an API to display the player's progression and detailed account of what the player did on the game server.Initially, I used OpenAPI to describe the REST API, and the community tooling allowed me to generate clients and servers in different languages, which accelerated the implementation process.I soon encountered a use case that required me to push data to the game server, and solving this with REST was possible but cumbersome. So I started exploring different alternatives in terms of event-driven architecture. However, none could be described using OpenAPI removing tooling, so I had to find alternatives.That was when I vaguely remembered a meeting in the company where AsyncAPI was mentioned. Around that time, we began to switch from a custom socket protocol toNATSand spend some time figuring out how to mainstream the process for both documenting and generating code for the APIs. This was where we had found AsyncAPI and started adopting the specification.So I started to look into AsyncAPI for my project, which sparked my first ever contribution to an open-source project, but that is a story for another time, maybe.So this blog post is a dedication to that experience, showcasing how I use AsyncAPI to document and generate code to speed up the development process and maybe spark your interest in helping us build the best tooling possible.To that endExplaining something is always better with actual examples, therefore I will be creating a little system to show you how code generation can support the development process.The general setup of the project, with the two applications game server and processor. The round dot between "some broker" and the applications represent how others may grab/interact with the application, ergo its API.I will be creating a system of two applications, agame serverand aprocessorusing a micro-service architecture with no public-facing API. How a player interacts with thegame servercould be through a phone, a computer, Xbox, or PlayStation. I only care about the interaction between thegame serverand theprocessorin this blog post.Thegame serverwill produce the following events: when players join the server, pick up items in-game, uses the chat, hit one another, and eventually disconnect. It will be implemented to simulate players at random intervals joins the server, perform the different actions, and eventually disconnect to provide a sense of realism.The backendprocessorwill be consuming these events to process them. In this series, I will not do anything particular with the data. TheProcessorwill simply save the received events directly to a database.I will not get into the specifics of the stack for this system yet since it does not affect the writing of the API documents for the two applications.Designing the APIs with AsyncAPIWhen starting designing the application APIs I always use thedesign first principle, even when we are talking about internal systems.The game serverI always start with the basics and define all the different channels for which thegame servershould produce events over.1asyncapi:2.0.02info:3title:"Game server"4version:"0.0.1"5channels:6game/server/{serverId}/events/player/{playerId}/item/{itemId}/pickup:7description:Channelusedwhenaplayerpicksupanitemin-game8game/server/{serverId}/events/player/{playerId}/connect:9description:Channelusedwhenaplayerjoins(connectto)thegameserver10game/server/{serverId}/events/player/{playerId}/disconnect:11description:Channelusedwhenaplayerleaves(disconnectsfrom)thegameserver12game/server/{serverId}/events/player/{playerId}/chat:13description:Channelusedwhenaplayerwritessomethinginchat14game/server/{serverId}/events/player/{playerId}/hit:15description:Channelusedwhenaplayerhitanotherplayerin-gameAsyncAPI channels have a different meaning based on the underlying setup. For brokers such asApache Kafka, this is referred to astopics.However, regardless of the underlying setup, channels must be defined as aRFC 6570 URI template.The way I like to structure my channels is to utilize parameters to separate the action from information about the event, so it describes, on what server the event was performed{serverId}, by what player{playerId}and in case ofpickup, what item{itemId}gets picked up. For the last part of the channel, I describe what event it was,pickup,connect,disconnect, etc.Next I define the actual definition of the channels, and here I will focus on explaining the channelgame/server/{server_id}/events/player/{player_id}/item/{item_id}/pickup. The full AsyncAPI document can be foundhere.1...2game/server/{serverId}/events/player/{playerId}/item/{itemId}/pickup:3description:Channel used when a player picks up an item in-game4parameters:5serverId:6description:The id of the server the action was performed on7schema:8type:string9playerId:10description:The id of the player who performed the action11schema:12type:string13itemId:14description:The id of item picked up15schema:16type:string17subscribe:18message:19payload:20type:object21properties:22pickupTimestamp:23type:string24format:date-time25description:The timestamp the item was picked up26$id: PlayerItemPickupPayload27additionalProperties:false28...First, I have the definition ofparametersused in the channel.serverIdtells us where the action originates from, theplayerIdtells us who performed the action, and theitemIdtells us which item was picked up and should all validate against a value with typestring.Displays the game server API as it is described with AsyncAPI with version 2.0.0. The round dot between "some broker" and the game server represent how others may grab/consume the produced event from the game server.Next, we have thesubscribeoperation, which might not make much sense at first glance. I do want thegame serverto publish this event, right?And you would be correct, but this is how you currently define operations in AsyncAPI. You define the operation others may interact with. This means that thegame serverpublishes on this channel and others maysubscribeto it [1][3]. If you want a more detailed explanation, I suggest reading Nic Townsend's post aboutDemystifying the Semantics of Publish and Subscribe.Thepayloadof the channel (is described using a super-set of JSON Schema draft 7) should validate against anobjectwhich contains the propertypickupTimestamp, which should validate against astring. WhenadditionalPropertiesisfalse, no extra properties may be added to the object (by default this istruein JSON Schema draft 7). The$idkeyword is used as an identifier for that specific schema, in this case, I name the object schemaPlayerItemPickupPayload.The backend processorNext, I design theprocessorAPI, which contains all the same channels as thegame server, but with a different operation keyword.Displays the processor API as it is described with AsyncAPI with version 2.0.0. The round dot between "some broker" and the processor represent how others may grab/provide events that the processor subscribes to.This is again because I need to define how others may interact with ourprocessor. This means that instead of using thesubscribeoperation I usepublishto tell others that they can publish to this channel since the backendprocessoris subscribing to it. The full AsyncAPI document for theprocessorcan be foundhere.1...2game/server/{serverId}/events/player/{playerId}/item/{itemId}/pickup:3...4publish:5...6...Introducing reusabilityAt the moment, each of the AsyncAPI documents contains its definition of the channels. But what if I were to add a new validation rule such as a new property to theplayerItemPickupPayloadschema? In this case, I would have to change this for both applications, which is way too much work😄Therefore, we can introduce$refto separate the parameters and messages into smaller sections for reusability. I will be placing all separate components into a"components" directoryin the same directory the AsyncAPI documents reside.Just a quick note, at the moment, it is not possible to reuse channels and operations directly between the two applications. Therefore we can only apply this to the parameters and message individually while keeping some duplicate information [2].First, I separate the different parameters. For simplicity, I add all of them into the same file./components/Parameters.yaml.1serverId:2description:Theidoftheserver3schema:4type:string5playerId:6description:Theidoftheplayerwhoperformedtheaction7schema:8type:string9itemId:10description:Theidoftheitem11schema:12type:stringAnd then change all the channel parameters to reference the external parameter definition.1...2game/server/{serverId}/events/player/{playerId}/item/{itemId}/pickup:3description:Channelusedwhenaplayerpicksupanitemin-game4parameters:5serverId:6$ref:"./components/Parameters.yaml#/serverId"7playerId:8$ref:"./components/Parameters.yaml#/playerId"9itemId:10$ref:"./components/Parameters.yaml#/itemId"11...12...For the messages, I add a new file per message instead of keeping everything in the same file as parameters. I use this approach since I find it easier to maintain and extend.We add the message file./components/messages/PlayerItemPickup.yaml1payload:2type:object3properties:4pickupTimestamp:5type:string6format:date-time7description:Thetimestamptheitemwaspickedup8$id:PlayerItemPickupPayload9additionalProperties:falseand alter the channel definition for thegame serverto:1...2game/server/{serverId}/events/player/{playerId}/item/{itemId}/pickup:3description:Channelusedwhenaplayerpicksupanitemin-game4parameters:5serverId:6$ref:"./components/Parameters.yaml#/serverId"7playerId:8$ref:"./components/Parameters.yaml#/playerId"9itemId:10$ref:"./components/Parameters.yaml#/itemId"11subscribe:12message:13$ref:'./components/messages/PlayerItemPickup.yaml'14...These changes are applied to theprocessoras well. You can find all the AsyncAPI fileshere.What's nextNow, that the APIs are designed for two applications, we can move on to the fun part, implementing the applications using code generation.Related issuesIf you are interested in jumping into our discussions and being part of the community that drives the specification and tools, I have referenced some of the outstanding issues and discussions related to the different aspects I have referenced in the post.Add a View property to the info section to change the perspective of subscribe and publish operationsReusing channel definitions across files is hardConfusions with the Publish and Subscribe meaning/perspectiveCover photo byDavid JakabfromPexels
"""
--------------------------------------------------------------------------------


Post 83
ID: https://www.asyncapi.com/blog/async_standards_compare?utm_source=rss
Title: AsyncAPI, CloudEvents, OpenTelemetry: Which Event-Driven Specs Should Your DevOps Include?
Link: https://www.asyncapi.com/blog/async_standards_compare?utm_source=rss
Summary: A decade ago, event-driven architecture was the wild west. Documentation? It’s in a spreadsheet somewhere. Where did the event go? Here’s a list of ten logs to search through. How do we make sure even
Content:
"""
A decade ago, event-driven architecture was the wild west. Documentation? It’s in a spreadsheet somewhere. Where did the event go? Here’s a list of ten logs to search through. How do we make sure events from System A can be understood by System B? Slap some headers on the message and hope that they make it across the event broker.This postAsyncAPI, CloudEvents, OpenTelemetry: Which Event-Driven Specs Should Your DevOps Include?appeared first onSolace.Thankfully, the increased adoption of event-driven and distributed architectural patterns has meant increased attention to related open-source specifications. With solidifying specifications, standardized instrumentation and reusable tooling has emerged as well. Becoming event-driven today involves less guess work and more assurance of compatibility.But which specifications matter? And how should they be used?Within the event-driven ecosystem, there are three major emerging specifications: CloudEvents, OpenTelemetry and AsyncAPI. Each of them map to phases of the DevOps lifecycle, and address a distinct challenge with event-driven development and/or implementation. Used together, they can make event-driven DevOps easier to implement.Here’s a summary of where each of the specifications fits, I will examine each more in depth later:In addition to different portions of the DevOps lifecycle, the three specifications focus on different challenges and objects within the event-driven landscape:There is some overlap between the three, particularly as the specifications mature and expand. There are areas where two specifications cover the same ground in different ways, so it’s up to architects to determine how best to allocate functionality.Async APIParticularly in API-first methodologies, the DevOps “Plan” phase revolves around defining the application programming interface (API). The API describes what messages an application can accept and emit. The APIs can then be used to build the application, advertise its capabilities to others and document its functionality.However, defining an interface requires having a standard way of describing it that can be 1) used by many different programming languages, 2) leveraged by multiple tools and 3) read (at least sort of) by humans. In the synchronous world, OpenAPI does this work. For event-driven applications, AsyncAPI tries to do the same thing. It offers a parallel to the OpenAPI specification, but with modifications to allow for asynchronous, event-driven behavior. You can see the parallel for yourself in the structure of the specifications:In addition to the Plan phase, AsyncAPI also has emerging capabilities for other phases (shown in grey above):Code:Acode-generator for Spring Cloud Streamtakes an AsyncAPI definition and creates skeleton code, reducing the need to laboriously create boilerplate code. More code generators are planned. And vice-versa, there arecode-first toolsat that will generate an AsyncAPI spec out of numerous popular languages.Test:Thepartnership between AsyncAPI and Postmanhighlights the increased ability to test async flows once they are well defined.Deploy:Technology-specificbindingsdefined within the spec can be used to establish connections and subscriptions to event brokers upon deployment.Operate:Once messages are flowing at runtime, an AsyncAPI document can be used to ensure schema compliance with tools likeNode.js AsyncAPI ValidatorCloudEventsAs more technologies become event-driven, ensuring that they all communicate effectively becomes challenging.For example: An equipment failure occurs at a manufacturing plant, generating an event. The attached IoT device publishes a message containing the alert event to an MQTT server. At the end of the journey, the event lands in a Kafka topic, is pushed to a websocket, and is sent to a function as a service using an HTTP webhook.Contextual information about the event is crucial for all the consumers, but every consumer could expect it in a different place, with a different naming convention and a different format. Some producers might even choose not to include a key piece of metadata.To resolve these challenges, enterprises have traditionally created their own custom envelope: standards about what meta information is included in messages and in what format. But many applications don’t comply, either because they are outside the organization, it’s a legacy app that’s too pricey to retrofit, or because they use a protocol that hasn’t been included in the standard.The workaround is typically tedious and error-prone – manual mapping of metadata. This additional step can mean using data transformation software to enrich messages.  And in cases where information is missing, you either have messy data generation or make do without it.CloudEvents aims to eliminate the metadata challenge by specifying mandatory metadata information (like event source and type of event) into what could be called a standard envelope. The fields are then mapped to individual messaging protocols like Kafka, MQTT and HTTP, so there’s no question about where the fields exist on each message. Most importantly, there’s wide support for different programming languages.There is an overlap between CloudEvents and AsyncAPI, as noted by AsyncAPI’s founder. The metadata fields used by CloudEvents could be defined within an AsyncAPI schema. However, there is an advantage to using CloudEvents in addition to AsyncAPI. CloudEvent libraries are available for multiple programming languages for multiple protocols, which streamlines interoperability. For instance, a Java developer can utilize a CloudEvents SDK to publish CloudEvents compliant messages to Kafka, without having to worry about the underlying metadata implementation.And as an evolving standard being used by major SaaS and cloud providers, CloudEvents is gaining both momentum and functionality. In addition to the Operate phase, now that the core specification has been released, the group’s focus has turned to several extensions that address other stages and address other event-driven challenges:Plan:Discovery capability allows new and existing applications to query a catalog of services for available events using a standardized API.Deploy:Subscription manager capability allows applications to subscribe to events using a standardized API.OpenTelemetryIn contrast to AsyncAPI and CloudEvents, which address producing and consuming events themselves, OpenTelemetry focuses on end-to-end monitoring of those events. OpenTelemetry standardizes the creation and management of trace information, which can reveal the path of a single event through multiple applications, or show the aggregate metrics that combine multiple events.Implementing OpenTelemetry typically means instrumenting code so that it can emit monitoring information. This information is then aggregated in a backend system, either on-premises or through monitoring as a service provider.Once completed, OpenTelemetry helps to answer the classic event-driven question “Where’s my event?” By including business-related fields in the trace, it’s possible to search by, say, the order number of the original event, and have its entire path through multiple applications revealed.ConclusionIt’s a great time for event-driven architecture. Challenges that used to be overcome in different ways in every implementation are now being addressed by standard, open-source solutions. While OpenTelemetry, AsyncAPI and CloudEvents do have overlapping capabilities, they are distinct enough to all warrant a place in your DevOps processes.If you have more questions or want to share your experience with these standards, you can let us know in theAsyncAPI Slackor theSolace Community Forum.
"""
--------------------------------------------------------------------------------


Post 84
ID: https://www.asyncapi.com/blog/websocket-part3?utm_source=rss
Title: From API-First to Code Generation - A WebSocket Use Case
Link: https://www.asyncapi.com/blog/websocket-part3?utm_source=rss
Summary: Learn how to go from API design to code generation. Create a WebSocket API for ChatBot. All supported by AsyncAPI
Content:
"""
This is the last article of WebSocket series. I recommend you readWebSocket, Shrek, and AsyncAPI - An Opinionated IntroandCreating AsyncAPI for WebSocket API - Step by Stepfirst.In my previous articles from the WebSocket series, I introduced you to WebSocket topic and explained how you would describe your WebSocket API using AsyncAPI specification.What was the point of doing it anyway? Why learning the specification?Just to document your API? Nah, that would be a huge waste of time. Like seriously, would you learn a new specification only to describe the API for documentation purposes? Please don't. You could do so much more with it.Look at the list ofall the toolsbuilt for AsyncAPI. There are many ahead of us, but the current list already explains what can be done with AsyncAPI. You can validate your messages in real-time in your application withasyncapi-validatoror mock and test your application withMicrocks. You can also generate code by picking one ofthe official templates. In this article, I will focus on the aspect of code generation.API-First vs Code-FirstDesigning API first and then coding later is not an easy shift. For a coder, it is easier just to code and focus on code aspects. And this is just fine. That is how humans work. We do what we learned and focus on making things good and maintainable. Different tasks require different skills, and it is ok that not everybody has them. Designing API requires a different look on the subject, being more flexible and abstract. You need a wider perspective, forget about implementation details, and think about the user first.Do you need the specification to design API?No, but specification makes the design process and feedback loop easier to handle and faster. If backed by good tools, of course.What is wrong with generating AsyncAPI from code?Even though I'm an author of many memes like those in this article, I'm actually far from judging. It all depends on your project, architecture, and even the work environment.In the end, I think there is a wrong assumption that if you generate spec from code, it means you did not think about API design and your users.Even AsyncAPItooling liststigmatize tools that allow you to generate spec from the code as code-first tools. Who said you couldn't do both things in parallel.I just realized this topic could continue and evolve into a dedicated article, so let me do a full stop here.My goal is to educate you on:Designing a WebSocket API with multichannel, with one message each. In other words, I want to show you something opposite to my previous articles where you could see a WebSocket API that has one channel but with multiple different messages.Performing code generation that enables you to focus on business logic only.I'll try to come back intoAPI-First vs Code-Firsttopic in the summary of the article.ShrekAppI know that inthis article, I wrote that I would not try to model a Shrek application. Since the moment I wrote I will not do it, I immediately started thinking about doing it😃So here I am, showing you a possible use case for AsyncAPI with WebSocket protocol basing on Shrek. I shamefully admit I do it mainly to make sure my head moves on and thinks about something other than Shrek😃Write AsyncAPI documentYou can see entire AsyncAPI documenthereThere are several questions you need to ask yourself when designing an API:What is the name of the API?What is the purpose of the API?What is the version of the API?How user can connect with the API and over what protocol?What messages can your user receive from and send to your API?On what channels are these messages available?What is the structure of these messages? What is the schema?These are basic questions that can be reflected in the AsyncAPI document.In case you didn't notice, these questions are user-oriented. Your AsyncAPI document must describe what users can do with your application and not what it does. It makes a difference.InfoI'm designing aShrekApp, release under 1.0.0 version. Its purpose is to enable chat with a chatbot trained to behave like Shrek. I want to useWit.aias a platform for training the bot that gives me a REST API to talk to the bot.1info:2title: Shrek App3version:'1.0.0'4description: |5Purpose ofthisappisto have some fun with AsyncAPIandWebSocketanddefine aninterfacefor...Shrek.67![](https://media.giphy.com/media/10Ug6rDDuG3YoU/giphy-downsized.gif)89YoucanusethisAPItochatwithShrekbotortogetupdatesaboutartificaltravelstodifferentlocations.ServersThe communication with the application goes over the WebSocket protocol. For now, it is not publicly hosted. You can run it locally and therefore connect throughlocalhostonly.1servers:2swamp:3url:localhost4protocol:wsChannelsThere are two separate entry points for the user to interact with the API:chatwhere bi-directional communication is possible to enable real-time conversation with the bottravel/statuswhere user can subscribe for a stream of updates on different travels, like for example:1destination:Far far away2distance:Beyond the seven mountains and seven forests3arrival:Pretty soonExcept for basic information like the purpose of messages, pub/sub operations, and messages schema, it is good to specifyoperationIdthat is unique across the entire AsyncAPI document and helps to generate human-readable functions' names.In the below example, you can see a usage ofcomponentssection and schema definitions. I don't want to explain those sections in detail here as I did it already in theCreating AsyncAPI for WebSocket API - Step by Steparticle.1#2# Details about all the channels that user can listen to or send to messages3#4channels:5/chat:6subscribe:7summary:Client can receive chat messages.8operationId:subChatMessage9message:10$ref:'#/components/messages/chatMessage'11publish:12summary:Client can send chat messages.13operationId:pubChatMessage14message:15$ref:'#/components/messages/chatMessage'16/travel/status:17subscribe:18summary:Client can receive travel info status.19operationId:subTravelInfo20message:21$ref:'#/components/messages/travelInfo'2223#24# All reusable parts for readability and staying DRY25#26components:27messages:28chatMessage:29summary:Message that you send or receive from chat30payload:31type:string32travelInfo:33summary:Message that contains information about travel status.34examples:35- payload:36destination:Far far away37distance:Beyond the seven mountains and seven forests38arrival:Pretty soon39payload:40type:object41properties:42destination:43description:Name of travel destination.44type:string45distance:46description:How much distance left to the target.47type:string48arrival:49description:Time left to get there.50type:stringFinal documentYou can see the entire AsyncAPI document for ShrekApp always up to datehereThe AsyncAPI document I just created is not very complicated as this way it will be easier to understand the generated code. Most important is for you to notice that all information about your application is expressed in the AsyncAPI document, and once you do it, options for the next steps are just endless.Generate CodeIt is time now to generate some code that enables you to focus just on the business logic.AsyncAPI GeneratorThe AsyncAPI Initiative maintains theAsyncAPI Generator, a tool that enables you to generate anything you want out of an AsyncAPI document.Generatorprovides several features that make it much easier to provide so-calledtemplates. The template is a standalone project that defines what files should be rendered by the Generator as a final output.We have many templates on ourlist. Try out the project by following👇instructions:Select a Generator template:HTMLMarkdownNode.jsNode.js WebSocketsJava Spring Cloud StreamJava Spring BootPython PahonpmDocker1npm install -g @asyncapi/cli2asyncapigeneratefromTemplate https://bit.ly/asyncapi @asyncapi/html-template -o exampleGenerate Server and ClientThis article focuses on WebSocket therefore, I use ourNode.js WebSocket templatethat is capable of generating server for WebSocket API and also a client that is aware of available channels.Create a new directory where you will work on the project:mkdir shrekapp &&cdshrekappTrigger generation using the template:ag https://raw.githubusercontent.com/derberg/shrekapp-asyncapi-designed/main/asyncapi.yaml @asyncapi/nodejs-ws-template -o myapp -p server=swampAccess generated folder and list all files from the directory. Notice that Node.js application is generated:cdmyapp && lsInstall application dependenciesnpm iStart the applicationnpm startThat is it. The basics are done. The application is ready, and all the basic logic is there. You can already interact with the application onlocalhoston port80. Now you need a client able to communicate with WebSocket protocol. For now, we will not explore the generated client.Getwebsocat(curl-like tool for WebSocket) by followingthese instructionsConnect to one of the channels and notice that the server sent you a message to respond to established connection.1websocat ws://localhost/travel/status23Message from the server: Implement here your business logic that sends messages to a client after it connects.Logs in the running server should also indicate a new connection with the server:1Listening on port 802/travel/status client connected.Code WalkthroughBefore writing some code, let's first go through the generated code:For the generated server, we need to look intosrc/api/routes.jsandsrc/api/servicesFor generated client, everything is in theindex.htmlServer CodeRouterBasing on the information provided in the AsyncAPI document about available channels, in thesrc/api/routes.jsthe following routes are generated:1const { subChatMessage, pubChatMessage } = require('./services/chat');2const { subTravelInfo } = require('./services/travel-status');34router.ws('/chat', async (ws, req) => {5const path = pathParser(req.path);6console.log(`${yellow(path)} client connected.`);7await subChatMessage(ws);8ws.on('message', async (msg) => {9console.log(`${yellow(path)} message was received:`);10console.log(util.inspect(msg, { depth: null, colors: true }));11await pubChatMessage(ws, { message: msg, path, query: req.query });12});13});14router.ws('/travel/status', async (ws, req) => {15const path = pathParser(req.path);16console.log(`${yellow(path)} client connected.`);17await subTravelInfo(ws);18});In the case of this particular template, routes are handled byExpress frameworkandexpress-wsmiddleware.First let's have a look at/travel/statusroute:1router.ws('/travel/status', async (ws, req) => {2const path = pathParser(req.path);3console.log(`${yellow(path)} client connected.`);4await subTravelInfo(ws);5});Once the client establishes connection with the server, generated code invokes a function calledsubTravelInfo. Now look again at the AsyncAPI document:1/travel/status:2subscribe:3summary:Client can receive travel info status.4operationId:subTravelInfo5message:6$ref:'#/components/messages/travelInfo'The name of the function maps to theoperationId. The/travel/statuschannel supports onlysubscribeoperation which means that client can only connect to the channel to listen for the messages, no messages are accepted. This is why the generated router doesn't react to any message sent to the channel. As oposite to the/chatchannel:1router.ws('/chat', async (ws, req) => {2const path = pathParser(req.path);3console.log(`${yellow(path)} client connected.`);4await subChatMessage(ws);5ws.on('message', async (msg) => {6console.log(`${yellow(path)} message was received:`);7console.log(util.inspect(msg, { depth: null, colors: true }));8await pubChatMessage(ws, { message: msg, path, query: req.query });9});10});ThesubChatMessagefunction is invoked when client connects with the server. There is also a message listener generated that invokespubChatMessagefunction whenever a message is sent from the client. Now look again at the AsyncAPI document:1/chat:2subscribe:3summary:Client can receive chat messages.4operationId:subChatMessage5message:6$ref:'#/components/messages/chatMessage'7publish:8summary:Client can send chat messages.9operationId:pubChatMessage10message:11$ref:'#/components/messages/chatMessage'The client can not only listen to the messages incoming from/chatchannel but, in this case, can also send messages. This way, there can be bi-directional communication established between the client and the chatbot.ServicesFunctions like, for example,pubChatMessageare generated in theservicesdirectory. All functions for single channel go into individual file. Have a look atsrc/api/services/travel-status.jsfile:1constservice =module.exports = {};23/**4* Client can receive travel info status.5* @param {object} ws WebSocket connection.6*/7service.subTravelInfo =async(ws) => {8ws.send('Message from the server: Implement here your business logic that sends messages to a client after it connects.');9};As you can see, you are ready to provide your business logic by replacing the generated one:ws.send('Messagefromtheserver: Implement here your business logicthatsends messagestoa clientafteritconnects.');Client CodeThe Node.js WebSocket template that I use for this article also generatesindex.htmlfile to showcase that client generation is also possible using AsyncAPI document. As I mentioned in the beginning, with AsyncAPI and the AsyncAPI Generator, you can generate whatever you want.Theindex.htmlcontains a simple API that you can call from the browser's console to talk to the WebSocket API. Open the file in the browser and play with the API:Add Business LogicThe Business logic goes only to generated services.Add Travel Status UpdatesI don't have here any real travel status updates. I add some dummy data that are sent to the client every 1s, 100 times.Adddummy-jsonthat makes it easier to provide mock data. I add it only to make sure the code is not overcomplicatednpm i --save dummy-jsonImported the package in thesrc/api/services/travel-status.jsfile:constdummyjson= require('dummy-json');ModifysubTravelInfofrom the same file to send mock data to the client withws.send()function:1service.subTravelInfo = async (ws) => {2(functionmyLoop (i) {3setTimeout(() => {4ws.send(generateResponse());5if (--i) myLoop(i);6},1000);7}(100));89function generateResponse() {10const template = `{11"destination":"{{city}}",12"arrival":"{{int 2 6}}h",13"distance":"{{int 18 65}}km"14}`;15return dummyjson.parse(template);16}17};This is it. Now restart the server and check with previously installedwebsocatif after connecting totravel/statuschannel you are now regularly receiving a stream of messages:1websocat ws://localhost/travel/status23{"destination":"Woodville","arrival":"4h","distance":"60km"}4{"destination":"Denver","arrival":"3h","distance":"60km"}5{"destination":"Fargo","arrival":"3h","distance":"42km"}6{"destination":"Exeter","arrival":"2h","distance":"62km"}7{"destination":"Bradford","arrival":"2h","distance":"55km"}8{"destination":"Toronto","arrival":"6h","distance":"28km"}9{"destination":"Durham","arrival":"5h","distance":"59km"}10{"destination":"Canterbury","arrival":"4h","distance":"50km"}Add ChatBot CommunicationI chose Wit.ai as a platform that:Makes is super easy to train the botGives me access to API that enables integration with custom services, like the one that we just generatedI encourage you togive it a tryas it is pretty easy to use if it is your first time with ChatBots. It was my first time.To make it easier to talk to Wit.ai API I usenode-fetchpackage:npm i --save node-fetchImported the package in thesrc/api/services/chat.jsfile:constfetch= require('node-fetch');ModifysubChatMessagefrom the same file to send to the client message that connection is working:1service.subChatMessage= async (ws) => {2ws.send('Connection with Shrek established');3};ModifypubChatMessagethat is invoked when message from the client gets to the/chatchannel:1service.pubChatMessage= async (ws, { message, path, query }) => {2constmessageToShrek= message ? encodeURIComponent(message) :'';3constdefaultAnswer='Shrek is out sorry. He\'s busy rescuing the princess.';4letshrekAnswer= defaultAnswer;5let botAnswer;67try {8botAnswer= await fetch(`https://api.wit.ai/message?q=${messageToShrek}`, {9headers: { 'Authorization': `Bearer ${process.env.CHATBOT_TOKEN}` }10});11} catch (e) {12throw new Error(`Having issues communicating with the bot: ${e}`);13}1415if (botAnswer) {16constwrongQuestionAnswer='Is it you Donkey!? Ask a better question!';17constanswerObject= await botAnswer.json();18let firstTraitValue;1920for (const[, v]of Object.entries(answerObject.traits)) {21firstTraitValue= v[0].value;22break;23}2425shrekAnswer= firstTraitValue ? firstTraitValue : wrongQuestionAnswer;26}27console.log(`Answered with: ${shrekAnswer}`)28ws.send(shrekAnswer);29};The most important part of this code is when the communication with the Wit.ai platform happens to send a message and get a response:1botAnswer = await fetch(`https://api.wit.ai/message?q=${messageToShrek}`, {2headers: {'Authorization':`Bearer ${process.env.CHATBOT_TOKEN}` }3});This is it. Now restart the server and check with previously installedwebsocatif after connecting tochatchannel you can send messages to chatbot and receive answers. You need to start the server withCHATBOT_TOKENenvironment variable with the token:CHATBOT_TOKEN=your-token npm start. I cannot give you my token, sorry, you have to get yours fromWit.aiand train your chatbot:1websocat ws://localhost/chat23Connection with Shrek established45Me: Hi Shrek6Shrek: hey,doyou know ogrs have layers?7Me: Interesting8Shrek: are you mocking me?9Me: Why would I? I like you10Shrek: Is it you Donkey!? Ask a better question!11Me: No, not a donkey12Shrek: goodYou can also see logs on the server-side:1Listening on port 802/chat client connected.3/chat message was received:4'Hi Shrek\n'5Answered with: hey,doyou know ogrs have layers?6/chat message was received:7'Interesting\n'8Answered with: are you mocking me?9/chat message was received:10'Why would I? I like you\n'11Answered with: Is it you Donkey!? Ask a better question!12/chat message was received:13'No, not a donkey\n'14Answered with: goodSummaryIf you do not want to go through all the steps of getting the generated code, you can directly usethis project. It contains everything mentioned in this article.As you could see, the only coding part was just business implementation details, and the rest was generated. When I worked on this article, I focused first on the API. My main goal was to write the AsyncAPI document first, and the rest was easy.Are you convinced now that API-first is better than code-first?I'm an API-first person. I can go on and give you many arguments that support my view.I won't do it.Instead, I will honestly tell you what the problems are related to API-first and code generation. You judge what is the path you want to take.AsyncAPI 2.0 LimitationsAs I mention in this article and the previous ones on WebSocket, you write AsyncAPI document for your application from a client perspective. When you start designing your API, you ask yourself questions from the user's perspective.Don't get me wrong; I'm not saying that taking user perspective is wrong. It makes sense but also confusing for many. I recommend joiningthis threadfor more details.Confusion betweensubscribeandpublishis not the only problem. Once you understand that your application that publishes events must describe it as subscribe operation, the rest is trivial.The real problem is with code generation. You describe the application from a user perspective, so client code generation is easy. What about generating code for your server? Have a look again at the/travel/statuschannel from ShrekApp:1/travel/status:2subscribe:3summary:Client can receive travel info status.4operationId:subTravelInfo5message:6$ref:'#/components/messages/travelInfo'I had to try hard to make sure thesummaryandoperationIdare as neutral as possible. My first version looked like this:1/travel/status:2subscribe:3summary:You can listen to travel info status.4operationId:onTravelInfo#client code perspective, generated client reacts"onTravelInfo"incomming message5message:6$ref:'#/components/messages/travelInfo'Then insrc/api/services/travel-status.jsfile, I would haveonTravelInfoinstead ofsubTravelInfowith the following jsdoc:1/**2*Youcan listen to travelinfostatus.3* @param {object}wsWebSocket connection.4*/5service.onTravelInfo = async (ws) => {6...This is a function responsible for sending messages to the Client once it connects with a given channel. Function name likeonTravelInfois misleading, not to mention the generated code description.I chose neutral descriptions. They are acceptable, I think, but not when it comes to user-facing documentation. Every technical writer will tell you that the best docs are the ones that are directed to a reader. You don't write "what user can do with the API" but "what you can do with the API".Therefore, all descriptions and even things likeoperationIdshould have two versions to satisfy both docs and code depending on the perspective. Otherwise, you need to make a sacrifice. You either make the developer that maintains the code happy or the technical writer that maintains docs happy.Join the discussion aroundoperationId.Keeping AsyncAPI in Sync With CodeIn this article, I generated a server that was easy to extend, to showcase AsyncAPI capabilities. Using such projects is a way for building prototypes and quickly design architectures. You can even scaffold a server that later you can tune and use on production.You did your work, you did API-first.What happens later? I mean later during further development of the application.Let's say you add a new channel to the server or modify the name of the old channel.Where do you do it? AsyncAPI document or the code? You need to do it manually in both. You need to add a channel to the AsyncAPI document and add implementation for the channel in the code. You enter the land where your AsyncAPI document describes something different from your code at some point in time. You cannot regenerate the project with the template you used in the beginning, as your custom logic will be lost.The AsyncAPI Generator provides support for Git. If you have a Git repository and unstaged files, the Generator warns you that your changes may be lost. Git support is definitely helpful. You can try code regeneration, but you need to review changes and manually ignore overrides after that.It can be a cumbersome process, but you maintain sync between the AsyncAPI document and the code. There is no place for automation, though.There must be a way to solve these challenges. Maybe some kind of markers.  One could use them in code to indicate that the generator must ignore a given part of the code. Another helpful solution could be a way to specify what template files should be ignored during generation. For example, regenerate only models built from messages' schemas. We need to figure it out.Don't give up, though. Technical challenges are not a good excuse for avoiding the API-first approach.In my opinion, specification limitations and gaps in tooling support should not block you from choosing an API-first direction. The benefits are too big to resign that easily. Just join us and let us find solutions together. We want to help solve all those issues, but we just need some help from you too.That would be it. Thanks for staying with me until the end. Don't forget to read my previous articles on AsyncAPI spec and WebSocket protocol. Share your feedback and connect with the AsyncAPI community in ourSlack workspace.
"""
--------------------------------------------------------------------------------


Post 85
ID: https://www.asyncapi.com/blog/april-2021-at-asyncapi?utm_source=rss
Title: April 2021 at AsyncAPI
Link: https://www.asyncapi.com/blog/april-2021-at-asyncapi?utm_source=rss
Summary: AsyncAPI 2.1 release is scheduled. Is there anything else that could be more important.
Content:
"""
ReadMarch 2021 at AsyncAPIfor the update from March.AsyncAPI specification release cadenceI'm super happy to share that we removed the last roadblock for the next AsyncAPI release. Basing on some discussions during our public meetings and onthisissue, the release schedule for the spec looks like this:June 2021September 2021January 2022April 2022June 2022September 2022January 2023April 2023June 2023I hope you noticed a pattern. We do not want to do releases during the summer holidays and stay away from December😃.In June 2021, we will release 2.1.0 version of the specification. It is going to be the first release underopen governance model, under Linux Foundation and newcontribution guide. So many new things, a lot to organize around. It means we probably won't accept too many changes as logistics will consume a lot of time. We welcome any help. Join ourSlackfor more details.AsyncAPI use case at eBayIf you were looking for an AsyncAPI use case that shows some big tech using AsyncAPI in production, it is here. I highly recommend you read the articleAsyncAPI 2.0: Enabling the Event-Driven WorldfromShekhar Banerjeefrom eBay.React component and HTML template mergeAsyncAPI document can be rendered into documentation using two different tools maintained by the AsyncAPI Initiative:You can useReact component, also bundled as Web Component, to render the AsyncAPI document on the client-side.You can useHTML templatethat is a docs generator compatible with the AsyncAPI Generator for a server-side generation.These are two completely separate tools. People are contributing to both. There are some features supported in the first one but not in the other one, and vice-versa.It is such a waste of time for contributors. We never liked it.Maciej Urbanczyktook the effort to change it.Solution: Use React component as the core and HTML template to provide static output by rendering React during generation (you may know such approach from tools like Gatsby or Next.js).Sounds simple, but there was a lot of work to do:React component to use official AsyncAPI Parser (yes, we were a bit behind there)Provide features from HTML template to React component (who likes functionality regression, right?)Rework design of React component to match the HTML templateThe result:You need to try the new React component that is getting closer to the 1.0 release and jointhe discussion.npm install @asyncapi/react-component@nextHTML template already uses this React release candidate under0.21.1version.Don't stay behind. Maciek is now entirely focused on the component. Now is the best time to push for your features😃.Your favorite missing features like rendering of extensions and bindings are already there!Intend-driven API for AsyncAPI ParsersOver the last couple of weeksJonas LagoniandSergio Moyaworked on an idea to make the AsyncAPI JavaScript Parser, and in future other parsers, resilient to breaking changes in the AsyncAPI specification.Why?The current parser is bound to the structure of the AsyncAPI specification. The goal is to move away from such an approach into the API driven by the developer's intent.Learn more about the outcome of this tremendous effort from Sergio's article:Designing a unified Intent-driven API for all AsyncAPI's parsersWebSocketSince we were getting more and more questions about using WebSocket with AsyncAPI, it was about time to provide some learning materials. We had no dedicated documentation nor examples, so I decided to spend few weeks on that subject, and as a result, we got:Blog post onWebSocket, Shrek, and AsyncAPI - An Opinionated IntroBlog post onCreating AsyncAPI for WebSocket API - Step by StepAnd soon I'll release the last blog post onFrom API-First to Code Generation - A WebSocket Use CaseIn addition, you can have a look atofficial WebSocket example.There is also alive streamI did about this topic. I will also present atEDASummiton 19th of May and most probably atAPIOps Helsinkisomeday around mid-June. Stay tuned.JobsIs your company looking for an AsyncAPI expert? Now you can share your job description on the AsyncAPI website to share it directly with the AsyncAPI community. In April, we had 300 individual users looking at Jobs view even though we do not actively promote it. Once the list of jobs grows, we will promote it more to increase the traffic and job offers visibility.Head onhereand check out instructions on getting your job posting published.This option to add custom job offers, including jobs filtering, was contributed byAcebuild🙏.RSSWe finally have anrss feedfor our AsyncAPI blog. All thanks toMike Ralphson.If you do not like feed readers, just like me, then use some service likeBlogtrottrto get email notifications. I use it for a GitHub blog on the free plan, and I'm super happy.AsyncAPI workshop aka trainingMore and more people learn about AsyncAPI. We need to make sure there are good learning materials for anyone. More important, we need a solution that is easy to scale.Our new initiative is to work on training materials that can be used for in-class workshops with trainers, but on the other hand, they need to be available on a platform that offers self-learning training. All discussions happenhere, and you can also join the #training channel in ourSlack.We need people that want to become trainers, trainees or help to work preparing training materials. All hands aboard💪.Who knows, maybe once it grows to a proper size, we will start thinking about some official certification program?AsyncAPI and KafkaThis year there were many sessions about AsyncAPI atKafka Summit. You need to have a look. If you want to work around the registration process, watch the below recording fromDale Laneexplaining how to use AsyncAPI with Kafka:Dale has more content about AsyncAPI. For example, have a look at his work on the AsyncAPINode-REDplugin:Interest growthI'm losing track here. It is growing so fast that we should expose some real-time metric that shows some aggregated data.For example, on Twitter, we went up by 200 followers in April, up to 1900. Now, when I write this article, it is already over 2000.On Slack, we are already over 1200, and on LinkedIn, over 1100.🚀🚀🚀Photo byWaldemar BrandtonUnsplash
"""
--------------------------------------------------------------------------------


Post 86
ID: https://www.asyncapi.com/blog/intent-driven-api?utm_source=rss
Title: Designing a unified Intent-driven API for all AsyncAPI's parsers
Link: https://www.asyncapi.com/blog/intent-driven-api?utm_source=rss
Summary: Afraid because of breaking changes? Learn how do we plan to reduce breaking changes in our tooling APIs by introducing a new design approach called Intent-driven.
Content:
"""
TheFree and Open-Source Software(FOSS) model, since its inception, has brought a flurry of libraries and applications available to everyone.Thanks to the growth of the open-source community, we can now enjoy free software and, in most cases, generate profit from it.I believe there is no tech company that doesn't use open source in one way or another.FOSS has changed the way most developers operate: from coding all features from scratch to become consumers of libraries that implement most of the basic operation of an application. Sometimes even the core logic of the application is baked with free software.So much so that I, as a developer, can't imagine having to implement a complex application from scratch.If we go a step further, we won't talk only about libraries but also about APIs as services. For example, the fast adoption of theJamstackarchitecture, where the backend consists of different API services (primarily third-party), is pushing SaaS companies to make their private APIs public.In short, applications worldwide depend on free libraries maintained by the community, which constantly deliver updates at a frenetic rate: new functionalities, fixes, or in many other cases, drastic changes that allow us to continue growing and maintaining those libraries or APIs.The latter is, precisely, a problem for many developers. The feared👻breaking changes👻.Disclaimer: This post provides examples from the point of view of a software library API maintainer. However, the same principles apply to any other API, such as command-line tools, REST, Kernel modules, or peripheral drivers.What is a breaking change?A change in one part of a software system that potentially causes other components to fail; occurs most often in shared libraries of code used by multiple applications.Source:https://en.wiktionary.org/wiki/breaking_changeBreaking changes are non-backward compatible changes in the public interface of an application, either a library, an API service, or even a command-line utility.Users of such software are forced to alter their code if they want to use the latest version; otherwise, their code will be unusable.I propose a metaphor to better understand what abreaking changeis. By the way, based on something that happened to me a few days ago.
Imagine that your preferred supermarket, the one you have been going to for several years, decides to restructure its interior completely. Where you could find the fruit, now you only find water and other drinks. At this point, I have three options:You adapt yourself to the new layout and changes made to the surface. It will take a few days or maybe weeks to know where each product is, but in return, you can continue shopping at your favorite supermarket.Seek another supermarket that does not make drastic changes. In case they want to make changes, changes to be less and communicated in advance.Decide that you will devote all your efforts to grow your vegetables, raise your cattle, ride a water purification plant, and everything it takes to not rely on any supermarket or store.I went for the first option. Today I still get lost when I go shopping, but at least pasta is still on the same shelf as it was!In the software world, the first option would mean to update your code, so you avoid breaking changes.Therefore, the second option would be to look for another library or an API designed to avoid, as far as possible, these breaking changes. Building an API that meets this requirement is the primary purpose of this post.Finally, the third option would be to make zero use of FOSS.How can we mitigate the impact on users when releasing a newmajorversion of our library or service API?Designing APIs that are resilient to breaking changesAPIs solve user needs.However, I believe we do not listen to the final users that much. Instead, we tend to expose functionalities based on our own experience, biased by our position or the knowledge we own of the platform behind. Sometimes guided by preliminary research (Product-oriented) or lead with a not-so-clear goal in mind. At least I used to do it in that way.Not an easy journey, but I can promise you it is worth it.
AsMark Dalgleishonce tweeted:Be ready for what the user needsFocusing on what the user needs pulls away most of the overprint of any API: What is the userintentionwhen asking for a particular action to happen?An Intent represents a user intention of performing an action that solves a clear use case.Continuing with the metaphor presented in the previous paragraph, notice that my only intention was tobuy groceries for dinner. In particular, I needed some avocados, tomatoes and a baguette.The supermarket should provide a mechanism that lets me buy those items. How to get those, it's just the implementation detail and can be up to each supermarket to decide how to do it.For example, my supermarket had shelves where customers can pick up fruits from, offers bags, a balance to know the weight of those, and a checkout place. However, after the last changes, fruits are weighted at checkout, and baguettes are no longer on the shelf. So you need to ask the baker.As you can see, the interface didn't change: I still can buy the groceries. However, the implementation completely changed.Building APIs based on the implementation detail will nothing less than lead your users to suffer the (not-so-good) design choices made in the past. Furthermore, each change you make will penalize the user experience and force them to upgrade their code.Let's pick up another example, this time a more practical one.Here is a modified version of theStreetlights tutorialdocument made for demo purposes:1asyncapi:'2.0.0'2info:3title:StreetlightsmodAPI4version:'1.0.0-alpha'5servers:6mosquitto:7url:mqtt://test.mosquitto.org8protocol:mqtt9channels:10light/measured/changed:11subscribe:12summary:Receiveanupdateeverytimealightingconditionchanged.13operationId:onLightMeasureChanged14message:15$ref:"#/components/messages/lightMessage"16components:17messages:18lightMessage:19payload:20type:object21properties:22id:23type:integer24minimum:025description:Idofthestreetlight.26lumens:27type:integer28minimum:029description:Lightintensitymeasuredinlumens.By the time of this post, there is only one implementation of the parser, which is written in JavaScript.Parser-jsparses AsyncAPI spec documents and provides functions to work with them and access the different objects and their values.In the hypothetical case a user wants to parse this document andget all the messages a consumer of the application can consume, this is needed:doc.channels().filter(c=> c.hasSubscribe()).map(c=> c.subscribe().messages()).flat();We can observe that theParser-jsAPI (v1.x) is completely coupled with the structure of the AsyncAPI spec (by the date of this post,v2.0.0) document. The API is just a layer on top of the JSON Schema parsed document with some helpers and extras, meaning you should know the document's structure to access any information.Let's emulate a possible breaking change.Imaginemessagesare now independent of channels andOperationsget moved from where they used to be (under the channel) to the root of the document. For instance:1asyncapi:'99.99.99'2# ...3operations:4onLightMeasureChanged:5operationType:subscribe6summary:Receiveanupdateeverytimealightingconditionchanged.7message:8$ref:"#/messages/lightMessage"9channel:10$ref:"#/channels/light/measured"11channels:12light/measured:13description:Channelforupdatesonlightningconditions.14messages:15lightMessage:16# ...Now the users of theParser-jsthat wanted toget all the messages a consumer of the application can consumewill need to change their code so their app keeps working after thebreaking changegot introduced. For instance:doc.operations().filter(o=> o.isSubscribe()).map(o=> o.message()).flat();Intent-driven design to the rescueWhat if I tell you that you could avoid most of the breaking changes on your APIs by following an Intent-driven design approach?Let's give a twist to the API by adding some user intents. In this particular case, a method that represents the intent:clientSubscribableMessages(): Message[]Some naming clarification:client: user wants to get messages from the point of view of a client/consumer of the application.subscribable: user wants to get the messages they can consume.It looks simple, right? We have just written down our first intent!🎉From now on, users won't need to know in detail how the spec document is structured. The parser will reflect any change on the underlying document inside each function instead. Therefore,doc.clientPublishableMessages();willalwaysbe available as a method: it makes complete sense from a business model point of view for the AsyncAPI project.New versions of the library will be out, but those will mostly be minor or patch versions, adding new features, or fixing bugs. Meaning the users will follow a fearless and simple upgrade process.This approach also sets the foundations for creating backward compatibility APIs, among other features. For example, you can support several versions by executing one or another logic inside your intent functions.Designing a unified Intent-driven API for all AsyncAPI's parsersThe idea behind the Intent-driven design approach is to first focus on getting what the user intents are by getting feedback from final users as much as possible. Sometimes users are nothing else than other libraries, so go and check how they use your API.Our goal was to design an API that could be implemented in any language, meaning others could create their parser but always following this API. For example, theParser-go.Here is a summary of the steps we followed:1. Identify how users use the libraryWe first focused on identifying the intents behind ourgenerator templates. By doing some code analysis, we came out witha listofpotentialintents that became the foundation of our API.Furthermore, we tried to think about potential users of the parsers. For example,Slackdevelopers could use the parser for adding documentation to their UI, validating messages, among others.That gave us another list ofpotentialintents, most of them already covered by the list we got from the templates.2. Transform potential intents to actual intentsIt is an important step, if not the most. It is one of the hardest as well.For this step, we tried to abstract our minds and forget most of what we knew about the structure of an AsyncAPI document. We instead focused on the models and theirlogical(from a human point of view) relationship:Messages flow through ChannelsMessages can exist without channels.Messages can be (or not) related to OperationsEtcWe then wrote down a draft of our first list of intents.3. Build a mock APIAfter getting a list of intents to implement, we built a simple mock API in JavaScript with that list.Methods were returning hardcoded data but were enough for getting an idea of how difficult it would be to create such API from the point of view of a maintainer.At this point, we faced up some API design decisions, such as:Shall we add getters for all properties?Are we going to use singular or plural methods?Are methods going to have any argument at all?Etc4. Validate the intents and their UXWith the new API mock built-in JavaScript, we chose some of the most usedgenerator templatesand replaced all the calls made to the oldParser-jsAPI with the new ones.This step made us realize that some of the intents we mocked up worked like a charm: We were pretty happy seeing how the code got simplified.However, we found some inconsistencies, such as missing intents and helpers required for simplicity purposes.5. Wrap up documentationThis step included writing down all our documentation around the new API in a new repository, where developers of AsyncAPI parsers will refer and follow the specification of the API.Even though each parser will now maintain an individual release cycle, changes to this API will force the individual parsers to update.It followsSemver(as we do for all projects), so each parser will therefore maintain its compatibility matrix, making visible what version of the API specification they support.You can find the new repository holding the new Parsers API specificationhere, which at the moment of writing this post, it's stillv1.0.0-alpha, as we are waiting for more feedback from the community.What's next?Even though we do now have an alpha version of the new parser API, work is pending around implementation.
We are actively asking for feedback. Please submit yours via GitHub Discussionshere.Our next steps are going to be:To release a new version (alpha) of theParser-jsthat implements the new API specification.To use that newParser-jsversion in some of thegenerator templates. That will help us to:Validate that theParser-jsbehaves as expected.Set an example of what kind of changes users will need to do on their codes to adopt the new API (We expect code will require no significant changes).To ask for feedback from the community, especially to maintainers and users of theParser-js. Reviewing the new API now becomes easier as there will be the specification, a new version of theParser-jsand also examples to follow.Review feedback, apply suggestions, and do release a release-candidate or final version.Related issues and linksPlease find the outstanding issues related to the design process we went through here:Main issue for the API design processCollecting potential intentsEmulating few breaking changesFiguring out how to do API versioningThe new Parser(s) API specification can be foundhere. Discussions take placehere.ConclusionIntent-driven design helps to better understand your users by focusing on their intentions rather than technical details.It is not an easy path in the short term; however, the benefits can be visible early, making the process a grateful experience.I firmly believe making a great user experience should always be a top priority, especially for publicly available projects. If we don't care about users then, who is going to use our software?I want to take this opportunity to express my gratitude toJonas Lagoni, who has been my partner along this journey.
Hours of figuring out small details, long backs and forths, and discussions around user experience were easy-going, thanks to this one.I hope you enjoyed reading this post as much as I did writing it😃Cover photo byKarolina GrabowskaonKaboompics
"""
--------------------------------------------------------------------------------


Post 87
ID: https://www.asyncapi.com/blog/publish-subscribe-semantics?utm_source=rss
Title: Demystifying the Semantics of Publish and Subscribe
Link: https://www.asyncapi.com/blog/publish-subscribe-semantics?utm_source=rss
Summary: Learn how to interpret publish and subscribe operations when reading an AsyncAPI specification, and why they might not mean what you expect.
Content:
"""
This post originally appeared onIBM Integration CommunityAs adoption of AsyncAPI increases, a frequent topic of conversation in the community is how to describepublishandsubscribesemantics - both now and in future versions of the specification.In this blog post I aim to introduce the discussion and set you on the right path to document your event driven APIs.Or in other words, what code would you expect to be generated for the publish operation in the following AsyncAPI document?1asyncapi:2.0.02info:3title:MyApplication4version:1.05servers:6bootstrap:7url:mybroker.com:35148protocol:kafka9channels:10myChannel:11publish:12message:13payload:14type:stringIf you would be surprised to hear that this would result in a Kafka Consumer, then you should keep reading!In the beginningAsyncAPI started as an adaptation of OpenAPI - which describes synchronousrequest/responsebased APIs. In an OpenAPI world, you describe the application from the perspective of the client. Or in other words, the OpenAPI document describes how a client should interact with your application. The client and server communicate directly with each other.You document that a GET endpoint exists to access data, a POST endpoint exists to create data, etc. In all cases, a client speaks to the application (server) that is serving these endpoints.If you were implementing an application to honour the contract described in an OpenAPI document, you know to build route handlers that provide the documented endpoints for clients to access.Callbacks and webhooks are asynchronous operations, but in OpenAPI they are still described from the perspective of the client – the client has to initiate/register with the server before the server will push data to the client.What about AsyncAPI?In an event driven architecture there is no client/server paradigm. Applications do not directly communicate with one another - instead, each application sends and receives events via communication channels provided by s messaging infrastructure such as a broker. The broker ensures that events sent to a channel are delivered to interested applications. It can be consideredfire and forget- an application sends an event, but does not have any interest in whether other applications receive or make use of the event.AsyncAPI approaches this by describing an application as having two potential roles:If it sends messages to a channel, it's a “Publisher".If it is interested in receiving messages from a channel, it is a “Subscriber".An application can have either one or both roles.What does the following AsyncAPI document describe?1asyncapi:2.0.02info:3title:MyApplication4version:1.05servers:6bootstrap:7url:mybroker.com:35148protocol:kafka9channels:10myChannel:11publish:12message:13payload:14type:stringIsMy Applicationa Publisher or a Subscriber?Answer... it's a Subscriber!Like with OpenAPI, an AsyncAPI documents an application from theclientperspective. For a client to interact withMy Application, it must publish an event to the myChannel channel on the Kafka broker hosted at mybroker.com:3514The exception to the rule is websockets - there is a client/server paradigm rather than a messaging infrastructure - so other applications will connect directly to the server. However, the semantics remain the same - you describe the server as an application from theclientperspective.See Lukasz's previous article for more details.Where's the confusion?An AsyncAPI document can have multiple purposes. It can act as documentation for other developers to understand how to interact with the API. It can also act as documentation for developers to implement the API.In OpenAPI, there is no ambiguity - if you implement the API your server must listen for incoming requests on the documented endpoints, and any clients know to make requests to the documented endpoints. A GET endpoint means the same thing to both client and server.In AsyncAPI, the confusion has arisen because applications can both publish and subscribe - soverbs become interchangeable depending on the perspective of the person reading the document.When describing your architecture - a collection of applications communicating via channels - it can feel more familiar to describe what each application is doing (it publishes eventxto channelaand subscribes to events from channelb).Conversely, if you are intending on socialising your asynchronous API for use by other developers - it is a more familiar paradigm to describe how external developers can interact with the API. Ultimately, that was the decision for v2.0.0 of the AsyncAPI specification.What does this mean for using the spec?TheAsyncAPI generator projectis designed to facilitate generation of various assets from an AsyncAPI document - including sample or mock applications. The application generators are primarily written to interpret the API as detailed in this blog post - so apublishwill generate a Kafka consumer. However, some of the templates have added support for interpreting the document so that apublishgenerates a Kafka producer.Java Spring Cloud Stream templateuses the parameterview=provider- (providerinterprets the AsyncAPI document as describing the behaviours the applicationprovides)Java Spring templateuse the parameterinverseOperations=trueSummaryAsyncAPI documents describe applications. When reading an AsyncAPI document:publishmeanspublish an event to the channel and this application will receive itsubscribemeanssubscribe to this channel to receive events published by this applicationThere is aGitHub issueraised for discussing these semantics moving forward into the next version of the AsyncAPI specification - please do get involved with the discussion!
"""
--------------------------------------------------------------------------------


Post 88
ID: https://www.asyncapi.com/blog/websocket-part2?utm_source=rss
Title: Creating AsyncAPI for WebSocket API - Step by Step
Link: https://www.asyncapi.com/blog/websocket-part2?utm_source=rss
Summary: Learn how to create a complex AsyncAPI document using WebSocket API as an example.
Content:
"""
This step-by-step guide is a continuation of a series of articles about WebSockets. I recommend readingWebSocket, Shrek, and AsyncAPI - An Opinionated Introfirst.If you do not want to read this article, then watch the recording of the live stream about the same:All roads lead to Rome, but all those roads are different. First, you need to identify where you are and what is the purpose of your journey. What is your goal? What do you want to use AsyncAPI for?You may invest in using the specification for many different reasons, like for example:documentationtestingmockingcode generationmessage validationDepending on your goal, you might need to take different roads to get there. If your only goal is documentation, you might take a different approach to writing an AsyncAPI file than you would take while thinking about code generation.Choosing the right road to RomeLet's say AsyncAPI does not fully cover your use case. You are missing some extra property. You are disappointed that you cannot explicitly provide information that your production servers both support different channels. Server A supports channel AA and AB, while Server B supports channel BA and BB. It is not currently possible with the specification as the assumption is that your application communicates with servers that support the same channels.There are two roads to Rome:Roaddocs-only: You need AsyncAPI for docs generation only and have no intention of sharing the source document with anyone. It means you do not need to bother much about inventing some specification extension. You can just add missing information to the description of a given object.Roadautomation: You need AsyncAPI for docs and code generation, which means that all details in your AsyncAPI document must be machine-readable. You can't just put unsupported information in the description.Kraken API use caseI'm going to guide you through the process of creating an AsyncAPI document. I'll use the example of Kraken API mentioned in myprevious article.The challenge I had here was that I'm trying to document an API basing on public docs with no access to a subject matter expert. I also have zero understanding of the cryptocurrency industry and still do not fully understand the vocabulary.Message to Kraken API developers and technical writersIn case you want to continue the work I started on the AsyncAPI document for Kraken API, feel free to do that. I'm happy to help, just let me know. Reach me out in ourAsyncAPI Slack workspace.More interesting here are the technical challenges though, caused by the fact that Kraken's API:has two production servers for non-secure and secure message exchangesome messages are supported only by the public and some only by a private serverhas just one entry point for communication. You do not get specific messages from one of many endpoints. You get specific messages after first sending a subscription message. Meaning you have a request message and you get a reply message, so something that is not yet possible to describe with AsyncAPI in a machine-readable wayWriting a single AsyncAPI documentBecause of all these different challenges, I took thedocs-onlyroad described in sectionChoosing the right road to Rome. No worries though, I give tips for theautomationroad too.Basic information about the APIFirst, provide some basic information that every good AsyncAPI file should have:What AsyncAPI version do you use?What is the name of your API?What version of the API you describe?Do not underestimate the description. Optional != not needed. AsyncAPI supports markdown in descriptions. Provide long generic documentation for your API. Benefit from markdown features to structure it, so it is easier to readIn case you think using just one property to add overarching documentation for your API is very limiting, I agree with you😃Join discussionhere. I believe spec should have better support for docs, and we should first explore it with specification extensions. To be honest, I always thought documentation deserves its specification, but I don't want to bother you with my wicked visions now.1asyncapi:2.0.02info:3title:KrakenWebsocketsAPI4version:'1.8'5description:|6WebSockets API offers real-time market data updates. WebSockets is a bidirectional protocol offering fastest real-time data, helping you build real-time applications. The public message types presented below do not require authentication. Private-data messages can be subscribed on a separate authenticated endpoint.78### General Considerations910-TLSwithSNI(ServerNameIndication)isrequiredinordertoestablishaKrakenWebSocketsAPIconnection.SeeCloudflare's[WhatisSNI?](https://www.cloudflare.com/learning/ssl/what-is-sni/)guideformoredetails.11-AllmessagessentandreceivedviaWebSocketsareencodedinJSONformat.12-Alldecimalfields(includingtimestamps)arequotedtopreserveprecision.13-TimestampsshouldnotbeconsidereduniqueandnotbeconsideredasaliasesfortransactionIDs.Also,thegranularityoftimestampsisnotrepresentativeoftransactionrates.14-Atleastoneprivatemessageshouldbesubscribedtokeeptheauthenticatedclientconnectionopen.15-PleaseuseRESTAPIendpoint[AssetPairs](https://www.kraken.com/features/api#get-tradable-pairs)tofetchthelistofpairswhichcanbesubscribedviaWebSocketsAPI.Forexample,field'wsname'givesthesupportedpairsnamewhichcanbeusedtosubscribe.16-Cloudflareimposesaconnection/re-connectionratelimit(perIPaddress)ofapproximately150attemptsperrolling10minutes.Ifthisisexceeded,theIPisbannedfor10minutes.17-Recommendedreconnectionbehaviouristo(1)attemptreconnectioninstantlyuptoahandfuloftimesifthewebsocketisdroppedrandomlyduringnormaloperationbut(2)aftermaintenanceorextendeddowntime,attempttoreconnectnomorequicklythanonceevery5seconds.Thereisnoadvantagetoreconnectingmorerapidlyaftermaintenanceduringcancel_onlymode.Provide server informationDescribe how to connect to the API:What is the URL of the server?Is there any authorization in place?What is the protocol requirement, is SSL connection required?The Kraken API is an excellent example of how different WebSocket implementations can be and that there is never one way to design your architecture. It all depends on your requirements, the use cases that drive your product.Describing multiple serversBelow you can notice two different servers. These are not, as you might think, production and development servers. Here you have a clear division between publicly available data and private-only data. In other words, users use two different servers, not channels/paths/endpoints, to talk to the API.1servers:2public:3url:ws.kraken.com4protocol:wss5description:|6Public server available without authorization.7Once the socket is open you can subscribe to a public channel by sending a subscribe request message.8private:9url:ws-auth.kraken.com10protocol:wss11description:|12Private server that requires authorization.13Once the socket is open you can subscribe to private-data channels by sending an authenticated subscribe request message.You can verify if above is true by connecting tows.kraken.comand trying to subscribe to one of the event streams that require a token:{"event":"subscribe","subscription": {"name":"ownTrades","token":"WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu"} }In response you get an error:{"errorMessage":"Private data and trading are unavailable on this endpoint. Try ws-auth.kraken.com","event":"subscriptionStatus","status":"error","subscription":{"name":"ownTrades","token":"WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu"}}In the documentation, they also indicate beta servers likebeta-ws.kraken.com. It is hard to understand their purpose, so I did not put them in the AsyncAPI document. For me, beta means something new, some upgrades, and I would consider writing a separate AsyncAPI document.Is it reasonable to describe API that has two different production servers in one AsyncAPI? As usual, it depends. Fordocs-onlyroad described in sectionChoosing the right road to Rome, you can "workaround" some AsyncAPI features if they do not support your use case. Check out, for example, what I had to do in sectionServer securitywhere I was not sure how to describe the specific security of the private server. Short answer: just extend the description.Forautomationroad described inChoosing the right road to Romesection, you need a machine-readable structure. In case you have messages that can be consumed only by theprivateserver, you need a way to specify that the given message can be published only to theprivateserver. It is exactly the case with Kraken API.Imagine you want to read the AsyncAPI document in real-time in your server and validate all incoming messages. Take serverws.kraken.com. The only way to emit errors likePrivate data and trading are unavailable on this endpoint. Try ws-auth.kraken.comis by writing the code that handles validation manually. You can't generate that as the AsyncAPI file does not specify what messages can go tows.kraken.comand what messages can't.Why?At the moment, in AsyncAPI, you don't have a way to "wire" a server with a message, operation, or a channel. There are no default properties that allow you to provide information that message with the nameownTradescan only be sent tows-auth.kraken.comserver.Solution?Create two AsyncAPI documents. Treat those two servers as separate services that share messages and schemas. Use$reffeature tocross-reference schemas.Server securityYou can use AsyncAPI also to describe the security of your API. You can describe in a machine-readable way the security mechanism that protects the server. Severalsecurity schemesare supported. In Kraken's case, I could not figure out what kind of security scheme they use from their docs.  They seem to have a non-standard set up for getting the authorization token, which is why the only option was to put a human-readable-only description there.1servers:2public:3url:ws.kraken.com4protocol:wss5description:|6Public server available without authorization.7Once the socket is open, you can subscribe to a public channel by sending a subscribe request message.8private:9url:ws-auth.kraken.com10protocol:wss11description:|12Private server that requires authorization.13Once the socket is open, you can subscribe to private-data channels by sending an authenticated subscribe request message.1415TheAPIclientmustrequestanauthentication"token"viathefollowingRESTAPIendpoint"GetWebSocketsToken"toconnecttoWebSocketsPrivateendpoints.Formoredetails,readhttps://support.kraken.com/hc/en-us/articles/360034437672-How-to-retrieve-a-WebSocket-authentication-token-Example-code-in-Python-31617Theresultingtokenmustbeprovidedinthe"token"field of any new private WebSocket feed subscription:18```19{20"event":"subscribe",21"subscription":22{23"name":"ownTrades",24"token":"WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu"25}26}27```Endpoints aka ChannelsI saw WebSocket APIs that provide different streams of messages on separate endpoints. It is often the case when you build the WebSocket API for the frontend only and design it for different UI views. In the case of Kraken API we have no endpoints. You connect to the root of the server.No matter what setup you have, just remember you should usechannelsto describe it. In the case of connecting to the root, it is as simple as:1channels:2/:Multiple different messages on the same channelYou can have one or many different messages coming to your channel. Like in the case of Kraken API, you can even have multiple messages, incoming and outgoing. You can describe it usingoneOfonmessageobject as you can see below:1channels:2/:3publish:4operationId:sendMessage5message:6oneOf:7-$ref:'#/components/messages/ping'8-$ref:'#/components/messages/subscribe'9-$ref:'#/components/messages/unsubscribe'10subscribe:11operationId:processMessage12message:13oneOf:14-$ref:'#/components/messages/pong'15-$ref:'#/components/messages/heartbeat'16-$ref:'#/components/messages/systemStatus'17-$ref:'#/components/messages/subscriptionStatus'Hold on! Where did thesepublishandsubscribekeywords came from.When we talk about WebSocket, we usually do not use words like subscribe and publish, as we do not think about producers and consumers. Just check outthe protocol RfC. We are used tosendingandreceivingmessages.Let me present to you an unofficial AsyncAPI vocabulary translator for WebSocket users😃WebSocket termAsyncAPI termMeaning from API server perspectiveMeaning from API user perspectiveSendPublishThe API server receives the given message.The API user can send a given message to the API server.ReceiveSubscribeThe API server sends a given message.The API user can receive a given message from the API server.Messages definitionIn event-driven architectures (EDA) it's all about the event, right? The message passed in the system. You need to specify many details about the message, like its payload structure, headers, purpose, and many others.Above all, always remember to have good examples. Please don't count on the autogenerated ones, as in most cases, they're useless.1messages:2systemStatus:3description:Status sent on connection or system status changes.4payload:5$ref:'#/components/schemas/systemStatus'6examples:7- payload:8connectionID:86286153908486100009event:systemStatus10status:online11version:1.0.0Describe responses - specification extensionsDescribe responses? What responses?It is EDA. Who cares about responses, right? Fire and forget rules!The thing is that request and reply pattern is also used in EDA. This is also the case with Kraken API where communication goes through a single channel with multiple different messages. One message triggers another message in response.The simplest example is the messagepingthat triggers apongreply. The current AsyncAPI limitation is that you cannot specify that once the user sends (publish) messageping, thepongmessage is received in a reply. Look at thisthreadto participate in an ongoing discussion about request/reply pattern support in AsyncAPI.Fordocs-onlyroad from sectionChoosing the right road to Rome, I would be lazy and just put such info in the description of both messages. Even though this is an error-prone approach, I would just make my life easier. Forautomationroad I would choose to use a specification extension.What is specification extension?You can extend every AsyncAPI object in the AsyncAPI document with extra properties. You only need to prefix them withx-. You can also share extensions or reuse extensions from others thanks toextensions catalog.In the below document, you will notice that for the request/reply pattern, I use AsyncAPI specification extensions calledx-response.1messages:2ping:3summary: Pingservertodetermine whetherconnectionisalive4description: Client can pingservertodetermine whetherconnectionisalive,serverrespondswithpong. Thisisan applicationlevelpingasopposedtodefaultpinginwebsockets standard whichisserverinitiated5payload:6$ref:'#/components/schemas/ping'7x-response:8$ref:'#/components/messages/pong'Even though the reference to another object is provided inside the extension that is not part of AsyncAPI, our parser will resolve it correctly. It means that underx-responseproperty, I will have access to the entire message object.Schemas vs JSON SchemaBecause the message itself is most important in the entire EDA, you need to describe the message payload properly.AsyncAPI allows you to provide payload information in different schema formats. The default format is AsyncAPI Schema that is a superset of JSON Schema. You can use others too, like Avro, for example.From the AsyncAPI document point of view, the most important is that you can reuse schemas. In other words, instead of providing data directly to thepayloadobject, you can$refthem fromcomponents.schemasor even an external document. Just DRY, right?The rest, I would say, has nothing to do with AsyncAPI itself. How you structure schemas depends on you and the schema format that you use. It is why the next sections of my article describe something specific, not for the AsyncAPI itself but rather JSON Schema.Simplest example of schemas from Kraken API is a payload forpingmessage:1schemas:2ping:3type:object4properties:5event:6type:string7const:ping8reqid:9$ref:'#/components/schemas/reqid'10required:11- event12reqid:13type:integer14description:client originated ID reflected in response message.You can see thatpingmessage is an object that has two properties where only one is required. One property is used across other messages, so is part of many different schemas, so better to keep its definition as a separate schema and reference where needed.Schemas complexitySplitting schemas into reusable chunks with$refusage is not something complex. It gets complex when messages are complex, when you get different message payload depending on system behavior.Kraken API has asubscriptionStatusmessage where payload depends on the success of the subscription. In case of successful subscription, you get a message withchannelIDandchannelNameproperties, but in case of failure, the message doesn't contain these properties but in exchange haserrorMessage. In other words, some properties are mutually exclusive.1subscriptionStatus:2type:object3oneOf:4- required:5- errorMessage6not:7required:8- channelID9- channelName10- required:11- channelID12- channelName13not:14required:15- errorMessage16properties:17channelID:18type:integer19description:ChannelID on successful subscription, applicable to public messages only.20channelName:21type:string22description:Channel Name on successful subscription. For payloads'ohlc'and'book', respective interval or depth will be added as suffix.23errorMessage:24type:string25event:26type:string27const:subscriptionStatus28reqid:29$ref:'#/components/schemas/reqid'30pair:31$ref:'#/components/schemas/pair'32status:33$ref:'#/components/schemas/status'34subscription:35type:object36properties:37depth:38$ref:'#/components/schemas/depth'39interval:40$ref:'#/components/schemas/interval'41maxratecount:42$ref:'#/components/schemas/maxratecount'43name:44$ref:'#/components/schemas/name'45token:46$ref:'#/components/schemas/token'47required:48- name49required:50- eventIt is what I call a complex schema, where good JSON Schema knowledge is needed. The problem with complex schemas is that not many tools support these kinds of schemas. By the time I write this article, our AsyncAPI tools for documentation rendering will fail to render the above schema correctly.It is why you sometimes need compromises and adjusts schemas, so they get proper tooling support. Below you can see the same schema but structured in a more straightforward way supported by most tools.1subscriptionStatus:2type:object3oneOf:4- $ref:'#/components/schemas/subscriptionStatusError'5- $ref:'#/components/schemas/subscriptionStatusSuccess'6subscriptionStatusError:7allOf:8- properties:9errorMessage:10type: string11required:12- errorMessage13- $ref:'#/components/schemas/subscriptionStatusCommon'14subscriptionStatusSuccess:15allOf:16- properties:17channelID:18type:integer19description: ChannelIDonsuccessfulsubscription, applicabletopublicmessagesonly.20channelName:21type: string22description: ChannelNameonsuccessfulsubscription.Forpayloads'ohlc'and'book', respectiveintervalordepth will be addedassuffix.23required:24- channelID25- channelName26- $ref:'#/components/schemas/subscriptionStatusCommon'27subscriptionStatusCommon:28type:object29required:30- event31properties:32event:33type: string34const: subscriptionStatus35reqid:36$ref:'#/components/schemas/reqid'37pair:38$ref:'#/components/schemas/pair'39status:40$ref:'#/components/schemas/status'41subscription:42required:43-name44type:object45properties:46depth:47$ref:'#/components/schemas/depth'48interval:49$ref:'#/components/schemas/interval'50maxratecount:51$ref:'#/components/schemas/maxratecount'52name:53$ref:'#/components/schemas/name'54token:55$ref:'#/components/schemas/token'I managed to get a structure that will be nicely rendered in the UI. Even code generation will work well. It is a bit more complex than initial structure, although this is rather subjective personal-taste-like opinion.Let's have a look at the final documentWebsocket protocol is very flexible, and therefore you can implement the server in many different ways. The path that Kraken API took is complex but not impossible to describe with the AsyncAPI document. Look at the document's final structure and keep in mind that it is not a complete document for Kraken API and the road that I chose to get to Rome was to focus on documentation rendering only.Forautomationroad described in sectionChoosing the right road to Rome, the document should be split into two documents: one for private and one for public servers. Common parts, like common messages and schemas, should be stored in separate files and referred from these two AsyncAPI documents using$ref. Another solution would be to use specification extensions to describe relations between messages and servers.You can open this document directly in AsyncAPI Studio by clickingthislink. Compare it also with theoriginal documentation.1asyncapi:2.0.023info:4title:KrakenWebsocketsAPI5version:'1.8.0'6description:|7WebSockets API offers real-time market data updates. WebSockets is a bidirectional protocol offering fastest real-time data, helping you build real-time applications. The public message types presented below do not require authentication. Private-data messages can be subscribed on a separate authenticated endpoint.89### General Considerations1011-TLSwithSNI(ServerNameIndication)isrequiredinordertoestablishaKrakenWebSocketsAPIconnection.SeeCloudflare's[WhatisSNI?](https://www.cloudflare.com/learning/ssl/what-is-sni/)guideformoredetails.12-AllmessagessentandreceivedviaWebSocketsareencodedinJSONformat13-Alldecimalfields(includingtimestamps)arequotedtopreserveprecision.14-TimestampsshouldnotbeconsidereduniqueandnotbeconsideredasaliasesfortransactionIDs.Also,thegranularityoftimestampsisnotrepresentativeoftransactionrates.15-Atleastoneprivatemessageshouldbesubscribedtokeeptheauthenticatedclientconnectionopen.16-PleaseuseRESTAPIendpoint[AssetPairs](https://www.kraken.com/features/api#get-tradable-pairs)tofetchthelistofpairswhichcanbesubscribedviaWebSocketsAPI.Forexample,field'wsname'givesthesupportedpairsnamewhichcanbeusedtosubscribe.17-Cloudflareimposesaconnection/re-connectionratelimit(perIPaddress)ofapproximately150attemptsperrolling10minutes.Ifthisisexceeded,theIPisbannedfor10minutes.18-Recommendedreconnectionbehaviouristo(1)attemptreconnectioninstantlyuptoahandfuloftimesifthewebsocketisdroppedrandomlyduringnormaloperationbut(2)aftermaintenanceorextendeddowntime,attempttoreconnectnomorequicklythanonceevery5seconds.Thereisnoadvantagetoreconnectingmorerapidlyaftermaintenanceduringcancel_onlymode.1920servers:21public:22url:ws.kraken.com23protocol:wss24description:|25Public server available without authorization.26Once the socket is open you can subscribe to a public channel by sending a subscribe request message.27private:28url:ws-auth.kraken.com29protocol:wss30description:|31Private server that requires authorization.32Once the socket is open you can subscribe to private-data channels by sending an authenticated subscribe request message.3334TheAPIclientmustrequestanauthentication"token"viathefollowingRESTAPIendpoint"GetWebSocketsToken"toconnecttoWebSocketsPrivateendpoints.Formoredetailsreadhttps://support.kraken.com/hc/en-us/articles/360034437672-How-to-retrieve-a-WebSocket-authentication-token-Example-code-in-Python-33536Theresultingtokenmustbeprovidedinthe"token"field of any new private WebSocket feed subscription:37```38{39"event":"subscribe",40"subscription":41{42"name":"ownTrades",43"token":"WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu"44}45}46```4748channels:49/:50publish:51description:SendmessagestotheAPI52operationId:processReceivedMessage53message:54oneOf:55-$ref:'#/components/messages/ping'56-$ref:'#/components/messages/subscribe'57-$ref:'#/components/messages/unsubscribe'5859subscribe:60description:MessagesthatyoureceivefromtheAPI61operationId:sendMessage62message:63oneOf:64-$ref:'#/components/messages/pong'65-$ref:'#/components/messages/heartbeat'66-$ref:'#/components/messages/systemStatus'67-$ref:'#/components/messages/subscriptionStatus'6869components:70messages:71ping:72summary:Pingservertodeterminewhetherconnectionisalive73description:Clientcanpingservertodeterminewhetherconnectionisalive,serverrespondswithpong.Thisisanapplicationlevelpingasopposedtodefaultpinginwebsocketsstandardwhichisserverinitiated74payload:75$ref:'#/components/schemas/ping'76x-response:77$ref:'#/components/messages/pong'78heartbeat:79description:Serverheartbeatsentifnosubscriptiontrafficwithin1second(approximately)80payload:81$ref:'#/components/schemas/heartbeat'82pong:83summary:Pongisaresponsetopingmessage84description:Serverpongresponsetoapingtodeterminewhetherconnectionisalive.Thisisanapplicationlevelpongasopposedtodefaultponginwebsocketsstandardwhichissentbyclientinresponsetoaping85payload:86$ref:'#/components/schemas/pong'87systemStatus:88description:Statussentonconnectionorsystemstatuschanges.89payload:90$ref:'#/components/schemas/systemStatus'91examples:92-payload:93connectionID:862861539084861000094event:systemStatus95status:online96version:1.0.097subscribe:98description:Subscribetoatopiconasingleormultiplecurrencypairs.99payload:100$ref:'#/components/schemas/subscribe'101examples:102-payload:103event:subscribe104pair:105-XBT/USD106-XBT/EUR107subscription:108name:ticker109-payload:110event:subscribe111subscription:112name:ownTrades113token:WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu114x-response:115$ref:'#/components/messages/subscriptionStatus'116unsubscribe:117description:Unsubscribe,canspecifyachannelIDormultiplecurrencypairs.118payload:119$ref:'#/components/schemas/subscribe'120examples:121-payload:122event:unsubscribe123pair:124-XBT/EUR125-XBT/USD126subscription:127name:ticker128-payload:129event:unsubscribe130subscription:131name:ownTrades132token:WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu133x-response:134$ref:'#/components/messages/subscriptionStatus'135subscriptionStatus:136description:Subscriptionstatusresponsetosubscribe,unsubscribeorexchangeinitiatedunsubscribe.137payload:138$ref:'#/components/schemas/subscriptionStatus'139examples:140-payload:141channelID:10001142channelName:ohlc-5143event:subscriptionStatus144pair:XBT/EUR145reqid:42146status:unsubscribed147subscription:148interval:5149name:ohlc150-payload:151errorMessage:Subscriptiondepthnotsupported152event:subscriptionStatus153pair:XBT/USD154status:error155subscription:156depth:42157name:book158159schemas:160ping:161type:object162properties:163event:164type:string165const:ping166reqid:167$ref:'#/components/schemas/reqid'168required:169-event170heartbeat:171type:object172properties:173event:174type:string175const:heartbeat176pong:177type:object178properties:179event:180type:string181const:pong182reqid:183$ref:'#/components/schemas/reqid'184systemStatus:185type:object186properties:187event:188type:string189const:systemStatus190connectionID:191type:integer192description:TheIDoftheconnection193status:194$ref:'#/components/schemas/status'195version:196type:string197status:198type:string199enum:200-online201-maintenance202-cancel_only203-limit_only204-post_only205subscribe:206type:object207properties:208event:209type:string210const:subscribe211reqid:212$ref:'#/components/schemas/reqid'213pair:214$ref:'#/components/schemas/pair'215subscription:216type:object217properties:218depth:219$ref:'#/components/schemas/depth'220interval:221$ref:'#/components/schemas/interval'222name:223$ref:'#/components/schemas/name'224ratecounter:225$ref:'#/components/schemas/ratecounter'226snapshot:227$ref:'#/components/schemas/snapshot'228token:229$ref:'#/components/schemas/token'230required:231-name232required:233-event234unsubscribe:235type:object236properties:237event:238type:string239const:unsubscribe240reqid:241$ref:'#/components/schemas/reqid'242pair:243$ref:'#/components/schemas/pair'244subscription:245type:object246properties:247depth:248$ref:'#/components/schemas/depth'249interval:250$ref:'#/components/schemas/interval'251name:252$ref:'#/components/schemas/name'253token:254$ref:'#/components/schemas/token'255required:256-name257required:258-event259subscriptionStatus:260type:object261oneOf:262-$ref:'#/components/schemas/subscriptionStatusError'263-$ref:'#/components/schemas/subscriptionStatusSuccess'264subscriptionStatusError:265allOf:266-properties:267errorMessage:268type:string269required:270-errorMessage271-$ref:'#/components/schemas/subscriptionStatusCommon'272subscriptionStatusSuccess:273allOf:274-properties:275channelID:276type:integer277description:ChannelIDonsuccessfulsubscription,applicabletopublicmessagesonly.278channelName:279type:string280description:ChannelNameonsuccessfulsubscription.Forpayloads'ohlc'and'book',respectiveintervalordepthwillbeaddedassuffix.281required:282-channelID283-channelName284-$ref:'#/components/schemas/subscriptionStatusCommon'285subscriptionStatusCommon:286type:object287required:288-event289properties:290event:291type:string292const:subscriptionStatus293reqid:294$ref:'#/components/schemas/reqid'295pair:296$ref:'#/components/schemas/pair'297status:298$ref:'#/components/schemas/status'299subscription:300required:301-name302type:object303properties:304depth:305$ref:'#/components/schemas/depth'306interval:307$ref:'#/components/schemas/interval'308maxratecount:309$ref:'#/components/schemas/maxratecount'310name:311$ref:'#/components/schemas/name'312token:313$ref:'#/components/schemas/token'314interval:315type:integer316description:Timeintervalassociatedwithohlcsubscriptioninminutes.317default:1318enum:319-1320-5321-15322-30323-60324-240325-1440326-10080327-21600328name:329type:string330description:Thenameofthechannelyousubscribetoo.331enum:332-book333-ohlc334-openOrders335-ownTrades336-spread337-ticker338-trade339token:340type:string341description:base64-encodedauthenticationtokenforprivate-dataendpoints.342depth:343type:integer344default:10345enum:346-10347-25348-100349-500350-1000351description:Depthassociatedwithbooksubscriptioninnumberoflevelseachside.352maxratecount:353type:integer354description:Maxrate-limitbudget.ComparetotheratecounterfieldintheopenOrdersupdatestocheckwhetheryouareapproachingtheratelimit.355ratecounter:356type:boolean357default:false358description:Whethertosendrate-limitcounterinupdates(supportedonlyforopenOrderssubscriptions)359snapshot:360type:boolean361default:true362description:Whethertosendhistoricalfeeddatasnapshotuponsubscription(supportedonlyforownTradessubscriptions)363reqid:364type:integer365description:clientoriginatedIDreflectedinresponsemessage.366pair:367type:array368description:Arrayofcurrencypairs.369items:370type:string371description:Formatofeachpairis"A/B",whereAandBareISO4217-A3forstandardizedassetsandpopularuniquesymbolifnotstandardized.372pattern:'[A-Z\s]+\/[A-Z\s]+'Stay tuned for more articles around WebSocket and AsyncAPI. Share your feedback and connect with the AsyncAPI community in ourSlack workspace.
"""
--------------------------------------------------------------------------------


Post 89
ID: https://www.asyncapi.com/blog/websocket-part1?utm_source=rss
Title: WebSocket, Shrek, and AsyncAPI - An Opinionated Intro
Link: https://www.asyncapi.com/blog/websocket-part1?utm_source=rss
Summary: WebSocket is a protocol, an industry standard for building client applications that users love to use. What does AsyncAPI have to do with it?
Content:
"""
This is a pretty subjective post. I'm sharing my perspective, taking into account years of experience building backend and frontend with user experience in mind.If you do not want to read this article, then watch the recording of the live stream about the same:Everything we hear is an opinion, not a fact. Everything we see is a perspective, not the truth.
―Marcus AureliusThis blog post is the first of a series of blog posts about WebSocket I'm working on.What is WebSocketIt is a pretty old protocol used for duplex communication over TCP connection. It was standardized in 2011. Yes, ten years ago means it is old, super old.So why do I even mention it in 2021?It is very widely adopted and will not go away anytime soon because tooling support is excellent and serves its purpose well. Just remind yourself when HTTP/2 showed up and how many years it took everyone to migrate. It would not happen without the strong support and push from all the big players.Sure, there isHTTP/2 multiplexingand protocols likeMercureorGraphQL Subscription. There is alsoRFC8441for WebSocket and HTTP/2 and some tools already adopted it, likeEnvoyorJetty. Nevertheless, WebSocket is here to stay.Anyway, the future of WebSocket has nothing to do with this post. This post is for the AsyncAPI community looking into the AsyncAPI spec because of WebSockets now, no matter the protocol's future.Websocket use caseDo you like to see in Slack that someone is typing a response?Do you like it when a user interface updates without page refresh?Do you like it when your client app knows there are updates available for display?That is what WebSocket is for. You establish a long-living connection between client and server. Through such a connection, the client can send a stream of messages to the server, and this is possible the other way around at the same time.One could say:I don't need WebSocket to achieve that. I could just set up a data polling with REST API. Just ask the API every few seconds if there are updates.Sadly this is not a joke. Engineers do it. Some engineers just take shortcuts, mostly because deadlines hunt them down.HTTP polling was presented very well in Shrek's famousAre we there yet?scene.Don't go that path. Do not perform unnecessary connections to your servers and create more and more traffic with more and more resource consumption. Wasting resources is bad and makes Shrek angry. WebSocket changes a lot there:Figure 1: HTTP Pull vs WebSocket vs Shrek.Why AsyncAPIWhen building a WebSocket API on a server, you might have some additional needs:Want to document the API for the team that writes a client app, Web UI, Desktop app, or Mobile app.Want to have a way to specify the format of the messages that the server supports to validate them in the runtime.Want to generate a server or/and a client? If not for final production use, then for sure for prototyping and testing.These are just a few common needs. For WebSocket, you only establish a connection over HTTP protocol, and the rest goes over WS, so OpenAPI specification won't help you much here. WebSocket is one of the patterns in event-based systems. In the end, it is all about a stream of messages and asynchronous processing. Yes, it would be best to use AsyncAPI😃WebSocket described with AsyncAPIWhen I google for some public WebSocket API to play with, I find mostly currency trading products:Kraken WebSocket APIGemini WebSocket APICEXIO Websocket APICurrency trading is a topic I know nothing about🤷‍♂but it feels interesting to explore more. Documentation of the 1st and 2nd API looks familiar from look&feel perspective. I think we can make a bet they are already using AsyncAPI, and Kraken most probably is still running on version 1. Let's release the Kraken then.I'm sorry if you expected me to describe Shrek's API interface using AsyncAPI. It would be fun, but only fun, and I'd also like to teach you something.I will write an AsyncAPI document for Kraken API after playing with the API and basing it on thecurrent documentation.Playing with WebSocket APIThe best way to play with a WebSocket API is through a CLI. Who didn't hear aboutcurlin the REST API world? For WebSocket, I would recommendwebsocat. Kraken's API is partially public without authorization which is just great because to play with it, you do not have to set up an account to get an authorization token.Installwebsocat. For other installation options, check outthislist.brewinstallwebsocatEstablish connection with the API:websocatwss://ws.kraken.comPing the API to see if it responds. Just type the below message and hit Enter:{"event":"ping"}Now subscribe to the eventtickerstream that sends messages with currency price. Just type the below message and hit Enter:{"event":"subscribe","pair": ["XBT/USD","XBT/EUR"],"subscription": {"name":"ticker"}}You should now see a constant stream of data sent by the server. You do not have to ask the API every second for an update, as the update is pushed to you.1{"event":"heartbeat"}2[340,{"a":["45520.10000",6,"6.78103490"],"b":["45520.00000",0,"0.00185230"],"c":["45520.10000","0.01643250"],"v":["1397.95434819","5589.12101024"],"p":["44883.49461","44062.07654"],"t":[14350,66782],"l":["43607.60000","42770.80000"],"h":["45811.10000","45811.10000"],"o":["43659.30000","44709.10000"]},"ticker","XBT/EUR"]3[340,{"a":["45520.10000",5,"5.84803490"],"b":["45492.50000",0,"0.09374582"],"c":["45492.50000","0.00625418"],"v":["1398.10526819","5589.26685876"],"p":["44883.56109","44062.11477"],"t":[14359,66790],"l":["43607.60000","42770.80000"],"h":["45811.10000","45811.10000"],"o":["43659.30000","44709.10000"]},"ticker","XBT/EUR"]4{"event":"heartbeat"}5[340,{"a":["45503.80000",1,"1.00000000"],"b":["45496.20000",0,"0.01426600"],"c":["45496.20000","0.00109400"],"v":["1398.10636219","5589.26295766"],"p":["44883.56157","44062.11447"],"t":[14360,66788],"l":["43607.60000","42770.80000"],"h":["45811.10000","45811.10000"],"o":["43659.30000","44709.90000"]},"ticker","XBT/EUR"]6{"event":"heartbeat"}Boy, it is always such fun to do it. Like seriously, I always have fun playing with APIs, any APIs. Just making this API "conversation". I hope nothing is wrong with me😅Now you know how to interact with the Kraken API. Now let's try to describe it using AsyncAPI.Describing API using AsyncAPII'll explain, in detail, how to describe Websocket API with AsyncAPI in another blog post that will be part of the series. Why? I don't want to make this post super lengthy and discourage others from reading it. Let us learn step by step.For now, I will throw here a full AsyncAPI document I created for the Kraken API. You can also open it up in theAsyncAPI Studioand compare with theircurrent documentationFamiliarize with below before you look at the AsyncAPI document:AsyncAPI describes the API interface between the client and the server. In other words, the AsyncAPI document is for the user of the API. It does not describe what the server does but what the user can do with the API.Kraken API is quite complex. It has some beta servers, some private messages, and messages closely related to vocabulary specific for currency trading. I dropped all of those from my research not to overcomplicate things. In other words, the AsyncAPI file that you can see below is not a complete document.Websocket protocol is very flexible, and therefore you can implement the server in many different ways. There is no standard way of doing things, like there is no common way of doing things with AsyncAPI. We can only make some generic assumptions looking at existing implementations:Your server has one entry point, just one endpoint that you communicate with to gain access to the API. It can be apath with some dynamic values, as some data id. It can also be nothing, no path at all, like in the case of below Kraken API. These entry points arechannelsin AsyncAPI document. Commonly, Websocket API has just onechannelthat user can send messages to and receive messages at the same timeAsyncAPI publish and subscribe operations translates tomessages user can send to the APIandmessages user will receive from the API. Depending on API complexity, sometimes you have an API that sendsonly one message. You can also have a situation where you can send to the server multiple different messages, and also receive different messages in response. This is when you need to useoneOfas I did in document for Kraken API.Current AsyncAPI limitation is that you cannot specify that once the user sends (publish) messageping, thepongmessage is a reply. Look at thisthreadto participate in an ongoing discussion about request/reply pattern support in AsyncAPI. In the below document, you will notice that for such a use case, I use AsyncAPI specification extensions (x-response).Message to Kraken API developers and technical writersIn case you want to continue the work I started on the AsyncAPI document for Kraken API, feel free to do that. I'm happy to help, just let me know. Reach me out in ourAsyncAPI Slack workspace.1asyncapi:2.0.023info:4title: Kraken Websockets API5version:'1.8.0'6description: |7WebSockets API offers real-time market data updates. WebSocketsisa bidirectional protocol offering fastest real-time data, helping you build real-time applications. Thepublicmessage types presented belowdonotrequire authentication.Private-data messages can be subscribedona separate authenticated endpoint.89### General Considerations1011- TLSwithSNI (Server Name Indication)isrequiredinordertoestablish a Kraken WebSockets API connection. See Cloudflare's [What is SNI?](https://www.cloudflare.com/learning/ssl/what-is-sni/) guide for more details.12- All messages sentandreceived via WebSockets are encodedinJSON format13- Alldecimalfields (including timestamps) are quotedtopreserveprecision.14- Timestamps shouldnotbe considered uniqueandnotbe consideredasaliasesfortransaction IDs. Also, the granularityoftimestampsisnotrepresentativeoftransaction rates.15- At least oneprivatemessage should be subscribedtokeep the authenticated client connection open.16- Please use REST API endpoint [AssetPairs](https://www.kraken.com/features/api#get-tradable-pairs)tofetch the listofpairs which can be subscribed via WebSockets API.Forexample, field'wsname' gives the supported pairs name which can be used to subscribe.17- Cloudflare imposes a connection/re-connection rate limit (per IP address)ofapproximately150attempts per rolling10minutes.Ifthisisexceeded, the IPisbannedfor10minutes.18- Recommended reconnection behaviouristo(1) attempt reconnection instantly uptoa handfuloftimesifthe websocketisdropped randomly during normal operation but (2) after maintenanceorextended downtime, attempttoreconnect no more quickly than once every5seconds. Thereisno advantagetoreconnecting more rapidly after maintenance during cancel_only mode.1920servers:21public:22url: ws.kraken.com23protocol: wss24description: |25Publicserver available without authorization.26Once the socketisopen you can subscribetoapublicchannelbysending a subscribe request message.27private:28url: ws-auth.kraken.com29protocol: wss30description: |31Privateserver that requires authorization.32Once the socketisopen you can subscribetoprivate-data channelsbysending an authenticated subscribe request message.3334The API client must request an authentication"token"via the following REST API endpoint"GetWebSocketsToken"toconnecttoWebSocketsPrivateendpoints.Formore details read https://support.kraken.com/hc/en-us/articles/360034437672-How-to-retrieve-a-WebSocket-authentication-token-Example-code-in-Python-33536The resulting token must be providedinthe"token"fieldofanynewprivateWebSocket feed subscription:{
"event": "subscribe",
"subscription":
{
"name": "ownTrades",
"token": "WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu"
}
}12channels:3/:4publish:5description:SendmessagestotheAPI6operationId:processReceivedMessage7message:8oneOf:9-$ref:'#/components/messages/ping'10-$ref:'#/components/messages/subscribe'11-$ref:'#/components/messages/unsubscribe'1213subscribe:14description:MessagesthatyoureceivefromtheAPI15operationId:sendMessage16message:17oneOf:18-$ref:'#/components/messages/pong'19-$ref:'#/components/messages/heartbeat'20-$ref:'#/components/messages/systemStatus'21-$ref:'#/components/messages/subscriptionStatus'2223components:24messages:25ping:26summary:Pingservertodeterminewhetherconnectionisalive27description:Clientcanpingservertodeterminewhetherconnectionisalive,serverrespondswithpong.Thisisanapplicationlevelpingasopposedtodefaultpinginwebsocketsstandardwhichisserverinitiated28payload:29$ref:'#/components/schemas/ping'30x-response:31$ref:'#/components/messages/pong'32heartbeat:33description:Serverheartbeatsentifnosubscriptiontrafficwithin1second(approximately)34payload:35$ref:'#/components/schemas/heartbeat'36pong:37summary:Pongisaresponsetopingmessage38description:Serverpongresponsetoapingtodeterminewhetherconnectionisalive.Thisisanapplicationlevelpongasopposedtodefaultponginwebsocketsstandardwhichissentbyclientinresponsetoaping39payload:40$ref:'#/components/schemas/pong'41systemStatus:42description:Statussentonconnectionorsystemstatuschanges.43payload:44$ref:'#/components/schemas/systemStatus'45examples:46-payload:47connectionID:862861539084861000048event:systemStatus49status:online50version:1.0.051subscribe:52description:Subscribetoatopiconasingleormultiplecurrencypairs.53payload:54$ref:'#/components/schemas/subscribe'55examples:56-payload:57event:subscribe58pair:59-XBT/USD60-XBT/EUR61subscription:62name:ticker63-payload:64event:subscribe65subscription:66name:ownTrades67token:WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu68x-response:69$ref:'#/components/messages/subscriptionStatus'70unsubscribe:71description:Unsubscribe,canspecifyachannelIDormultiplecurrencypairs.72payload:73$ref:'#/components/schemas/subscribe'74examples:75-payload:76event:unsubscribe77pair:78-XBT/EUR79-XBT/USD80subscription:81name:ticker82-payload:83event:unsubscribe84subscription:85name:ownTrades86token:WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu87x-response:88$ref:'#/components/messages/subscriptionStatus'89subscriptionStatus:90description:Subscriptionstatusresponsetosubscribe,unsubscribeorexchangeinitiatedunsubscribe.91payload:92$ref:'#/components/schemas/subscriptionStatus'93examples:94-payload:95channelID:1000196channelName:ohlc-597event:subscriptionStatus98pair:XBT/EUR99reqid:42100status:unsubscribed101subscription:102interval:5103name:ohlc104-payload:105errorMessage:Subscriptiondepthnotsupported106event:subscriptionStatus107pair:XBT/USD108status:error109subscription:110depth:42111name:book112113schemas:114ping:115type:object116properties:117event:118type:string119const:ping120reqid:121$ref:'#/components/schemas/reqid'122required:123-event124heartbeat:125type:object126properties:127event:128type:string129const:heartbeat130pong:131type:object132properties:133event:134type:string135const:pong136reqid:137$ref:'#/components/schemas/reqid'138systemStatus:139type:object140properties:141event:142type:string143const:systemStatus144connectionID:145type:integer146description:TheIDoftheconnection147status:148$ref:'#/components/schemas/status'149version:150type:string151status:152type:string153enum:154-online155-maintenance156-cancel_only157-limit_only158-post_only159subscribe:160type:object161properties:162event:163type:string164const:subscribe165reqid:166$ref:'#/components/schemas/reqid'167pair:168$ref:'#/components/schemas/pair'169subscription:170type:object171properties:172depth:173$ref:'#/components/schemas/depth'174interval:175$ref:'#/components/schemas/interval'176name:177$ref:'#/components/schemas/name'178ratecounter:179$ref:'#/components/schemas/ratecounter'180snapshot:181$ref:'#/components/schemas/snapshot'182token:183$ref:'#/components/schemas/token'184required:185-name186required:187-event188unsubscribe:189type:object190properties:191event:192type:string193const:unsubscribe194reqid:195$ref:'#/components/schemas/reqid'196pair:197$ref:'#/components/schemas/pair'198subscription:199type:object200properties:201depth:202$ref:'#/components/schemas/depth'203interval:204$ref:'#/components/schemas/interval'205name:206$ref:'#/components/schemas/name'207token:208$ref:'#/components/schemas/token'209required:210-name211required:212-event213subscriptionStatus:214type:object215oneOf:216-$ref:'#/components/schemas/subscriptionStatusError'217-$ref:'#/components/schemas/subscriptionStatusSuccess'218subscriptionStatusError:219allOf:220-properties:221errorMessage:222type:string223required:224-errorMessage225-$ref:'#/components/schemas/subscriptionStatusCommon'226subscriptionStatusSuccess:227allOf:228-properties:229channelID:230type:integer231description:ChannelIDonsuccessfulsubscription,applicabletopublicmessagesonly.232channelName:233type:string234description:ChannelNameonsuccessfulsubscription.Forpayloads'ohlc'and'book',respectiveintervalordepthwillbeaddedassuffix.235required:236-channelID237-channelName238-$ref:'#/components/schemas/subscriptionStatusCommon'239subscriptionStatusCommon:240type:object241required:242-event243properties:244event:245type:string246const:subscriptionStatus247reqid:248$ref:'#/components/schemas/reqid'249pair:250$ref:'#/components/schemas/pair'251status:252$ref:'#/components/schemas/status'253subscription:254required:255-name256type:object257properties:258depth:259$ref:'#/components/schemas/depth'260interval:261$ref:'#/components/schemas/interval'262maxratecount:263$ref:'#/components/schemas/maxratecount'264name:265$ref:'#/components/schemas/name'266token:267$ref:'#/components/schemas/token'268interval:269type:integer270description:Timeintervalassociatedwithohlcsubscriptioninminutes.271default:1272enum:273-1274-5275-15276-30277-60278-240279-1440280-10080281-21600282name:283type:string284description:Thenameofthechannelyousubscribetoo.285enum:286-book287-ohlc288-openOrders289-ownTrades290-spread291-ticker292-trade293token:294type:string295description:base64-encodedauthenticationtokenforprivate-dataendpoints.296depth:297type:integer298default:10299enum:300-10301-25302-100303-500304-1000305description:Depthassociatedwithbooksubscriptioninnumberoflevelseachside.306maxratecount:307type:integer308description:Maxrate-limitbudget.ComparetotheratecounterfieldintheopenOrdersupdatestocheckwhetheryouareapproachingtheratelimit.309ratecounter:310type:boolean311default:false312description:Whethertosendrate-limitcounterinupdates(supportedonlyforopenOrderssubscriptions)313snapshot:314type:boolean315default:true316description:Whethertosendhistoricalfeeddatasnapshotuponsubscription(supportedonlyforownTradessubscriptions)317reqid:318type:integer319description:clientoriginatedIDreflectedinresponsemessage.320pair:321type:array322description:Arrayofcurrencypairs.323items:324type:string325description:Formatofeachpairis"A/B",whereAandBareISO4217-A3forstandardizedassetsandpopularuniquesymbolifnotstandardized.326pattern:'[A-Z\s]+\/[A-Z\s]+'Personal noteIf you can, if you are in a planning phase, new project, etc., then start designing your architecture with AsyncAPI. Don't do the mistake of coding first and then trying to figure out how to describe it with AsyncAPI😅Stay tuned for the next blog post that guides you step by step through the above document☮️I recommend you also read another article from the series about WebSocket:Creating AsyncAPI for WebSocket API - Step by Step.
"""
--------------------------------------------------------------------------------


Post 90
ID: https://www.asyncapi.com/blog/march-2021-at-asyncapi?utm_source=rss
Title: March 2021 at AsyncAPI
Link: https://www.asyncapi.com/blog/march-2021-at-asyncapi?utm_source=rss
Summary: AsyncAPI Initiative joined the Linux Foundation in March, but except of this, many other interesting things happened: new roadmap, google summer of code
Content:
"""
ReadFebruary 2021 at AsyncAPIfor the update from February.In case you do not have time to read this article, maybe take time to listen to the news. Let me know what you think about such an appraoch.Q1 2021 came to an end. Let me summarise our targets, revenue, and forecasts😃This month:Slackmembers up by around 100 (reached 1.1k)Twitterfollowers up by around 100 (reached 1.7k)LinkedInfollowers up by around 100 (reached 1k)NewOpenCollectivecontributor,Apideck+ additional 100 USD every monthForecast? Last months were as awesome as March, usually +100. Does it mean that we will have +1k members on all channels by the end of the year?😅Figure 1: Comparison of Q1 2020 vs Q1 2021 visits to asyncapi.comLet's scale this party up!AsyncAPI at Linux FoundationWe did it. AsyncAPI initiative joined Linux Foundation (LF). No more excuses for you not to join us. You're all welcome.I don't want to write about this too much as everything was described in different articles about us joining LF:AsyncAPI joins Linux FoundationLinux Foundation Will Host AsyncAPI to Support Growth and Collaboration for Industry's Fastest-Growing API SpecThe Linux Foundation Announces Hosting of AsyncAPIAsyncAPI Looks to Unify API Workflow under Linux FoundationFAQLet me provide more context in FAQ style:Is Linux Foundation taking control over AsyncAPINo. AsyncAPI Initiative runs underopen governance modeland is community-driven. LF assures the project's intellectual property (IP), and related assets do not belong to any company or individual.Fran Mendezdoes not retire. He only handed over rights to the project to the foundation to assure the community that it is completely safe for all to use the spec and its tooling.It also means ourGitHub organizationis not going anywhere. Nothing changes.Do we need to sign some CLA now to contributeWe do not need a contributor license agreement (CLA) on repositories for our tools. We might need to set upEasyCLAfor the repository where we have the specification. We need to clarify it in the long run—nothing to worry about until we set it up. In the end, the only reason to set it up is to secure the community from a situation that some contributor (or their company) claims rights to some part of the specification they contributed to.How much money you needGlad you asked. We joined the foundation with an open governance model that favors active contributors over sponsors. As a result, we do not have a setup where we can assure significant income in exchange for voting rights. In other words, we do not have a financial founding associated with joining the foundation. We still need your financial support. Go to ourOpen Collective profileand drop some coins. Let us know if I can help to preach about AsyncAPI in your company for some extra money.How can we helpExcept for regular contributions, we need help setting up tooling for our open governance model. We need to:Automate a process of collecting information about TSC membersPut information about current TSC members on the AsyncAPI websiteFigure out tooling for the websiteSetup CODEOWNERS and VOTING files in all the repositoriesEveryone with a different set of skills is welcome.Just contact me.What is nextWe are almost ready for the next releases of the specification. We already have a new, GraphQL-inspired contribution guide that explains how to introduce changes in the specification. What is left is a decision on how actually to decide that release will happen and when. Help us by:Familiarize withinstructionon how to introduce changes in the spec, pickthe ideathat you want to champion, and let us start improving the specHave a look at theproposal on release cadenceand share your opinion, as comments or emojisVision and roadmapAsyncAPI creator,Fran Mendez, published AsyncAPI Initiative's vision and roadmap for next years.tl;drAsyncAPI becomes the #1 API specification for defining and developing APIs. Any kind of APIs.Go to theroadmapview to check out what it means and what needs to be done to get there.We need a lot of help to complete this roadmap. Without engagement and support of the community, all of this is just wishful thinking. All hands aboard, we're waitinghere.Google Summer of CodeIn 2020, we decided to actively supportthe Hacktoberfestto give back to the community by making it easier to make a first contribution in open-source and at the same time improve awareness about the AsyncAPI Initiative. We received a very positive feedback, and people referred us toGoogle Summer of Codeas a place where our engagement would be highly appreciated.We applied this year to be part of the GSoC initiative.We got rejected.It is not easy to reject us, though😃Postmanthat we partner with was accepted for GSoC and offered us to submit the list withour ideas(ideas 7-13) as part of Postman application. We received many proposals and were contaced by many very motivated students (but not only students) who would like to join the AsyncAPI initiative and build great tools.Have a look at the list of ideas. We received proposals for all of them. It looks like soon, our tooling ecosystem will get many new useful tools. Stay tuned. Feel free to join us, share your use cases for the ideas and also help build those tools. A Majority of discussions happenhere.Bindings rendering in react componentThanks to work done bySwen HelgefromSolace, the React component supports rendering of information provided in bindings. Check release0.21in theplayground for the React component.Messages validation in NodeJS templateThanks to work done byKhuda Dad Nomani, the NodeJS template that you can generate using the AsyncAPI Generator includes a message validator that enables real-time validation of all incoming and outgoing messages. Check outthisshort instructions to see it in action or watch the below recording.About AsyncAPI in different languagesAre you tired of reading about AsyncAPI only in English? Some articles in French and Spanish were released recently, have a look:SpanishFrenchIf you want to see more content in different languages, let us know.Also, provide feedback toBarbaño Gonzálezthat works on content for Spanish-speaking audience. Some help neededhere.Photo byMarkus SpiskeonUnsplash
"""
--------------------------------------------------------------------------------


Post 91
ID: https://www.asyncapi.com/blog/asyncapi-joins-linux-foundation?utm_source=rss
Title: AsyncAPI joins Linux Foundation
Link: https://www.asyncapi.com/blog/asyncapi-joins-linux-foundation?utm_source=rss
Summary: Today marks a delightful milestone for us at AsyncAPI: I'm proud to share with you that we're now a Linux Foundation project 🎉
Content:
"""
Today marks a delightful milestone for us at AsyncAPI:I'm proud to share with you that we're now a Linux Foundation project🎉When a year ago, our Łukasz and I started having discussions on the best way to improve the open governance, we instantly agreed that AsyncAPI had to join a neutral home. But not just any neutral home. We needed to join a strong and trusted organization that would allow us to keep the project independent and community-driven. That's the Linux Foundation. The home of many other internet open-source industry standards.It's been a year to remember. Amidst a pandemic, we organized the first AsyncAPI Conference. Lots of new folks joined our great community. Our tools started to get mature enough. And to put the cherry on the cake,we partnered with Postmanto guarantee the continuity and growth of AsyncAPI for the next decade. What a ride!2021 looks no different so far. In less than 3 months, we're seeing an increasing amount of folks joining us tochange the EDA and API landscapes forever. We owed you this. We're joining the Linux Foundation to make sure AsyncAPI stays neutral and isdriven by those who dedicate their effort, time, and love to the project.And that's what it is all about, my friends. Without you —yes, you too!–, AsyncAPI is nothing but an illusory fantasy in the heads of some dreamers. This step is indeed the culmination of years of hard work, but to me, this is just the beginning. Now is when the party is actually getting started. Drop some cool beats and grab some drinks. It's going to be a long night!Let's build the future, together🚀
"""
--------------------------------------------------------------------------------


Post 92
ID: https://www.asyncapi.com/blog/building-async-flight-notification-service?utm_source=rss
Title: Building an asynchronous flight notification service using AsyncAPI, MQTT, Amadeus and Twilio
Link: https://www.asyncapi.com/blog/building-async-flight-notification-service?utm_source=rss
Summary: Flight delays, cancelations and gate changes are among the most common headaches that travelers face. Now more so than ever, travelers need this information literally at hand to enjoy a stress-free tr
Content:
"""
Flight delays, cancelations and gate changes are among the most common headaches that travelers face. Now more so than ever, travelers need this information literally at hand to enjoy a stress-free trip.With this in mind, we decided to build a small prototype to implement an asynchronous scheduling notification service. The prototype will be implemented following the microservices architecture paradigm with the following services and requirements in mind:All services should communicate asynchronously via theMQTTprotocol, a lightweight publish-subscribe messaging pattern. Messages should be correctly defined and documented following AsyncAPI specs.AMonitor servicereceives and queues flight information and queries the REST API to detect changes. When it detects a change, it notifies subscribers. Flight schedule information is retrieved from theFlight Status APIfrom Amadeus for Developers.ANotifier servicereceives the notifications and alerts the user via SMS. Alerts are sent using theTwilio SMS API.ASubscriber serviceprovides a simple web interface so users can subscribe to flight status updates.Defining messages with AsyncAPIFirst, we’ll define two messages to model the events managed by subscribers and publishers:AflightQueuemessage to queue a new flight to be monitored for status changes. This event is composed of two main schemas:user– to model information about the user subscribing to the notifications (name and phone number):1type:object2properties:3userName:4type:string5minimum:16phoneNumber:7type:string8description:phonenumberwherenotificationswillbereceived.flight- to model  information about the flight being monitored (carrier code, flight number and departure date).1type:object2properties:3carrierCode:4type:string5description:2to3-characterIATAcarriercode6example:"LH"7flightNumber:8type:integer9minimum:110description:1to4-digitnumberoftheflight11example:"193"12scheduledDepartureDate:13type:string14format:date-time15description:scheduleddeparturedateoftheflight,localtothedepartureairport.16example:"2020-10-20"AflightStatusmessage to notify about changes. When the service detects a change in flight status, it triggers a notification event to alert the user. The payload of theflightStatusmessage consists of the following structure:flightanduserschemas (the same as in theflightQueuemessage) to identify the flight emitting the event and the user receiving the notification.Twosegmentschemas corresponding to the origin and destination. This lets us notify about changes to both departure and arrival.1type:object2properties:3iataCode:4type:string5description:2to3-characterIATAcarriercode6example:"MAD"7scheduledDate:8type:string9format:date-time10description:scheduleddatetimeoftheflight,localtotheairport.11example:"2020-10-20 19:15"12gate:13type:string14description:departuregate15example:"2D"16terminal:17type:string18description:airportterminal19example:"4"Messages are shared among services so it’s important to correctly organize the YAML definition files under a common folder. In our case, we call it common:common/
messages/
flight_queue.yaml
flight_status.yaml
schemas/
flight.yaml
segment.yaml
user.yamlServices communicate through channels using the publish/subscribe pattern. Our architecture uses two different channels:flight/queueto manage and queue the flights to be monitored.flight/updateto manage the notifications about flight updates.Each service contains anasyncapi.yamlfile with the description of the service and server and channel information. Let's take a look to the finalasyncapi.yamlfile of the Subscriber service to see how the messages and channels are organized:1asyncapi:'2.0.0'2info:3title:FlightSubscriberService4version:'1.0.0'5description:|6Allows users to subscribe events from a given flight7license:8name:Apache2.09url:'https://www.apache.org/licenses/LICENSE-2.0'10servers:11development:12url:mqtt://localhost:188313protocol:mqtt14channels:15flight/queue:16description:|17queue flight in order to retrieve status18subscribe:19summary:Receiveinformationabouttheflightthatshouldbemonitoredforchanges20message:21$ref:'#/components/messages/flightQueue'22components:23messages:24flightQueue:25$ref:'../common/messages/flight_queue.yaml'When the user provides their flight information, the Subscriber service emits aflightQueuemessage that will be received by the Monitor service from theflight/queuechannel. The Notifier service also receives the message and adds the payload to the list of flights to monitor.Once the Monitor service detects a change in flight status (e.g. a change in boarding gate), it emits aflightStatusmessage to inform subscribers. The Notifier service, which is subscribed to the changes on theflight/updatechannel, notifies the end-user by SMS.The AsyncAPI specification files for theMonitor ServiceandNotifier Servicecan be found on GitHub.Monitoring flight status informationThe Monitor service checks the status of the user’s flight by calling the On-Demand Flight Status API, which provides real-time flight schedule information like departure/arrival times, gate, or terminal. A simple cURL request to the API shows how the information is represented:To get your own authorization token, followthisguide.curlhttps://test.api.amadeus.com/v2/schedule/flights?carrierCode=KL&flightNumber=1772scheduledDepartureDate=2021-02-18-H 'Authorization: Bearer dzh1cpJiFgAlE7iZS'In the JSON response, the schedule data of this example has one single segment (a leg of an itinerary, in airline jargon) with severalflightPoints:1"flightPoints": [2{3"iataCode":"FRA",4"departure": {5"terminal": {6"code":"1"7},8"gate": {9"mainGate":"B20"10},11"timings": [12{13"qualifier":"STD",14"value":"2020-11-05T18:20+01:00"15}16]17}18},19{20"iataCode":"AMS",21"arrival": {22"terminal": {23"code":"1"24},25"gate": {26"mainGate":"A04"27},28"timings": [29{30"qualifier":"STA",31"value":"2020-11-05T19:35+01:00"32}33]34}35}36]We can see that:The flight is scheduled to depart from Terminal 1, Gate B22 of Frankfurt International Airport (FRA) at 18:20 (UTC+1).It is scheduled to arrive at Terminal 1, Gate A04 of Amsterdam Schiphol Airport (AMS) at 19:35 (UTC+1).The API is synchronous and therefore needs to be polled to monitor the flight status. This isn’t ideal and we need a solid strategy to avoid DDoSing the Amadeus backend, using up our free call quota or piling up a massive bill at the end of the month.To solve this, we put the Monitor service on a separate thread. Every five minutes, the thread checks to see if it’s time to retrieve information from the API and update the status. The Monitor only calls the API if two conditions are met:The current date is equal to the departure date.The current time is within 4 hours of the departure time.Subscribing to flight updatesThe Subscriber service  lets users subscribe to the notifications. We built a simple HTTP server with Flask to let the user enter their name, phone number and flight information.Once the Subscriber service gets a new user subscription, it emits aflightQueuemessage with that information in the payload to the broker, so that it can be received by the Monitor.Sending notifications to usersThe Notifier service receives flight status updates from the Monitor and uses the Twilio SMS API to notify the end. The service has a very simple implementation: when the Notifier receives aflightStatusmessage, it uses the message payload to build an SMS message:1client = twilio.Client(account_sid, auth_token)23msg = build_message(alert_msg['user'],4alert_msg['departure'],5alert_msg['arrival'])67destination_phone = alert_msg['user']['phoneNumber']89message = client.messages.create(body=msg,10from_=twilio_phone,11to=destination_phone)Running the serviceTheprototyperuns on four Docker containers – one per service plus another for theMQTT brokerbased on the Docker image maintained by the Eclipse Mosquitto project.To avoid manually starting each service (plus the dependency of starting the broker first), we will useDocker compose, a tool to run applications composed of multiple containers using a YAML file to define each container as well as their dependencies.We start the service by executing:docker network create my-network
docker-compose up --remove-orphansIn the browser, we go tohttp://localhost:5000and enter information about the flight we want to monitor. The service will send us an alert once the flight information is updated:ConclusionOur prototype successfully implements our requirements but it’s still far from being ready to use in production. To do so, we’d need to implement authorization, an unsubscribe feature and improve the polling service’s performance, among other improvements.However, developing this prototype lets us learn how to specify and document event-driven architecture using AsyncAPI easily.You can find the complete source code of the prototype on the GitHubasync-flight-status repository. Feel free to clone, modify and improve the implementation!Happy coding!
"""
--------------------------------------------------------------------------------


Post 93
ID: https://www.asyncapi.com/blog/understanding-asyncapis?utm_source=rss
Title: Understanding AsyncAPIs with a Practical Example
Link: https://www.asyncapi.com/blog/understanding-asyncapis?utm_source=rss
Summary: Learn how to map a real-world event-driven Microservices architecture into AsyncAPI specification
Content:
"""
Event-driven applications are inherently distributed and loosely-coupled. That potentially leads to having many self-contained components in your architecture, managed by multiple teams.The information exchanged between them must be documented and maintained consistently for everyone’s visibility.AsyncAPI specificationsteps in to solve that gap.This post explains how to map a simple event-driven application architecture into corresponding AsyncAPI specifications by walking you through an example.The event-driven use caseImagine you are designing a solution to the following use case.Two event-driven microservices are communicating through a message broker in a publish/subscribe manner. The first service, the Account service, publishes theUserSignedUpevent when a new user account is created. The second service, the Email service, subscribed to receive those events to send the new user a welcome email.We can come up with a simple solution architecture as follows.The problemNow we have a solution architecture in place. Should we go ahead and start building?No! Not so fast. There are strong reasons behind not doing so.Account and Email services are loosely coupled distributed services, potentially built, operated, and maintained by separated teams. Two services will have their own context boundaries defined. All teams must explicitly define any information exchanged across these boundaries. For example, all teams must maintain broker configurations, topics, and event formats in a central place. Otherwise, maintaining the solution will become a nightmare in the long run.In our solution, the format of theUserSignedUpevent must be consistent across two services. If one team makes a change, it has to be visible across the board.Therefore, a proper process must be in place to describe different components of an event-driven system and their interactions.
AsyncAPI specification comes into play at this point.AsyncAPI specification to the rescueAsyncAPI is an open-source initiative that provides both a specification to describe and document your asynchronous applications in a machine-readable format and tooling (such as code generators) to make life easier for developers tasked with implementing them.-Marc DiPasqualeAsyncAPI is built on the foundation ofOpenAPI specification. A brings in critical activities from the REST API world, from documentation to code generation, from discovery to event management. Most of the processes you apply to your REST APIs nowadays would apply to event-driven/asynchronous APIs.Currently, the specification is atversion 2.0.0.Documenting the solution architectureLet’s try to document our solution as per the AsyncAPI specification. Our end goal is to share it with respective teams to generate the implementations, validators, and most importantly, the documentation.An AsyncAPI document is a file that defines and annotates the different components ofa specific Event-Driven Application. The file format must be JSON or YAML; however, only the subset of YAML that matches the JSON capabilities is allowed.First, we need to identifyApplicationsin the solution.Identify event-driven applications in the solutionThe first step of documenting an event-driven architecture is to identify discrete components that produce or consume events. In AsyncAPI terms, they are commonly referred to asApplications.As per the specification:An application is any kind of computer program or a group of them. It MUST be aproducer, aconsumeror both. An application MAY be a microservice, IoT device (sensor), mainframe process, etc. An application MAY be written in any number of different programming languages as long as they support the selectedprotocol. An application MUST also use a protocol supported by the server in order to connect and exchangemessages.In our solution, both Account service and Email service can be considered as applications as they produce and consumeUserSignedUpevents, respectively. Hence, both services will get their own AsyncAPI specification file.Let’s start with the Account service first.Documenting the Account serviceCreate a file calledaccount-service.yamland add the following content to it.1asyncapi:2.0.02info:3title:AccountService4version:'1.0.0'5description:|6Manages user accounts in the system.7license:8name:Apache2.09url:https://www.apache.org/licenses/LICENSE-2.0The first line of the specification starts with the document type,asyncapi, and theversion(2.0.0). This line doesn’t have to be the first one, but it’s a recommended practice.Theinfoobject contains the minimum required information about the application. It contains thetitle, which is a memorable name for the API, and the version. While it’s not mandatory, it is strongly recommended to change the version whenever you make changes to the API.Adding serversOur solution has been designed around a message broker. Therefore, both Account and Email services MUST specify brokers’ necessary information such as URIs, protocols, and security configurations.We can use theserversobject to define that information for the Account service. In AsyncAPI terms, a server object defines a message broker, a server, or any other kind of computer program capable of sending or receiving data.Add the following content to the same file. Here, we are using the test MQTT broker available at mosquitto.org. Apart from MQTT, AsyncAPI supports other protocols like AMQP and Kafka.1servers:2production:3url:mqtt://test.mosquitto.org4protocol:mqtt5description:TestMQTTbrokerAdding channels, operations, and messagesSo far, the Account service consumers know where they should connect to send or receive data. The next step is to define operations on the broker.An operation maps to eitherpublishorsubscribemethod/function in the application. Each operation exchanges one or moremessages. Effectively, these messages define different events sent to and received from operations.Operations are bound to a particularchannelin the server, along with the messages they exchange. A channel is an addressable component made available by the server for the organization of messages. Producer applications send messages to channels, and consumer applications consume messages from channels. You can think of channels as the interfaces for external parties to communicate with an application.There can be many channel instances in a server, allowing messages with different content to be addressed to different channels. A channel is equivalent to topics, routing keys, event types, or paths based on the server implementation.This relationship is illustrated in the following figure.In our solution, both services publish and consume events on the same channel.Add the following section to define a channel calleduser/signedup.1channels:2user/signedup:3subscribe:4operationId:emitUserSignUpEvent5message:6$ref:'#/components/messages/UserSignedUp'The Account service publishesUserSignedUpevents to the broker. Hence, it is a publish operation. TheoperationIdspecifies the name of the method or function that emits theUserSignedUpevent in the generated code.The above operation uses a reference to specify the format of the message that publishes. We’ll get to the schema definitions shortly.Defining messages and payload schemaIn our solution, both services produce and consume theUserSignedUpevent, which has the following format.1{2"firstName":"John",3"lastName":"Doe",4"email":"aa@bb.cc",5"createdAt":"2021-02-12 09:34:123"6}The publish operation of theuser/signedupchannel had a reference to the event payload’s schema. Now we need to define it properly. The schema definitions are done with AsyncAPI schema, which is 100% compatible with JSON Schema Draft 07. Refer tothisif you need to explore more on the AsynAPI schemas.Message schemas, security schemes, and bindings are housed byComponentsobject. All objects defined within the components object must be referenced from properties outside the components object.After adding the schemas, the final AsyncAPI definition for the Account service file should look like the following.1asyncapi:2.0.02info:3title:AccountService4version:'1.0.0'5description:|6Manages user accounts in the system.7license:8name:Apache2.09url:https://www.apache.org/licenses/LICENSE-2.01011servers:12production:13url:mqtt://test.mosquitto.org14protocol:mqtt15description:TestMQTTbroker1617channels:18user/signedup:19subscribe:20operationId:emitUserSignUpEvent21message:22$ref:'#/components/messages/UserSignedUp'2324components:25messages:26UserSignedUp:27name:userSignedUp28title:Usersignedupevent29summary:Informaboutanewuserregistrationinthesystem30contentType:application/json31payload:32$ref:'#/components/schemas/userSignedUpPayload'3334schemas:35userSignedUpPayload:36type:object37properties:38firstName:39type:string40description:"foo"41lastName:42type:string43description:"bar"44email:45type:string46format:email47description:"baz"48createdAt:49type:string50format:date-timeDocumenting the Email serviceSimilar to the above, we can create the AsyncAPI specification for the Email service as follows.1asyncapi:2.0.02info:3title:EmailService4version:'1.0.0'5description:|6Sends emails upon certain events7license:8name:Apache2.09url:https://www.apache.org/licenses/LICENSE-2.01011servers:12production:13url:mqtt://test.mosquitto.org14protocol:mqtt15description:TestMQTTbroker1617channels:18user/signedup:19publish:20operationId:onUserSignUp21message:22$ref:'#/components/messages/UserSignedUp'2324components:25messages:26UserSignedUp:27name:userSignedUp28title:Usersignedupevent29summary:Informaboutanewuserregistrationinthesystem30contentType:application/json31payload:32$ref:'#/components/schemas/userSignedUpPayload'3334schemas:35userSignedUpPayload:36type:object37properties:38firstName:39type:string40description:"foo"41lastName:42type:string43description:"bar"44email:45type:string46format:email47description:"baz"48createdAt:49type:string50format:date-time51description:"foo"Notice that the servers, channels, and payloads are the same. The only difference is in thepublishoperation, bound to theuser/signedupchannel. It says that messages published to this channel will be received by this service.What’s next?Now we have completed writing AsyncAPI specifications for both Microservices. The next goal is to check-in them into a central location like Git and let both teams collaborate over the design. They can collaboratively edit the spec files to introduce new operations, parameters, versions, etc. Thanks to AsyncAPI, everything can be controlled from a central place, and every change will be visible across the board. I would say this is the pipe dream of an enterprise architect ;)But our journey doesn’t stop here. The AsyncAPI project brings in a rich set of tools for the betterment of event-driven application building. You can find more information on thishere.Code generatorsApplication developers can speed up their work by automatically generating scaffoldings by specifying the specification file. This design-first strategy provides boilerplate code for dealing with brokers and marshaling/unmarshalling messages over the wire.Generators are available for mainstream applications like Java, .NET, JavaScript, etc. You can check outthisrepo for more information.ValidatorsValidators validate a given message by comparing it with the specification. That is useful at the runtime for input validations.Documentation generatorsThese generators generate human-readable documentation from an AsyncAPI document. Output formats are HTML, Markdown, and React (experimental)Mocking and testing toolsTools that take specification documents as input, then publish fake messages to broker destinations for simulation purposes. May also check that publisher messages are compliant with schemas.ConclusionUse AsyncAPI specification to document your event-driven systems to maintain consistency, efficiency, and governance across different teams who own each architectural component.The tooling ecosystem of AsyncAPI helps you speed up application development by automating tedious but necessary tasks such as code generation, documentation generation, validators, etc. Use them whenever you can.Finally, the AsyncAPI community is growing so fast. Your contribution to the community will be valuable in terms of making better event-driven applications.I hope you enjoyed this post.Originally published athttps://medium.com/event-driven-utopiaCover image bysilviaritafromPixabay
"""
--------------------------------------------------------------------------------


Post 94
ID: https://www.asyncapi.com/blog/february-2021-at-asyncapi?utm_source=rss
Title: February 2021 at AsyncAPI
Link: https://www.asyncapi.com/blog/february-2021-at-asyncapi?utm_source=rss
Summary: We are getting close to joining a foundation. We started a few new initiatives. We are busy. In other words, this is a good time to join us and drive things together.
Content:
"""
ReadJanuary 2021 at AsyncAPIfor the update from January.I enjoy monthly status over weekly one. It is not that I'm just happy I have more time for other things. Content size did not change. I think people do have other things to do than following AsyncAPI only😅Life in open-source runs slower, at least when you look at it from the outside. I have an impression, that more people pay attention to the status when it is once a month. I wonder what your view is on that.Open governance model aka charter ready for the reviewIs an "open governance model" the same as a "charter"? No. Charter is a boring legal document that describes many rules that need to be followed when being under a foundation. One of the things the charter tackles is the general rules on how the project will operate and be governed.I think the most important thing to write here is that the AsyncAPI charter is a reality. It finally arrived and is ready for review. In the special blog post, we also explained what governance model we envision for the AsyncAPI Initiative in more human-friendly words. This content was released and communicated on Tuesday, 9th of March, and we will wait for your feedback until the 23rd of March. It looks like we will kick off April under the umbrella of the foundation🤞Please take your time to:ReadFinding a Good Open Governance Model for AsyncAPIto understand our motivationCheck outthispull request with the charterCode generators activitiesWe had some significant traffic in the area of code generation templates in February.PHPEmiliano Zublenajoined the AsyncAPI community big time by starting with donatinga new template for PHP. It is not yet released under@asyncapiscope on npm, but you can already play with it by using the AsyncAPI Generator with a direct GitHub link like:ag https://bit.ly/asyncapi https://github.com/asyncapi/asyncapi-php-template -o output`GoWe merged the initial pull request to theGo template. The initial contributor was not able to continue working on the template, but the foundation was there.Emiliano ZublenaandTakumi Suedawill try to help to drive forward template development. This template is not yet released as we need to get some feedback from the community first. Give it a try with:ag https://bit.ly/asyncapi https://github.com/asyncapi/go-template -o outputLet us know what you think in the GitHub issues section. Thank you,Jacob Postonfor your initial hard work on the template!TypeScript and NATSJonas Lagoniregularly extends and polishesthe TypeScript template for NATS. It reached 0.3 release and is the first template that is already using a new AsyncAPI SDK for data types generation. Please go and check it out.AsyncAPI CLI to rule them allWe always wanted to have a single CLI to do all the things related to AsyncAPI. In other words, one CLI to validate, generate, edit, create, and others. So far, we had a CLI for the AsyncAPI generator, and recently one of our community members,Jorge Aguiar Martín, referred us to his CLI for AsyncAPI validation.We all agreed that instead of working separately on different CLIs, it is better to work together on one CLI that everyone will love. The project kicked off! A repository has been created and we already discuss details on how the CLI interface should look like.Jointhe discussion.Event gatewaySounds big? It is😃An excellent engineer joined AsyncAPI,Sergio Moya. We felt like we need to start something big that should be built independently from any vendor together with the AsyncAPI community. The project got kicked off, and it is the best time to join. Have a look at the dedicated repository and our plans forthe Everest? AsyncAPI Gate? or maybe Eventide?😃Share your use cases. Please help us understand what you need. Sergio prepared an issue template thathelps with that.Domain model generationAs mentioned inthe blog post about January, February was all about data model generation that we wanted to use to speed up templates development for code generation. The library isready, and we started trying it out. You can try it out too, and you do not even need our AsyncAPI Generator. It is a generic library and you only need a JSON Schema Draft 7 or an AsyncAPI document.1import { TypeScriptGenerator } from '@asyncapi/generator-model-sdk';23const DESCRIPTION_PRESET = {4interface: {5property({ property, content }) {6const desc = property.getFromSchema('description');7if (desc) {8return `// ${desc}\n${content}`;9}10return content;11}12}13}1415const options = {16modelType: 'interface',17presets: [DESCRIPTION_PRESET],18}1920const generator = new TypeScriptGenerator(options);2122const schema = {23$id:"Address",24type:"object",25properties: {26street_name:    { type:"string"},27city:           { type:"string", description:"City description"},28house_number:   { type:"number"},29marriage:       { type:"boolean", description:"Status if marriage live in given house"},30pet_names:      { type:"array", items: { type:"string"} },31},32required: ["street_name","city","state","house_number","state"],33};3435const interfaceModels = await generator.generate(schema);3637// generated interfaceModels[0].result should have the following shape:38export interface Address {39streetName: string;40// City description41city: string;42houseNumber: number;43// Status if marriage live in given house44marriage?: boolean;45petNames?: Array<string>;46}Community continues to growIn February we reached 1600 followers on Twitter.A great thing to see is that the community fromLinkedIngrew to 900, and our news shared there also get more visibility.We are very noisy😅Other featuresThanks to the support ofDaniel CHU—who joined us during last Hacktoberfest— now the JavaScript parser also validates the examples of server variables. For more details, check out the1.4release.Once again, thanks toLudovic Dussartfrom Ineat Lab, we have additional features, these time in HTML and Markdown template. Thanks to the newversionparameter, you can overwrite the version of the application specified in the AsyncAPI file underinfo.version. Useful in CI/CD when your service version is not maintained in the AsyncAPI file but pom.xml or package.jsonThanks toMike Ralphson, we have a newfrontMatterparameter in the Markdown template. It lets you specify an external file with a custom front-matter that should be included in the resulting Markdown during generation. Very useful for static site generators' users.1# 1. Get AsyncAPI Generator2npm install -g @asyncapi/generator34# 2. Create a file with frontmatter5cat > ssg.yml <<EOF6title: AsyncAPI Documentation7layout: asyncapi8permalink: /asyncapi-docs9EOF1011# 3, Generate Markdown file that includes the frontmatter12ag https://bit.ly/asyncapi @asyncapi/markdown-template -o output -p frontMatter=ssg.yml1314# 4. Check out the output15cat output/asyncapi.mdMaciej UrbanczykandI(I mean me😃) pushed some features to the AsyncAPI Generator:It supports the latest Node.js 15 and npm 7You can now install generator templates globally. For more details, readthisnew section in the readme.It is now much easier to generate multiple files using the new React render engine. For more details, readthisor have a look at ithereSome parts of templates can be written in TypeScript. For more details, readthis. We still cannot use TS in main template code. For more details readthis.Check out all thereleasesGood learning resourcesRead this important10 FAQs About Event-Driven APIsfromDakshitha RatnayakeGreat summary from Nordic APIs andVyom Srivastavaon8+ AsyncAPI Documentation GeneratorsFran Mendez was a part of Postman's live stream. Learn how to get from zero to AsyncAPI in just about 1h 30min. I hope it can be done faster, and Fran was just having too much small talk with Kevin and Kin😅Photo byDenys NevozhaionUnsplash
"""
--------------------------------------------------------------------------------


Post 95
ID: https://www.asyncapi.com/blog/governance-motivation?utm_source=rss
Title: Finding a Good Open Governance Model for AsyncAPI
Link: https://www.asyncapi.com/blog/governance-motivation?utm_source=rss
Summary: AsyncAPI can be successful if the initiative is community-driven. To be community-driven, we need the community to see it can drive things and make an impact. For that, we need a proper open governance model. What model would be the best?
Content:
"""
tl;dr charter for the AsyncAPI Initiative open governance is ready for review. Leave your comments there inthispull request. We will wait two weeks for your feedback.December 2020 brought to AsyncAPI an important announcement, apartnership with Postman. This huge milestone secured the AsyncAPI Initiative development efforts as few active community members moved to Postman. This move speeded up our work on transferring AsyncAPI to a foundation and forming an open governance model to assure the community that a single company does not control AsyncAPI Initiative.It took us a lot of time to write down the initial charter for the initiative.Pro Tip:Charteris not a person that creates charts😃Nobody's trying to be a smart ass here. We actually had to google that😃The visionWe started with a basic vision in our heads and studied governance models of many diverse communities, like NodeJS Foundation, OpenJS Foundation, GraphQL Foundation, Cloud Events, OpenAPI Initiative, and CNCF. We also got a charter template from Linux Foundation. That was a lot to handle.In the end, we just wanted to make sure the initiative is community-driven and leaves no one behind. We tried to figure out a governance model that:is as democratic as possiblesupports the asynchronous decision-making processgives power to people that "work", not companies that "pay". In other words, it gives equal power to both individual and corporate contributors.VocabularyIn the AsyncAPI governance model, you can find two essential roles: contributor and committer. A contributor is a person that contributes to the project code, docs, or other artifacts. A committer is a person that contributes regularly and is invited by other committers to manage the repository, to have more privileges, and to approve pull requests.Committer rules in the repository, but for topics that go beyond, there is a Technical Steering Committee (TSC).TSC consists of all committers.Yes, not a dedicated group of people for now. Are you a committer? If yes, then it means you are a voting member of TSC (unless you do not want to). But more on that further in the blog post.Single TSC for spec and toolsSpec and tools will have different licenses, but there will not be two TSCs though. One TSC to handle both the specification and the tools.Why?start small, they say.don't design processes and then work accordingly but better build a process that facilitates the way you work already.we are a large community, but not large enough to handle two different charters, not now.The other good reason for not splitting is that we believe the initiative should work on spec and tools to provide essential open-source tools that consistently support the latest version of the specification. In other words, when we release the newest version of the specification, you can already use it with official tools and do not have to wait for other tooling providers to catch up. We know big companies do not care much about basic tooling as they most probably write their own because it is much easier for them to work without unnecessary noise. Nevertheless, we need to think about the small ones too. Two TSCs sound like having two silos that work separately, and it is not good for the start. Nobody says, though, that the TSC can't organically grow into two separate groups in the future.Value work more than moneyWe want to have a TSC consisting of all the active committers in the project, not people who are there because their company is a sponsor of the project. You are a TSC member because you work on the project, you code, write docs, maintain CI. You work, and therefore, you are a part of the initiative.Why? Don't you like money?We like money, don't get us wrong here😃Money helps the project a lot, we can sponsor many good things with the money we obtain from you.Nevertheless, we believe that it isn't good to run a project alone with lots of bucks in the pocket.What? We need a doctor here!🤷‍♂We just prefer to work with a large group of people, from different cultures, from other parts of the world, with diverse experience and use cases in heads. That is just how you build great products by having many people around you to help and validate the ideas actively.Respecting committers and the right to voteThe rule we want to follow is that the committer automatically gets a right to vote.Why?Voting is always about essential things, essential for the entire initiative. Who else should have a right to vote if not people that are directly affected by the decisions of the ToC? The tricky situation here is that this approach can lead to a problem where one company hires most committers and, therefore, takes over project steering. This is something we actually have at the moment. The majority of folks working actively on the project are from Postman. Nothing terrible happened to the project for now, but this doesn't mean the whole community feels comfortable.We had a tough brainstorming here about finding the right balance between respecting all contributors equally and still making sure that there is no risk that a company has most voters. That is why we have a rule that only 1/4 of voters can be affiliated with the same company. Or 1/3 in case we need to look for more maintainers to bring balance back to the force.Work on all the tools under the AsyncAPI umbrellaWe want AsyncAPI Initiative to be a place where AsyncAPI open source tools are developed, together, so we do not duplicate each other in the community with different variations of the same tool. So far, seven AsyncAPI tools resulted from different companies or individuals' work and moved to the AsyncAPI GitHub organization. We want this to become a standard in the community.The governance model embraces this direction. How?If you own a project, you created it. It means you are its committer.Do you see where We're getting?Yes, it means that once you donate the project to the AsyncAPI Initiative, you do not only stay there as a committer but also become a voting member.No meetings - async all the thingsWe hate to have too many meetings. Meetings suck out your blood. Meetings = schedule and schedule = leash.Zero meetings? No, we will have something on the schedule, but it will not be mandatory. We will not make decisions during the meetings, so you do not have to rush to be there. You just need to watch the recording to learn if there is something relevant for you if there is a topic that needs voting. Decision-making should be asynchronous, and people should have time to make wise decisions.The async decision-making process also assures that the number of voters can scale up easily, and we should be able to handle as many committers in the group as we have. We can automate many things here.Wishful thinkingWe hope that a side effect of such an open governance model will be that companies will have a better motivation to sponsor the initiative financially and assign employees to work on the spec and tooling regularly to become committers and become voting members of the TSC.Hopefully, these companies will take shortcuts here that will open up new job opportunities for individual contributors.That was not our initial goal, though. We just figured that this might happen, and we look forward to it.I hope this rough explanation makes it easier to digest the charter. Please share what you think. UseTwitter,Slack, email. Write publicly or privately. We just care about the feedback and not how you pass it on.You can also comment onthispull request with the charter. You can leave generic comments that we could reuse in official communication after we join the foundation.Cheers🍻Photo byUnited Nations COVID-19 ResponseonUnsplash
"""
--------------------------------------------------------------------------------


Post 96
ID: https://www.asyncapi.com/blog/january-2021-at-asyncapi?utm_source=rss
Title: January 2021 at AsyncAPI
Link: https://www.asyncapi.com/blog/january-2021-at-asyncapi?utm_source=rss
Summary: I always thought January is a month of a slow start of a new year. I could not have been more wrong. No time to rest, no slow down here.
Content:
"""
A new year always comes with New Year's resolution, right? Folks fromBump.shcame up with the best idea you could get this year. Don't you dare to fail this time😃Foundation and open governance modelAs part of recentlyannouncedpartnership with Postman, most core AsyncAPI maintainers joined Postman as employees. This change made it clear that now it is even more important what we planned in the past.AsyncAPI must go into a "neutral ground" aka independent foundation that, among other things, will take over the AsyncAPI intellectual property.Joining a foundation also means setting up an open governance model to ensure a single company's lack of dominance over the specification and its tools.As communicated during our public meetings on2nd of Februaryor19th of January, or our officialTwitter account, Fran and I treat this topic as priority number 1.At the moment, we are trying to figure out a governance model that:is as democratic as possiblesupports asynchronous decision-making processgives power to people that "work", not companies that "pay". In other words, it gives equal power to both, individual and corporate contributorsNow we spend a lot of time reading and reaching out to similar communities that went this path and know what booby traps to avoid to stay healthy. We hope to share something more concrete in the next update, in March.New bronze sponsorWe kicked off this year with a new bronze sponsor. Thanks a lot to Bump.sh and their trust in the AsyncAPI Initiative, and being among the first ones adopting the AsyncAPI specification in their product.Community continues to growMylast postthat summarizes the year 2020 was pretty clear that the community's size grew a lot. Well, it is January, and we see that not much has changed. We keep growing:we went over 1k users on Slack.Join nowwe went over 1.5k followers on Twitter.Follow usto be up to date with the latest news in the projectwe went over 1.4k stars on GitHub. If you like the project,express itwe had several issues solved by the community members from different companies, including few new features. For more details, readFeature releases and community-driven changessectionLast but not least, we beat the record of people joining our public meetings🚀RapidAPI Developer SurveyRapidAPI released the results of theirdeveloper survey. Reading it at the beginning of the year is like drinking a strong coffee in the morning - you get a good kick of positive energy for the rest of the year.Spoiler alert -> number of developers using AsyncAPI in production tripled in 2020.Feature releases and community-driven changesPavel Bodiachevskiicontinues his hard work onasyncapi-java. Wait, it is finally notasyncapi-javaanymore. Thanks to a suggestion fromJames Higginbothamit is all aboutjasyncapinow. Maven, Gradle and IntelliJ plugins are not published as a preview release under official AsyncAPI accounts. Please give them a try and share your feedback.React component:showsrequired flag for required propsthanks toc-piusfromSAPwe have betterDX in Web componentthanks toViacheslav TurovskyiPlayground now showsmuch detailed errorsthanks toJorge Aguiar MartínfromLean Mind - esHTML template:CSS size decreased and introduction of Tailwind 2.0thanks toJulian SchaferCorrelationId renderingthanks toLudovic DussartfromIneatLabTypeScript NATS templateWe have anew templateavailable. You can use this template to generateNATSclient based on the AsyncAPI document for Node.js. Interesting fact: it is already using the newReact render enginefrom the AsyncAPI Generator.Next major feature is data model generationWe again invest big-time in the Generator. This time, it is all about making it super easy to generate a data model for templates, so the template developer doesn't waste much time on templating it and can focus on the template's main logic. In other words, it is all about enabling faster template development. Ourprogresslooks good, and it seems like at the end of February, we should already have something that you can start using.Feel free to share your thoughts inthisissue.Refactoring of our CI/CDGitHub Actions is what powers our CI/CD. It is a great tool that you configure through a file stored in a repository. Things are just getting more complex when you want to use them in an organization with around 40 repositories (and growing). This is not a post about our internal organizational challenges and GitHub Actions limitations, so I will not bother you with details. The most important is to share that we are managing our GitHub workflows like a pro and if you are interested in more details, contact us.So what changed that is meaningful for our community:We have two new channels in Slack workspace:#github-releases where you get information about all the releases from all the repositories#github-new-issues-prs where you get information about all new issues and PRsWhenever we have a major or a minor release in any repository, our bot automatically tweets about itAll pull requests are now tested against Linux, MacOS, and Windows. For you, this means that we fixed a lot of bugs in tests and configurations that were blocking Windows users from smooth contributionsNot used to Conventional Commits specification? now all pull requests have a dedicated check that lints your pull request titles and gives hints what you should fixYou contributed something to the JavaScript Parser, and you wonder what you have to do to see the change in the Generator? No need to wonder. Now, when we release any package, we also bump its version in all the other packages that depend on it. AsyncAPI bot is a super busy bot🤖The future of API specificationsWorking with specifications is not easy because there are many of them. How do you know when to use which one? Just look at the concept of microservices architecture. Did you think that monitoring, scaling, and tracing is a challenge? What about specifications:you need a different spec for your backend that exposes GraphQL API to your frontendyou need another spec to describe how a user can interact with your service using asynchronous communicationyou need a different spec to define how a user can interact with your service with RESTWhat about specs for describing your data model? What about if you use RPC and Protobuf? What if you use Avro? or maybe you only use JSON Schema.Why do you have to define the same things over and over using different specs...Something went wrong down the road, and we need to do something to save the chicken.Watch Fran's presentation on the future of API specification. And don't stop there. We don't want only to admit we know about the problem and expect someone solves it. We want to fix it. Join us!Public meetingsFor notes and links to recordings, look into the below references:Jan 5 2021Jan 19 2021Spoiler alert -> leading topic during the meetings wasthe status of AsyncAPI.Next meeting is scheduled forFeb 16 2021for8AM UTC. Feel free to suggest a topic or such join to say hello.Google Summer of CodeThis month we want to apply forGoogle Summer of Code. We found two volunteers that agreed to mentor participants to work on some good stuff for the AsyncAPI tooling space. January was when we collected all the possible ideas that we would work on together with students. Thelist of ideasis completed. There are many good proposals there, and most of them won't make it to the event, so feel free to let us know if you want to work on them under the AsyncAPI umbrella.Good readAsyncAPI and OpenAPI: an API Modeling ApproachbyAntonio GarroteAPI adoption is on the rise across all industriesHow Microcks Can Speed-Up Your AsyncAPI Adoption - Part 2byLaurent BroudouxSimplify code generation with ReactbyJonas LagoniandMaciej UrbańczykThat was an exhausting month, but looking at what is happening around the project, you feel it was worth it. Let us see what February brings.Photo byNicolas HoizeyonUnsplash
"""
--------------------------------------------------------------------------------


Post 97
ID: https://www.asyncapi.com/blog/react-as-generator-engine?utm_source=rss
Title: Simplify code generation with React
Link: https://www.asyncapi.com/blog/react-as-generator-engine?utm_source=rss
Summary: React permanently changed the way how developers write web-apps. Personally, we love React and knew it would solve many pain points we faced with Nunjucks. Therefore in the last cycle we integrated it
Content:
"""
React permanently changed the way how developers write web-apps. Personally, we love React and knew it would solve many pain points we faced with Nunjucks. Therefore in the lastcyclewe integrated it as a template rendering engine into ourGenerator. This post is a short introduction for developers who write or plan to write templates for AsyncAPI specification using React. It also includes a comparison with the default Nunjucks renderer.Getting startedYour React template requires@asyncapi/generator-react-sdkas a dependency. You need it to access theFilecomponent required as a root component responsible for rendering a file. Furthermore, it provides some common components to make your development easier, likeTextorIndent.Let's consider a basic React template file as the one below calledMyTemplate.js:1import{ File, Text }from"@asyncapi/generator-react-sdk";23exportdefaultfunction({ asyncapi, params, originalAsyncAPI }){4return(5<Filename="asyncapi.md">6<Text>Some text that should render as is</Text>7</File>8);9}The exported default function returns theFilecomponent as a root component that theGeneratoruses to figure out what file it should generate. In the example above, we overwrite the default functionality of saving the file asMyTemplate.js, and we setasyncapi.mdas the filename. Using theTextcomponent, we specify what content should be rendered inside the file. The content of the resulting file is:Some text that should render as is\n. Notice the\ncharacter at the end. It is automatically added after theTextcomponent.For further information about components and their props, see theGenerator React SDK.TheGeneratordoesn't use React renderer by default. You need to specify in the template configuration that your template is based on React. For that, change therendererfield ofgeneratorobject inside the template'spackage.jsonfile:1{2...3"generator": {4"renderer":"react",5...6}7}You can find more information about the Generator configurationhere.How it worksThe process of creating content from React components consists of two steps: transpile and render.The SDK has a custom transpiler which ensures that any directory in template'stemplatefolder are transpiled usingRollup. Rollup helps bundling all dependencies and transpile them into CommonJS modules. This is required because this library will be used through NodeJS (by AsyncAPI Generator) which does not understand these new modules natively and we do not want to limit the developer in which syntax they prefer nor how they want to separate code.Also, SDK has its own reconciler. It traverses through each element in the template structure and transforms it into a pure string. Propchildrenis always converted to a regular string and stored in thechildrenContentprop in each component. Check the below example, to see how it works. In addition, you can also see how to apply the composition to templates using components:1import{ Text, Indent, IndentationTypes, render }from'@asyncapi/generator-react-sdk';23classClassComponentextendsReact.Component{4constructor(props){5super(props);6}78render(){9// In `childrenContent` prop is stored `text wrapped by custom component\n\n`.10// The content of the `children` prop is transformed to string and saved to the `childrenContent` prop.11returnthis.props.childrenContent;12}13}1415functionFunctionComponent(){16return(17<Indentsize={3}type={IndentationTypes.TABS}>18indented text19<ClassComponent>20<TextnewLines={2}>21text wrapped by custom component22</Text>23</ClassComponent>24</Indent>25);26}2728// content will be `\t\t\tindented text text wrapped by custom component\n\n`29constcontent = render(<FunctionComponent/>);There are some restrictions:React hooks feature is not allowed.HTML tags are not supported.React internal components likeFragments,Suspense, and others are skipped.Comparison with NunjucksThe AsyncAPI generator still usesNunjucksas a default render engine. It's a templating language, heavily focused on string literals, filters (similar to bash pipes), and partials called macros.The next sections compare how you can accomplish certain things in Nunjucks and React. For more complex examples, see thetemplate-for-generator-templatesrepository with examples based on React and compare those withnunjucksbranch.Creating reusable partsIt may sound obvious, but when writing any code, even a template, a programmer wants to create reusable parts that separate repeating logic.In Nunjucks, you can reuse parts of the template usingmacros, in React, usingcomponents. Imagine that you are writing a template that produces Markdown content. You need to create a reusable macro/component that renders a list from an array of strings.Using Nunjucks you can write the code below:1{% macro list(data, type ="-") %}2{% for item in data %}3{{type}} {{item}}4{% endfor %}5{% endmacro %}67{% from"partials/list.njk"import list %}8{{ list(["one","two","three"]) }}Using React you can write the code below:1functionList({ list = [],type="-"}){2returnlist.map(item=>`${type}${item}\n`);3}45// use `List` component in another component6exportfunctionSimpleList(){7return(8<Listlist={["one", "two", "three"]} />9);10}Looking at both examples we see that in Nujucks we operate on string literals, it means that when passing data to a macro, you always need to know what type of data the macro takes. In React we operate on JS objects/variables. By this, your IDE should always inform you what value, of what type, you must pass to component. Additionally, you must place Nunjucks's macro inside thepartialsfolder of the template. Using React, you can put your components wherever you want.Using third party packagesUsing helper functions from third-party packages, in Nunjucks you must apply them asfilters. For example, you want to use one function fromUnderscore.stringlibrary likecleanDiacritics, which replaces diacritic characters with closest ASCII equivalents. To do this, you must create a function insidefiltersfolder to convert the function to Nunjucks's filter:1// filters/cleanDiacritics.js2constcleanDiacritics= require('underscore.string/cleanDiacritics');3constfilter= module.exports;4filter.cleanDiacritics= cleanDiacritics;And then you can use this function inside your template/macro:{{Urbańczyk| cleanDiacritics }}# will be UrbanczykThe main problem with this solution is that it creates an unnecessary boilerplate - you must create a function in a separate file. Another problem is that you operate on the name of this helper function which means you must always remember what filters you have included in your template.In opposite, in React you can useUnderscore.stringdirectly in your template:1importcleanDiacriticsfrom'underscore.string/cleanDiacritics';23functionMyComponent(){4returncleanDiacritics('Urbańczyk');// will be Urbanczyk5}It is worth mentioning that when using packages in this way, you always operate on the reference to the function, not on its name, so you know what functions you have in the file's scope.Cons & ProsLike any solution, React has its advantages as well as disadvantages.AdvantagesUsing React, you use JS directly. You don't need to learn custom Nunjuck's syntax, only how React works under the hood.It provides better debugging functionality that is not possible with Nunjucks.It provides better error stack traces.Better tools support development. You write templates in JavaScript, you use a reference to functions/variables, and therefore your IDE can tell you what you can use in a given scope.Provides better support for separating code into more manageable chunks/components. You don't need to createpartialsfolder. You can create React component wherever you want, also next to the template's source code.You can easily test your components. It is difficult with Nunjucks. You can split template file into separate chunks and test them in separate test cases.DisadvantagesCommon pain when writing templates with React is related to indentations and new lines. However, we have several helpers in SDK to make your life easier, likeIndentorTextcomponents.Some people don't like to mix logic inside template files, so probably React won't be friendly for them.HTML tags at the moment are not supported. The developer must write them as a string literal, likehere.ResourcesWe use React render engine already in three official AsyncAPI templates:template-for-generator-templatestemplate showcases features ofthe AsyncAPI Generator, including the React renderer. It shows how to write templates, reusable parts (components), what are the recommended patterns. It has simple and complex examples. You can also check how the same things could be done using Nunjucks inthisbranch.markdown-templateis written using React. It generates documentation into a Markdown file.ts-nats-templateis re-written using React to generate a TypeScript NATS client.If you want to check the source code of React renderer, go to theofficial repository.SummaryThere is a long way ahead of us to stabilize React as a render engine. We know about problems that make it unpleasant to write templates using React, such as indents or new lines, but we will work on that. Additionally, we have a couple of improvements on our list that will allow things likeFile Templatesto be simplified in the Generator. We also plan to supportTypeScript.We are waiting for your feedback.Happy coding!Cover photo is fromDrunken Mastermovie.
"""
--------------------------------------------------------------------------------


Post 98
ID: https://www.asyncapi.com/blog/microcks-asyncapi-part2?utm_source=rss
Title: How Microcks Can Speed-Up Your AsyncAPI Adoption - Part 2
Link: https://www.asyncapi.com/blog/microcks-asyncapi-part2?utm_source=rss
Summary: On our first AsyncAPI blog post we have introduced Microcks 1.0 General Availability (GA) as a unique milestone for mocking and testing event-driven API like any other APIs through the support of Asyn
Content:
"""
On ourfirst AsyncAPI blog postwe have introducedMicrocks 1.0 General Availability (GA)as a unique milestone for mocking and testing event-driven API like any other APIs through the support of AsyncAPI specification.In case you missed it, we have already releasedversion 1.1.0in the meantime. This release includes some nice enhancements related to the topic of the day:Microcks + AsyncAPI use cases using Apache Kafka. This post will show you how Microcks is leveraging the AsyncAPI specification on Kafka in a very pragmatic and powerful approach: way beyond documentation or code generation! We will also go through the different business use-cases implemented by users integrating Microcks in their asynchronous API toolchain.When we are talking about Kafka we mean all Kafka distributions translated intothe choice is yours: from vanilla Apache upstream distribution, to enterprise products and also cloud providers’ managed distributions!By the way, we will be happy to have some QAcontributors and reportson more brokers and AsyncAPI supported protocols😉Before diving into AsyncAPI on Apache Kafka, let first see why simulating producers is a key project success factor.Why simulating producers is a key project success factor?As good developers, we are lazy - in a very good way😉- and hate to restart from scratch our beautiful code implementations due to misunderstanding with Product Owners. However, nowadays Product Owners adopted and love theFail-Fast Principle. We can't rely on functional implementations to start beta testing with consumers, we should fail fast and make them change requirements before we start implementation.Apart from generating frustrations, this above situation is also very inefficient from a cost and time to market point of view for the organization.The contract-first approach is a wonderful way to create strong and efficient agreements between functional / business / product owners and developers! But it represents only a partial answer to the above situationTo avoid unnecessary work from developers and speed-up feedback gathering from consumers, simulation is the second part of the answer. That is why Microck's first use case and the killer feature is mocking!These are some of the reasons why the way to do mocking with Microcks is highly scalable:We rely 100% on Product Owners contractsWe rely 100% on standards and specifications to describe contractsWe automatically generate all APIs mocks from contracts: no code!We publish APIs mocks like real implementations using specifications examplesWe centralize all contracts and are the single point of trustWe are always in sync with your repositories: no drift anymore!We provide sandbox at scale. You can heavily stress tests your business rules. Remember, we are Kubernetes-native!This is why Microcks is the ultimate way to test, iterate and speed-up your APIs validations before asking developers to code the real implementation! And this certainly applies to asynchronous API on Kafka too: thanks toAsyncAPI specification.Now let’s start with first feature: mocking asynchronous API.Mocking asynchronous API on top of Apache KafkaThis is how Microcks value proposition of accelerating Kafka asynchronous API simulation looks like:In a very pragmatic approach, Microcks uses your AsyncAPI specification as the source of truth for your simulation. As soon as it is imported into Microcks, it manages to create a topic for your API version on the connected Kafka broker and starts publishing mock messages. Messages are published at a configured frequency and thus consumers immediately start receiving event messages as if it is published by a real application. Thanks to Microcks’message templatingyou can also easily include dynamic content in the sample messages.Mocking event-driven architecture using Microcks is a game-changer as you do not need to write code nor set up complex infrastructure! Your consumers can receive messages in the minute. Testing some changes is just one commit away. You update the AsyncAPI specification in the Git repository and Microcks will take care of updating everything! It's even capable of providing and managing the Kafka infrastructure thanks to the excellentStrimzi.iooperator if you wish! See ourEverything managed by Microcksdeployment option🚀Our second feature is testing or how to make your delivery lifecycle reliable.How to make your delivery lifecycle reliable?As the number of event producers and subscribers is exploding, managing changes and taking care of versioning compatibility is essential. And what about checking that business rules implying event triggering are correctly implemented? The fact it produces syntactically correct events and all this in a fully automated way based on each change and new commit in your source code repository?Again this is all provided by Microcks thanks to its capability to interoperate with your CI/CD pipeline using our plugins forJenkins,Tektonorany other CI pipeline technology like GitLab. You'll typically use these plugins to trigger a Kafka test in Microcks.In Microcks, testing Kafka endpoints means connecting to a remote Kafka topic on an existing broker in the organization, listening for incoming messages, and checking that received messages are valid against the event-based API schema that is referenced in your source of truth: the AsyncAPI specification. You can find further technical details on the blog postmocking and testing Apache Kafka API using Microcks.Testing of event-driven architecture is no longer a nightmare with Microcks! Microcks can connect to the Kafka brokers in your organization and tell you if the received messages are valid according to your specification. No drifting risks anymore or way to introduce regression in production! You'll drive and control everything from your pipeline.What are the business use-cases of AsyncAPI? Where can you use Microcks as an essential part of your toolchain?Business use-cases of AsyncAPIAs said before, event-driven and asynchronous APIs are becoming mainstream because we truly understand the decoupling level - and thus power and agility - it brings within our products. We see the need for asynchronous APIs and Apache Kafka's presence as the de facto standard for message brokering - everywhere.In every business vertical: to decouple a recording action (registration, purchase, like) to a marketing reaction (CRM update, behavioral analysis, marketing notification, renewal process management, etc...)In Governmental organizations: to synchronize complex and partitioned repositories using master data management and staging pipelines techniquesIn Financial Services: to streamline the sharing of information between core platforms and distribution ecosystems of partners,In Industry: to enable Industry 4.0 to use IoT and become more agile to respond to market unpredictability and improve quality,Soon in every Citizen's life: to power tomorrow Smart Cities with IoT and enable smart real-time insights and decision making.These use cases come from companies using Microcks for simulating and testing their API implementation, and we are thankful to our users and community.SummaryWe are convinced that cutting edge developers understand the purpose, usages, and efficiency of asynchronous mechanisms. To take all its advantages and especially to use an AsyncAPI contract-first approach: developers must work hand in hand with software architects, business/product owners within the enterprise. In our humble opinion, this is clearly a strong point of attention to improve collaboration between enterprise silos and take the quintessence of AsyncAPI specification for a contract-first approach using Microcks as the ultimate tooling for mocking and testing purposes. Please read ourprevious blog post on this topicand share it with your software architects😉We hope these two Microcks features - mocking and testing - and application use-cases are clear and you now better understand our value proposition. Microcks proposes a very pragmatic and powerful usage of AsyncAPI specification: way beyond documentation or code generation! It allows you to speed-up and makes your delivery of Kafka event-driven architectures reliable.The roadmap ahead is also full of exciting new features we are looking forward to:Continuing to make AsyncAPI full potential bloom through implementing multiple schema format supports - like Apache Avro - andadding examples in the spec,Taking advantage of multiple protocol binding capabilities, releasing very soon aMQTT implementationto support our users and prospects on the IoT landscape,Solidifying an initiative we started a long time ago about a shared repository of simulation and test suites for standards or products APIs...We are open and you can help make Microcks an even greater tool! Please spread the word, send us some love throughGitHub stars, follow us onTwitteror join our chat room onZulip.
"""
--------------------------------------------------------------------------------


Post 99
ID: https://www.asyncapi.com/blog/2020-summary?utm_source=rss
Title: Awesome 2020 and What Can Get Better In 2021
Link: https://www.asyncapi.com/blog/2020-summary?utm_source=rss
Summary: Fuck you COVID-19, AsyncAPI Community is stronger than you think. See the growth of AsyncAPI in 2020 in hard numbers. How we compare to 2019?
Content:
"""
🖕COVID-19AsyncAPI Community is stronger than you think.See the growth of AsyncAPI in 2020 in hard numbers. How do we compare to 2019?This post is based on quantitative data using metrics from different platforms where AsyncAPI is present. I collected this data between 15-17.12, so they are already a bit larger by now. I'll try to confront our qualitative knowledge, what we know from discussions with others, and our observations.This post is not 100% just in numbers and analytics. It is also a summary of all the important things that happened to the project this year.Important momentsOur first everAsyncAPI Online Conference. This pandemic edition turned out to be a very successful event that powered us up for the rest of the yearWe took active part inHacktoberfestas maintainers and increased the number of contributions to the projectAsyncAPI was featured in InfoQ'sSoftware Architecture and Design InfoQ Trends Report—April 2020that directly brought 1963 new users to the AsyncAPI websiteAsyncAPI showed up onTechnology Radarthat took 1051 users directly to the AsyncAPI websiteOur two core tools reached their first major releaseJavaScript ParserGeneratorAll those moments lead us to the most important one: thepartnership with Postman.Slacktl;dr AsyncAPI community activity onour Slack workspacedoubled!Figure 1: Slack active members weeklyNumbers getting highI don't think the below tables require any introduction.January 2019January 2020December 2020Messages posted278825388(+22600)76609(+51221)Number of members159432(+273)888(+456)More members means higher activity😅20192020Weekly members activity45 average42 median81 average76 medianMost present companiesI was also super curious to check out where our members are coming from. The only way to do it was by checking the domain of their emails used during registration. Yes, this is not 100% accurate. Not all people use company emails in open source. It is visible in data; half of the users have thegmail.comdomain. Nevertheless, the result of my investigation is pretty accurate with our knowledge. The ones that have more than three representants:mulesoft.compostman.comredhat.comsap.comsmartbear.comsolace.comtibco.comworldpay.comSome of these companies sponsored our work in 2020. The ones that didn't... don't worry, we'll contact you😉In 2021, we want to go into a neutral ground (i.e., joining a foundation). There'll be no more excuses.What's next with SlackSlack hard numbers confirm what we see in Slack every day. Luckily, even though the activity doubled, the number of active users that help out in the workspace also grew🙏With the recently announced Postman partnership, I do not worry about how we'll handle 2021.Next year we need to address two critical topics:our community grows but the knowledge that we all share in Slack is lost. We use a free version of Slack, and therefore, only the last 10k messages are available. In 2021, we need to make a strong decision on what's next. Should we spend some budget on Slack commercial subscriptions, or maybe we should find a better tool?we need to reorganize our channels, be a bit more granular, and target suitable community groups. We'll bother you to get your feedback once we start this reorganization.LinkedInLinkedIngrew a lot this year. We won't be able to compare this year with the previous one because... this is not a place where I want to discuss the experience you get with LinkedIn.Followers and impressionsAt the moment, we have 757 followers.FollowersLikesImpressions61157 from payed marketing125380095People that like our updates are most likely the ones that click on links. 75% (947) of likes converted into visits to ourwebsite. We took this data from Google Analytics, and we know that in 2019 we had only 137 visits from LinkedIn.The most performing update was the one about thepartnership with Postman. It is LinkedIn, and it is all about business.The chart below shows that data match reality. The highest peak in late March is related to our firstAsyncAPI Online Conference. The rise of sponsored traffic is connected to our post-conference activities using the money we got from conference sponsors.Figure 2: Impressions to updates in 2020Sponsored marketingThis year we explored paid adverts on LinkedIn. We had some money left from sponsors of our AsyncAPI conference but zero experience with LinkedIn.Luckily, we have a fantastic community. One of the community members,Dan Weese, helped us here. He did not only put us in contact with marketing expert,Charles Serdoubut also covered his wages. Thank you, Dan🙏This way, we covered only LinkedIn costs paying $1 074,08Figure 3: Followers growth in 2020Marketing was focused on increasing the number of followers. Comparing the results of sponsored marketing with followers' organic growth, one could say LinkedIn marketing was not so good. It was very good though. LinkedIn is just super expensive and charged a lot for every new follower.We should give it a second chance in 2021, but this time with sponsored updates.What's next with LinkedInThe numbers show it is worth investing in the channel. We can reach a lot of people that are not reachable on other channels. So we will for sure continue what we do now, especially that this work doesn't require too much extra effort from us.I feel that probably some traffic coming from LinkedIn to our website is not adequately tracked in Google Analytics. Data from LinkedIn say we should notice 2x947 traffic. It might be related to people blocking tracking tools, and we will have to make sure to use other tracking methods, like putting identifiers in the links.Google AnalyticsWe use Google Analytics onAsyncAPI websitebecause we want to understand what content is most valuable for you, and we want to learn how the interest is growing.Traffic got much higherThe interest is growing by a lot! Our website handles it well with the support ofNetlify, which is free for open-source projects.20192020Unique users visits27 09080 399(+53 309)Number of sessions50 405142 229(+91 824)Unique pageviews143 059348 131(+205 172)Top referring channelsIf we look closer to the statistics to check out how people learn about AsyncAPI, referral channels keep pretty much the same share of the pie, just numbers grow.Figure 4: Top channels in 2019Figure 5: Top channels in 2020In 2019, the most viral was the information about AsyncAPI 2.0 release, while in 2020, the blog post about how weautomated releaseson AsyncAPI packages to speed up work.Top blog postsAsyncAPI blogis not just for Fran and me. It is for the AsyncAPI Community. Anyone can share knowledge, experience, and showcase their work there. Justlet usknow what you want to write about.What is the benefit of writing/republishing on the AsyncAPI blog? Visibility among the AsyncAPI community plus our activities to make your work go viral. Just look at the below table to see our top 3 viral posts.PostUnique pageviewsAuthorFull automation of release to NPM and Docker Hub with GitHub Actions and Conventional Commits(March 2020)9 318Lukasz GornickiAsyncAPI Code Generation: Microservices Using Spring Cloud Stream(June 2020)8 508Marc DiPasqualeAn API Strategist Explores Event-Driven APIs(May 2019)3 451Emmelyn WangWhat's next with the websiteWe need to enable Google Search Console and connect with our Google Analytics account. It will increase our knowledge about how people google before they get into the AsyncAPI website. Knowing how people find us, we can focus on more content related to search queries.We need more posts on our blog. 2020 shows this is something that increases traffic. We already welcomed many guest bloggers, and youcan becomeone of our writers too.TwitterBy the time I gathered data for this blog post, we had 1433 followers on Twitter. 876 followers joined us in 2020. It is a large increase since the account creation back in March 2019.Paid marketingWe used money from our AsyncAPI conference sponsors to advertise the conference on Twitter.We spent $924,14 on this activity and when we compare it to organic impressions over this year, result is just great:Organic (549 tweets)Promoted (3! tweets)Impressions570 466525 329Retweets1 42977Likes2 507567URLs clicks2 7592 283Follows435Nothing is black and white, even Twitter performance. One could say:leave organic growth and invest in paid marketingWe do not treat Twitter as just a marketing channel. It is our window to the community. We use it to share updates, short information and engage directly with our community members. We should continue to work on organic growth. It converted only into 2 160 sessions to the AsyncAPI website, which is not much if we compare it with 2 283 sessions opened with the AsyncAPI Conference website using promoted content. We do not want to close the window, though.It's all about keeping the balance⚖️Top tweetsWe did some research on the most impressive and engaging tweets.TweetImpressions15k14k9kThere is only one tweet that shows up in the top 3 for each category.TweetEngagements428259253(not all those memes were lame after all)It is pretty clear that what you liked the most this year is that we are hiring💪We are still hiring!What's next with TwitterWe should get more insights into how Twitter activity converts into visits to our website. Twitter offers something calledconversion trackingwhich seems like a perfect fit, and this is something we will enable for next year.Paid marketing on Twitter is useful, so we will continue using it for important events.GitHubWe notice growing traffic inour GitHub organizationlike on other channels.Most popular repositoriesOur most popular repositories contain the AsyncAPI specification and the AsyncAPI Generator that the community can use to generate documentation and code.The asyncapi repositorythat had 245 stars in 2019 jumped to 1361. The peak you see on the diagram was caused by us putting the link to the asyncapi repository onHacker News.Figure 6: GitHub stars growth in asyncapi repositoryThe generator repositorygrew from 62 to 198. The path got steeper this year. This popularity is covered with our recent development activities in the project.Figure 7: GitHub stars growth in generator repositoryTraffic growthAll numbers went up😅The growth of contributors was not organic but driven by our activities in theHacktoberfestevent.20192020Contributors76119Commits1.5k3.5kPull requests (opened/closed)399/39799% closed1200/117597% closedIssues (opened/closed)322/28789% closed587/40168% closedWe're closing fewer issues. This number got worse than last year because we freeze progress on the asyncapi repository, and the last few months did not continue any efforts towards specification 2.1 and 3.0 releases. The reason was pretty simple; we were involved in discussions with many players and planning the next step forward to scale up in 2021. It would not be fair with the AsyncAPI community to work on the next specification versions, with the current government process, knowing we preparepartnership with Postman.What's next with GitHubWe are doing well on GitHub, and so far, I don't see any improvements other than the further automation that we have in plans to handle even more traffic next year.npmThe majority of our tools are written in JavaScript/TypeScript, and we host them on Node Package Manager(npm)Top packagesOur most important packages arethe Generatorandthe Parser. Below you can see how downloads of these packages increased.20192020Generator21 536134 224Parser (published May 2019)18 591173 286The change in numbers is so huge that I checked them twice to make sure I'm not wrong.Figure 8: Popularity of all packages on npmIf you know the package from the above list had some different names over the year, you can check it withnpm statproject. For example, late in the year, we moved the React component under@asyncapi, and under the old name, it had 56 520 downloads. Next year won't be so messy.What's next with npmThis year we introduced@asyncapiscope on npm and switched all packages to it. You could see some differences in numbers in previous sections because for the generator and parser I manually counted the sum of downloads of a package under different names.There are still many downloads of the parser and generator using old names. It means we still have many people that do not migrate to new releases. Next year we could write a blog post that summarizes the differences between old tools and their latest versions. It could be linked to the deprecation notice.YouTubeTheAsyncAPI YouTube channelhad a massive increase in the traffic.Watch time goes crazyWe felt it might be significant because of the AsyncAPI conference, but we never expected a 6000% growth of the watch time!20192020Views5278 678Watch time29.9h1 850.1hSubscribers35390Most popular videosUndeniably the most popular this year was our first AsyncAPI online conference.ViewsAuthorAsyncAPI Online Conference4 123AsyncAPI CommunityAsyncAPI SIG meeting 37 (December 8, 2020) - SPECIAL EDITION!542AsyncAPI CommunityEvent-Based API Patterns and Practices354James HigginbothamIn case you missed our conference, watch the recording and stay tuned for the next conference in 2021.What's next with YouTubeI think it is the right moment to work on the channels' landing page. We could use it to promote the most valuable content.Open CollectiveWe earned and spent lots of money this year🤑Huge applause👏to allour sponsors!We enabled theGitHub sponsoringthis year, but still, 99% of funds go through theOpen Collective.SourceAmountBalanceAsyncAPI Online Conference$983 Swags for participants$359,10WWC donation$1 074,08 LinkedIn marketing$924,14 Twitter marketing$66,54 Zoom account$0AsyncAPI Initiative$52 371 Maintanance$3 750JSON Schema$1 493,64In 2021 we continue using Open Collective. Even though we startedpartnership with Postmanto cover many maintenance costs, there are other costs. Even once we join some foundation next year, we still need to collect money to run the project.Ultimate questions - how many people use the spec?We don't know.It is the area where we have no specific metrics. We see the growth in tools' adoption, but not everybody uses open source tools. Many companies prefer to develop those in-house.From observations, we know that number of users that use specification grows:More and more companies seek integration with the specification. From unofficial discussions, we know their customers ask them about AsyncAPI supportThe metrics from this blog post clearly show adoption and interest growthIt is a specification we are talking about here. There is no way to measure how many AsyncAPI files were created worldwide. At least there was no way to do it in 2020. We'll tryone ideaof ours in 2021. It looks like in the 2021 summary, we could provide some hard numbers on the subject🤞Final wordsMost important conclusion: If the AsyncAPI conference brought so much activity, it is evident that in 2021 we must organize another great AsyncAPI event.Thanks for being with us in 2020, and stay with us for 2021 as it will be epic!I planned to include a list of all the AsyncAPI Heroes for 2020, but I was afraid I could miss someone very important and that the list would be very subjective. I hope it is clear, though, that this project is where it is, thanks to many guardian angels out there that help us out.Photo byImmo WegmannonUnsplash
"""
--------------------------------------------------------------------------------


Post 100
ID: https://www.asyncapi.com/blog/asyncapi-partners-with-postman?utm_source=rss
Title: AsyncAPI partners with Postman to boost development of Asynchronous APIs
Link: https://www.asyncapi.com/blog/asyncapi-partners-with-postman?utm_source=rss
Summary: I'm proud and honored to let you know that we're partnering with Postman to boost the development of Asynchronous APIs to a new level.
Content:
"""
I'm proud and honored to let you know that we're partnering withPostmanto boost the development of Asynchronous APIs to a new level🚀Since the very beginning, I knew the duty we had at hand was challenging. And still is! The specification was just the trigger of a snowball effect. What's the spec for if you can't do anything with it? Tooling is as important as the specification. However, tooling is a number of times more complex than the specification. We engineers don't want to abandon our favorite programming language and framework, therefore, it's AsyncAPI's responsibility to integrate with the existing tools in the market.The specification (and tools) should work for the user, not the other way around.Partnering with Postman allows us to boost the development of more and better tools to help engineers create and maintain Asynchronous APIs while using their favorite programming languages and frameworks.Our goal is to make Asynchronous APIs as successful and mature as REST APIs.We are aware this is a long journey but, with Postman's help, we'll be able to grow the team and continue working on the AsyncAPI specification and all the necessary tools to create a delightful developer experience. The AsyncAPI Initiative team is fully committed to open source software (OSS), and the partnership with Postman will help us keep doing our job with freedom and independence.Next stepsWe want to make the AsyncAPI Initiative a neutral and independent place for collaborating on defining the future of Asynchronous APIs. Next step for us is to host the project in a neutral foundation to guarantee the long-term success of the initiative. We're currently in conversations with different actors of the OSS world to make sure the initiative remains independent.Also, we want you to work with us.We are hiringat Postman to work full-time on AsyncAPI. In the first half of 2021, we'll open a bunch of positions, including Software Engineers, Graphic Designers, Technical Writers, and more. Make sure you don't miss them!Before I finish, I would love to thankKin LaneandAbhinav Asthanafor being so supportive. And of course, a huge shout out toŁukasz GornickiandEva Morcillofor their tireless support. None of these would be possible without their help.There's a bright future ahead for Asynchronous APIs. 2021 will be the year of AsyncAPI, the year of you, our beloved open-source community.Cheers!🍻
"""
--------------------------------------------------------------------------------


Post 101
ID: https://www.asyncapi.com/blog/status-update-47-20?utm_source=rss
Title: Happy Birthday AsyncAPI (week 47, 2020)
Link: https://www.asyncapi.com/blog/status-update-47-20?utm_source=rss
Summary: Happy Birthday AsyncAPI

On 18.11.2017 Fran Mendez exclaimed "Eureka” and created AsyncAPI. The story is more complicated than that, but it is not a time for a history lesson, so let us keep it simple
Content:
"""
Happy Birthday AsyncAPIOn 18.11.2017 Fran Mendez exclaimed "Eureka” and created AsyncAPI. The story is more complicated than that, but it is not a time for a history lesson, so let us keep it simple😄Yes, AsyncAPI is 3 years old🍻This is whattheysay about kids at age 3:Around this age, your baby loves to move and will probably start rolling from tummy to back. When you give him tummy time, he might lift his head high or push up on his hands. He might even sit up with some support behind and on each side of his body.That is about it. We do not want to just sit, relax, and enjoy lunch anymore. ** It's time for us to start moving, exploring, and not stopping but making a stand in the industry**. We have great years ahead of us. Trust me. Soon you'll learn that work on AsyncAPI will lift off to another level.Join us during these strange pandemic times in asynchronous remote celebration, whenever and wherever you can.Generator 1.0 And Other GoodiesFollowing the recent1.0 release of the AsyncAPI Parserwe came to the point we could release the first major release ofthe AsyncAPI Generatortoo.Feel free to congratulate us by giving a⭐️ tothe project. This is the moment to join us and think with us about the 2.0 release and all the goodies we can add to it.Try out the project by following👇instructions:Select a Generator template:HTMLMarkdownNode.jsNode.js WebSocketsJava Spring Cloud StreamJava Spring BootPython PahonpmDocker1npm install -g @asyncapi/cli2asyncapigeneratefromTemplate https://bit.ly/asyncapi @asyncapi/html-template -o exampleGenerator GitHub Action 1.0Yes, our officialGitHub Action for Generatoralready uses the latest Generator and is released under v1.1-name:GeneratingHTMLfrommyAsyncAPIdocument2uses:asyncapi/github-action-for-generator@v13with:4template:'@asyncapi/html-template@0.15.4'#In case of template from npm, because of @ it must be in quotes5filepath:docs/api/my-asyncapi.yml6parameters:baseHref=/test-experiment/sidebarOrganization=byTags#space separated list of key/values7output:generated-htmlThe AsyncAPI Playgroundis up to date with the latest generator.Writing Own Generator Template Ain't EasyWriting a template compatible with the AsyncAPI Generator is not an easy task that you can complete in one day. To write a template that generates docs or code, you need to have not only decent knowledge about AsyncAPI specification but also the features of the Generator:How do I extract data from the spec file?What template engine powers Generator and how to use it?How can I add optional features to the template?There is a lot of it. We wanted to make it easy for you. We created aGitHub Templatethat showcases all features available in the Generator. It contains:A template that generates class diagram showing relations between schemasDetailed readme which explains all the features and where are they used in the templateTo try out the template, run👇commands:1# Install the AsyncAPI Generator if you do not have it yet2npminstall-g@asyncapi/generator34# Run generation5aghttps://raw.githubusercontent.com/asyncapi/generator/v1.0.1/test/docs/dummy.ymlhttps://github.com/asyncapi/template-for-generator-templates-ooutput67# Open the result of the generation8openoutput/index.htmlFigure 1: Schema consumed by the template and the resulting diagramReact Component and Web ComponentNew Npm ScopeSince the 0.16.2 release, we changed the npm scope of the component and now use the officialasyncapione. That means you should update your dependencies and from now on use@asyncapi/react-component.Web ComponentSince the 0.17.5 release, we are now automatically publishing also the @asyncapi/web-component to npm. Given that it depends on the React component, it will always follow the same version number. This is all possible thanks to work done by amazingHesyar Uzuner,Claude Gex,Maciej Urbańczyk.Now it should be easier for you to use this component in non-React projects. That is, for example, how you would use it in a plain HTML:1<!DOCTYPEhtml>2<html>34<head>5<metacharset="utf-8">6<title>AsyncAPI Web Component Demo</title>7<scriptsrc="https://unpkg.com/@asyncapi/web-component@0.17.5/lib/asyncapi-web-component.js"defer></script>8<script>9varschema = {10url:"https://raw.githubusercontent.com/asyncapi/asyncapi/master/examples/simple-asyncapi.yml"11};1213window.onload =function(){14document.getElementById("asyncapi").schema = schema;15}16</script>17</head>1819<body>2021<asyncapi-componentid="asyncapi"cssImportPath="https://unpkg.com/@asyncapi/react-component@0.17.5/lib/styles/fiori.css"></asyncapi-component>2223</body>2425</html>There is also a sample project where you can see how this Web component plays together with Angular.We already havesome ideason how to improve DX for the component. Try it on your own and let us know what you think.Examples RenderingSince the 0.16.0 release, the component supports examples provided in the AsyncAPI document on a Message Object level. These examples are treated with priority over others. You can try it out inthe React component playground.Figure 2: View of the AsyncAPI React playground where you can see sample AsyncAPI document with example in Message Object, and how the React component renders it.AsyncAPI Special Interest Group (SIG) open meetingThe last meeting took place on Tuesday, 10th of November, 4PM UTC. Meeting notes and recording are availablehere.The next meeting is scheduled for nextTuesday, 24th of November, 8AM UTC.We work on the agenda for the next meetinghere. At the moment, there is nothing on the agenda, so you can easily sneak your topic in.We host the meeting onZoom. Do not forget about future meetings and always have up to date invitations in your calendar by adding your email tothismailing list.Some Good Read ResourcesWhat Is AsyncAPI and How Does It Differ from OpenAPIHow Microcks Can Speed-Up Your AsyncAPI Adoption - Part 1byLaurent BroudouxIs Hacktoberfest Good For Maintainers?byLukasz GornickiCover photo byWill MyersonUnsplash
"""
--------------------------------------------------------------------------------


Post 102
ID: https://www.asyncapi.com/blog/microcks-asyncapi-part1?utm_source=rss
Title: How Microcks Can Speed-Up Your AsyncAPI Adoption - Part 1
Link: https://www.asyncapi.com/blog/microcks-asyncapi-part1?utm_source=rss
Summary: August 11th 2020 was the official announcement of Microcks 1.0.0 release and our first Microcks General Availability (GA) version to fully manage event-driven API through the support of AsyncAPI speci
Content:
"""
August 11th 2020 was the official announcement ofMicrocks 1.0.0release and our first Microcks General Availability (GA) version to fully manage event-driven API through the support ofAsyncAPIspecification.This first post explains why we decided to start this project and provides more insights.For those who don't knowMicrocksyet: it is the ultimate Open source Kubernetes Native tool for Mocking and Testing all your APIs. With Microcks, you can turn your API contract, collection or SOAP UI projects into live mocks in a few seconds. For further information, please read"Why Microcks ?".We are following theAsyncAPIspecification initiative since day one and I clearly remember how thefirst announcement back in 2017resonated within our team ! We shared the same principles: Open source and community driven... and last but not least, 100% aligned with our vision that open specifications standards likeOpenAPIis the ultimate way to move forward and perpetuate our mantra: unlock developers potential in an unpredictable and strongly innovative environment!Since then, we have been in touch with our mutual communities and strategic users to see if we all embrace the idea of adding AsyncAPI testing and mocking support within Microcks.
Microcks community was very enthusiastic by the idea and problem this integration can solve. We have helped some users on their AsyncAPI use cases to grab valuable feedback on how to manage Microcks event-driven API integration. We learned a lot from different vertical industries, including tricky IoT & Edge computing or fintech implementations.Our communities clearly validate that it makes sense to have the same tool managing all their API whatever the type, open contract definition or design tool used. This is why, today Microcks supports open standards for contract definitions and mainstream open collaborative tools:It took us a year to make, which explains why Microcks 1.0.0 release is already GA and the first tool onthis topic😉This is a major step forward as we are convinced that the transition to cloud-native applications will strongly embrace event-based and reactive architecture. Thus the need to speed-up and govern event-based API like any other services mocking using Microcks will be crucial and a key success factor for any modern and agile software developments.Microcks 1.0.0 provides a solid platform for simulating event-based API using message broker technologies likeApache Kafkaeven before the publishing component has been developed. And once developed, it is then capable to validate that all the publisher sent events will be compliant with the defined specification, automatically from a CI/CD pipeline.To demonstrate our commitment/vision and toimprove AsyncAPI specificationson our favorite topic: testing & mocking, we have launched an upstream feature request in order to provide a formal type for message examples.Please have a look atthis proposal #329and share your opinion. At the moment, it is a part ofAsyncAPI 2.1 milestone.** In the next article, we will focus on Microcks + AsyncAPI use cases. Stay tuned.**And if you can't wait for text explanataions, do not hesitate having a look at theAsyncAPI SIG Meeting #34 recordingfor full illustrations of the capabilities.😉
"""
--------------------------------------------------------------------------------


Post 103
ID: https://www.asyncapi.com/blog/hacktoberfest-summary-2020?utm_source=rss
Title: Is Hacktoberfest Good For Maintainers?
Link: https://www.asyncapi.com/blog/hacktoberfest-summary-2020?utm_source=rss
Summary: tl;dr

In October, we welcomed 26 new contributors with 70 pull requests (PRs) merged. It was an exhausting but also a fascinating experience.

Hacktoberfest Is Ok

Don't be afraid of Hacktoberfest. I
Content:
"""
tl;drIn October, we welcomed 26 new contributors with 70 pull requests (PRs) merged. It was an exhausting but also a fascinating experience.Hacktoberfest Is OkDon't be afraid ofHacktoberfest. It is an excellent event for both contributors and maintainers.There arehatersthat will tell you something different. My advice, followtruncated meanmeasure and always discard extreme opinions, especially if they call for boycotting:Finally, and most importantly, we can remember that this is how DigitalOcean treats the open source maintainer community, and stay away from their products going forwardCancel culture at its best. The fact that someone is good at programming or works at Google or Facebook doesn't make them experts in everything. Remember that celebrities are not good candidates for a role model.There are no perfect events; there are no best solutions. There is always a place for improvement, but it should be followed by open, civilized discussion.Let me conclude by saying that I hope the "harm to the open source made by DigitalOcean" is not as significant as the harm that such hate does to open source by discouraging new open-source contributors. However, this is just speculation. How can I consider any of these things harmful if I did not conduct scientific research? I can only confirm that Hacktoberfest did not harmAsyncAPI Initiative. On the contrary, it was pretty neat.SpamDuring the entire event, we had only two spam PRs. I can imagine that a much more popular and known project might have had more. Nevertheless, adding theinvalidlabel and closing a PR is a super simple operation, three clicks.The definition of spam heavily depends on maintainers. For example,thisis not invalid to me, because I don't think of grammar as "subjective nits".Why We Participated in HacktoberfestOur intentions were pretty clear from the very beginning. As I wrote in theprevious post, we wanted to:PromoteAsyncAPI Initiativeas a place where we work not only on the AsyncAPI specification, but also lots of toolsHelp members of the broader open-source community make their first contributions in a friendly environmentMy impression is that sometimes the open-source is perceived as a kind of elite gathering.This is quite often blocking people from joining because they feel they cannot help but rather waste others' time.I was there in the past, I thought the same. It's just another variation of the damnimpostor syndrome. You can always help, no matter what your experience is.Start small. Don't start with tasks that can be overwhelming. Don't throw yourself into the deep end.We wanted to help others make first baby steps in a secure and inclusive environment, with lots of patience and support.What It Takes To Have 70 PRs MergedIt is not enough to label 70 issues with thehacktoberfestlabel, sorry😃First of all, you need to be passionate about open source and dedicated to what you do. It can't just be a task that somebody assigned to you. It would help if you were prepared to treat Hacktoberfest participants as a priority. I would compare it to the onboarding process of new hires.Of course, not all participants join to stay longer, usually they just follow the  "one pull request, and I'm out of here" approach.It doesn't matter.Please don't make assumptions; assumptions are evil. Be opened, treat every contribution equally, and remember that the onboarding process is a crucial element. If you fail with the onboarding process, you fail big time at the very beginning.What We PreparedWe prepared the following materials for potential participants:Blog postabout our participationOnboarding videosthat explain how to start78 issues from more than 30 repositories and put them all in onelistwith additional information about the difficulty level or the technical area,It took me around eight workdays to do it all. The most time-consuming part was to go through all the issues, pick candidates, create new ones, and group them all in a Google Sheet.What We Did During The Event70 pull requests mean —at least— 70 reviews😅If you know your project well, it is not very time-consuming, and anyway, it is the work you have to do as a maintainer. I do not count this time as an extra Hacktoberfest effort. Of course, it can be overwhelming if this is not a standard amount of PRs that you get every month.We also hostedoffice hoursfor participants. This was fun, and we wanted to start doing live streams about AsyncAPI anyway.Last but not least, once a week, I advertised our project on the official Hacktoberfest Discord server.It looks like we do not need to do more for the next year.Was It Worth ItHell yeah, and I'm already looking forward to Hacktoberfest 2021.It was great to see so many different people interacting with the project and seeing we reached our goal.We got some new features, CI/CD cleanup in all repositories, and solved many trivial SonarCloud-reported issues that we would never found time to solve.What Made It Such a SuccessOur success was a typical return on investment.We asked all contributors to provide feedback on how they learned about us and what was the most helpful resource. 20 out of 26 responded to our request.Figure 1: Ways in which the contributors learned about AsyncAPI participating in HacktoberfestI think it is pretty clear that introducing the official Discord channel was a great idea. I personally do not like Discord because of the lack of support for threads, but better this than nothing.Figure 2: Resources helpful for contributorsSuch a simple thing as a Google Sheet with a list of issues grouped by different factors was, in the end, our best resource for contributors. I encourage you to create such a sheet for your contributors next year.Open Request to Hacktoberfest OrganizersThere is one thing that calls for an improvement for next year. Just one? Yeah, opt-in solution for projects that want to participate in Hacktoberfest was addressed during this event, and I assume it stays on.The number of projects that people can work on is overwhelming, and finding the right issue seems very difficult. Please have a look at the feedback we got from our contributors. It is enough to develop an official application where potential contributors can adequately filter out issues by technology and difficulty. In the end, it doesn't make sense for all maintainers to work on their own Google Sheets and post it on Discord. A better way would be to introduce an app for all.Hall Of FameBelow you can find a list of all contributors that joined AsyncAPI during Hacktoberfest and contributed their time to the project. The list is sorted alphabetically, including the number of PRs created by this contributor.ab510 (2)anbreaker (3)Jesús Miguel Benito Calzada (1)Barbara Szwarc (8)Mitchell Sawatzky (2)Chenemi Zekeri (2)Charlie Tharas (1)Christeen Fernando (1)danielchu (4)depimomo (4)Miguel Angel Falcón Muñoz (1)Gabriel Claudino (1)Talmiz Ahmed (5)HUTCHHUTCHHUTCH (11)Jakub Iwanowski (2)João Francisco Lino Daniel (1)Jürgen B. (3)mbeuil (2)Moritz Wiesinger (1)Katrina Knight (2)Jimmy Kasprzak (3)Phil Antiporda (1)Olivier Lechevalier (6)Sanskar Patro (1)Sam (1)GrimPix (1)Cover photo byIan SchneideronUnsplash
"""
--------------------------------------------------------------------------------


Post 104
ID: https://www.asyncapi.com/blog/status-update-43-20?utm_source=rss
Title: AsyncAPI Initiative Status Update (week 43, 2020)
Link: https://www.asyncapi.com/blog/status-update-43-20?utm_source=rss
Summary: AsyncAPI JavaScript Parser 1.0.0 Is Out

I’m very proud to share that we are finally there, release 1.0.0 is out in the wild.

One month passed since the last release candidate, and no one reported an
Content:
"""
AsyncAPI JavaScript Parser 1.0.0 Is OutI’m very proud to share that we are finally there, release 1.0.0 is out in the wild.One month passed since the last release candidate, and no one reported any blockers for our first major release.AsyncAPI JavaScript Parser is an official library that validates AsyncAPI documents and returns a set of functions that make it much easier to access the document's contents. It works well both in the browser and in Node.js. We've been using it for very long in our React component to parse in the browser and in the AsyncAPI Generator to parse documents in the Node.js server and CLI.Please join us in the celebration. We do it in a typical asynchronous way. Everyone celebrates whenever they can...HTML Template ImprovementsHacktoberfest contributions brought many improvements and bug fixes. Two weeks ago, during the last status update, the HTML template version was 0.12.2, and now it is 0.15.0.PDF GenerationThe template supports now an additional parameter calledpdf. You use it to get an additional PDF file generated, next to the index.html file. In the CLI, pass-p pdf=trueto get it. Thank youTalmiz Ahmed.Change Default Name of HTML FileThe template now supports an additional parameter calledoutFilename. You use it to change the default index.html file to something different, like for example, asyncapi.html. In the CLI, pass-p outFilename=asyncapi.htmlto get it. Thank youMitchell Sawatzky.Display of Schema UIDDue to suggestions from different community members, we now display the UID of the schema. UID is displayed only if it is provided. An anonymous UID assigned by the AsyncAPI Parser to schemas without UID is not shown.Notice how it is displayed in the below example, next to the first twomixedTypeArrayproperty schemas.Java Spring Template ImprovementsOur great contributorSemen Tenischevcame back and kicked off the work on the Java template. Most important is a new feature to supportanyOfandoneOf. There are also bug fixes for enums generation and how schemas without UID are handled. The current version is 0.20.1.Hacktoberfest StatusFor us, the Hacktoberfest celebration has been a great success so far. The first day of the event started with two spam pull requests, but then...well, see for yourself:We had 24 contributorsWe merged 58 pull requests!Only around 20 issues left on ourlist. Hurry up and become our star!Generator Release Candidate 13We releasedanotherrelease candidate with several security fixes. Important to notice in this RC is that we changed the way we build the docker image. Now it doesn’t contain the generator's sources but we install Generator CLI as a global application. This means the entrypoint is not “node ./cli.js” but “ag”, just like you would use it without Docker. Also, keep in mind that this release candidate now uses the official major release of the JavaScript Parser.AsyncAPI Special Interest Group (SIG) open meetingThe last meeting took place on Tuesday, 13th of October, 4PM UTC. Meeting notes and recording are availablehere.The next meeting is scheduled for nextTuesday, 27th of October 8AM UTC.We work on the agenda for the next meetinghere. At the moment, there is nothing on the agenda so you can easily sneak your topic in.We host the meeting onZoom. Do not forget about future meetings and always have up to date invitations in your calendar by adding your email tothismailing list.Cover photo bySpaceXonUnsplash
"""
--------------------------------------------------------------------------------


Post 105
ID: https://www.asyncapi.com/blog/status-update-41-20?utm_source=rss
Title: AsyncAPI Initiative Status Update (week 41, 2020)
Link: https://www.asyncapi.com/blog/status-update-41-20?utm_source=rss
Summary: New Website

I'm super excited to share with you that last week we released a new AsyncAPI website:

On a home page, we now promote Studio more and put much more emphasis on the different ways you can
Content:
"""
New WebsiteI'm super excited to share with you that last week we releaseda new AsyncAPI website:On a home page, we now promoteStudiomore and put much more emphasis on the different ways you can engage with AsyncAPI Community,Documentation view got additional navigation per document so, for example, it is now much better to navigate through different sections ofthe specification document,The tools section is now dedicated to AsyncAPI's official tools to clarify the AsyncAPI initiative is not just the spec. Just have a look how much detailed is, for example, thegenerator view,Don't worry, all the other tools are still there, underthe Tools sectionThe cherry on the cake is a much more appealingBlog viewFran Méndezdid all this fantastic job. Well done, Bro! Sources of the website arehere. Feel free to use it as a template for your website and let us know if you need help reusing it.HacktoberfestAsyncAPI Initiative joined Hacktoberfest. We decided to join the event at the end of August when nobody even thought this would happen. The first day of Hacktoberfest felt like a false start. Because of the enormous amount of spam pull requests, some open-source community people went too far in the #cancelculture trend. They opted on Twitter for the Hacktoberfest cancelation and DigitalOcean boycott. Luckily, not everyone is a hater, and Hacktoberfest stays. Anyway, this is a topic for another post.Do we regret we engaged with event participants? Hell no! So far, we got only 2 spam PRs, but we also got many issues addressed (26 in 7 days) that we listed for the event.We had two primary goals to join the event:Show the community that AsyncAPI Initiative is not just the spec but a lot of great tooling.Help out people to take their first baby steps in open-source contributions with a welcoming community. We not only prepared issues with different levels of difficulty but also created a set of videos that explain how to contribute and what the issues are about.Anyway. We share the summary of how Hacktoberfest ended up for us in the next status update. So far, so good though.Remember that throughout the entire October me and Fran, we'll be hosting office hours so anyone can join and ask for help or even do a pair programming session with us. Feel invited! More details in the blog post about the event. We will stream to our official media accounts:https://www.twitch.tv/asyncapihttps://www.youtube.com/asyncapihttps://twitter.com/AsyncAPISpecLook intothiscalendar for the schedule.Apidays Live Hong KongThe AsyncAPI founder,Fran Méndez, was invited to present at Apidays Live Hong Kong. It is a free event that we recommend you to join. Fran's talk is scheduled for tomorrow at 8:10 AM CEST (2:10 PM Hong Kong timezone). He'll talk aboutAsyncAPI and the Future of API specs.Our regular community member, Paul Taylor from Mulesoft, will talk aboutGetting Started with AsyncAPI. His talk is scheduled for tomorrow, 6:10 AM CEST (12:10 PM Hong Kong timezone).To join the event, registerhere.React Component ImprovementsThe latest version of the component is 0.13.1. Since the last status update, we had three releases, where one was a feature to display descriptions of channels and operations correctly. We can see more interest in the component and more people asking about a client side's documentation rendering. External contributors pushed all recent changes to the component. Thanks a lot toDominik Henneke,Oliver Sand, andJakub Iwanowski.Don't think that server-side docs generation dies. So far generation of docs usingHTML Templateis most popular. We had a few bug fixes added to it, and the current release is 0.13.0. The latest release has a feature that few people asked for. Now you can add-p outFilename=customName.htmlparameter to modify the name of the output HTML file.AsyncAPI Special Interest Group (SIG) open meetingThe last meeting took place on Tuesday, 15th of September, 4PM UTC. Meeting notes and recording are availablehere.The next meeting is scheduled for nextTuesday, 13th of October, 4PM UTC.We work on the agenda for the next meetinghere. At the moment, there is nothing in the agenda so you can sneak in your topic easily.We host the meeting onZoom. Do not forget about future meetings and always have up to date invitations in your calendar by adding your email tothismailing list.Some Good Read3 Experts on How the API Industry Is Changingarticle byThomas BushGoing AsyncAPI: The Good, The Bad, and The Awesomevideo byBen GambleAsyncAPI @Hacktoberfestarticle byLukasz GornickiCover photo byPineapple Supply Co.onUnsplash
"""
--------------------------------------------------------------------------------


Post 106
ID: https://www.asyncapi.com/blog/hacktoberfest-2020?utm_source=rss
Title: AsyncAPI @Hacktoberfest
Link: https://www.asyncapi.com/blog/hacktoberfest-2020?utm_source=rss
Summary: What is AsyncAPI

AsyncAPI is a specification for describing your
Content:
"""
HacktoberFest 2020 has finishedCheck out oursummary blog post. There are lots of good insights!What is AsyncAPIAsyncAPI is a specification for describing yourevent-driven architecture. You are probably using alreadyOpenAPI/Swagger specificationfor describing your synchronous RESTful APIs. AsyncAPI is something that supplements OpenAPI. As an example, you should use AsyncAPI when your services do not talk to each other directly but through a message broker.In contrast to the OpenAPI Initiative, AsyncAPI Initiative is focused not only on creating and evolving the AsyncAPI specification but also on its tooling. It is a vendor-neutral space for the community to work together on the spec and its tools. We work on tools like specification parsers or docs and code generators.What Is Hacktoberfest And Why AsyncAPI Initiative Joins ItHacktoberfestis a well-known event that promotes open source contributions. In short, you have the entire October to submit four pull requests to any project you want, and in exchange, you get a super cool t-shirt. Is that it? Is it just for a t-shirt? Nah, the t-shirt is nice but what you also get is easy access to open source world. Maintainers of many projects open up for contributions, and it is a great chance to make your first step to joining this fantastic world.AsyncAPI Initiative joins the Hacktoberfest for two main reasons:Promote AsyncAPI Initiative as a place where we don't work on the specification only but also build a lot of great toolsMake it much easier for the community to make the first contribution to one of the AsyncAPI repositoriesIn the past, we were also there where you are now, shy and uncertain if we can impact open source community. We want to give you an easy path to take the first baby steps in the world of open source in a welcoming and friendly environment.Don't forget tosign upto the HacktoberfestHow Can You HelpThere is always a lot of work waiting out there. For the sake of this special event, we prepared around 75 GitHub issues that you can pick up. They represent different areas (for example, JavaScript or HTML), different difficulty (for example, 50 issues are easy), and different repositories. No matter if they are trivial or demanding, all of them are important for us. Even with trivial ones where you, for example, need to remove a semicolon, we will still be super happy because this will improve the quality of the project (SonarCloud reports). In other words, every single issue fromthislist is important.1. Pick The Right IssueHereyou can find a list of all the issues that you can work on. Most of the issues are about code contribution, but not all of them. There are also issues about documentation or CI/CD configuration (we use GitHub Actions). Just pick the issues you want to work on, one at a time, and let us know in the comments section that you want to work on it.2. Setup Your Environment And Create A First Pull RequestOnce youinstall Giton your machine and get aGitHub account, you need first to decide if you are here just for Hacktoberfest or longer, and make sure if your issue is easy and maybe you can complete it in the GitHub UI.In case you are here just for the Hacktoberfest, and you picked easy issues that involve changes only to a single file, there is no need to install Git and complicate your life. GitHub UI enables you tomake changes to a single file online.In case you:want to stay with us longer,you picked up an issue where you need to make changes to more than just one file,you also need to run the project locally to check if it worksThen followthisshort instruction on how to fork the repository and set it up locally.Once you are ready with your changes, submit a pull request. Be nice and follow ourcode of conductand make sure your pull request isdescribed properly.Office HoursDo you feel overwhelmed? No need. You can do it. Just take this blog post seriously.Trust me when I write that every pull request is crucial for us.
Trust me when I write that we are a welcoming community.
Don't be afraid that you will waste our time. If we would think about it this way, we would not even join the Hacktoberfest.Still not sure if you can make it? Don't worry. We want to host office hours throughout the event, 2x a week, 1h long, and different time zones. You can join whenever you want and ask us anything, or do pair programming with us. We start with the first meeting onTuesday 6th, 8AM UTCand then on the following days:Tuesday 6th, 8AM UTCThursday 8th, 4PM UTCTuesday 13th, 8AM UTCThursday 15th, 4PM UTCTuesday 20th, 8AM UTCThursday 22nd, 4PM UTCTuesday 27th, 8AM UTCThursday 29th, 4PM UTCWe stream to our official media accounts:https://www.twitch.tv/asyncapihttps://www.youtube.com/asyncapihttps://twitter.com/AsyncAPISpecYou can also join us in a more asynchronous discussion onSlack. For updates and latest news, the best is to follow ourTwitter account.Blooper ReelBefore you jump to your first contribution, have a look at the making of the videos. It was quite fun.Enjoy the Hacktoberfest!
"""
--------------------------------------------------------------------------------


Post 107
ID: https://www.asyncapi.com/blog/status-update-39-20?utm_source=rss
Title: AsyncAPI Initiative Status Update (week 39, 2020)
Link: https://www.asyncapi.com/blog/status-update-39-20?utm_source=rss
Summary: Circular References Supported in HTML and Markdown Templates

After recent efforts into circular references support in the AsyncAPI JavaScript Parser, now we started using these features in HTML and M
Content:
"""
Circular References Supported in HTML and Markdown TemplatesAfter recent efforts into circular references support in the AsyncAPI JavaScript Parser, now we started using these features in HTML and Markdown docs generators. With the latest releases of those two templates, you can generate documentation for schemas containing circular references. Below you can see an example specification file and how its payload and payload generated example looks like in generated HTML. You can also give it a try on your own in ourPlayground.1asyncapi:2.0.02info:3title:Example4version:0.1.15channels:6recursive:7subscribe:8message:9payload:10$ref:'#/components/schemas/Recursive'11components:12schemas:13Recursive:14type:object15properties:16children:17type:array18items:19$ref:'#/components/schemas/Recursive'20something:21type:stringMessage payload presentation.Generated payload example.Generate HTML Docs into a Single FileThanks to the contribution fromGordeev Artem, you can now generate HTML documentation into a single file. Like what?To generate HTML documentation for AsyncAPI files, you can use ourHTML generator template. It generates an index.html file with correctly rendered content of the AsyncAPI file. In addition, it also references additional files necessary for nice display of the HTML, JavaScript, and CSS files.From time to time, the community asked that it would be nice if the template could generate only one index.html file with all the JavaScript and CSS inline inside the HTML file.Now it is possible! There is a new parameter added to the template called singlePage. Just pass it for example, in the CLI like this -p singlePage=true.Parser with More Helpers and Better API docsWe releasedParser release candidate 5with features you want to have in a library before you announce the 1.0.0 release. Thanks to generous support from our community memberMaciej Urbanczyk, this release candidate contains the following additions:Missing externalDocs field in AsyncAPIDocument modelNew functions to all models that need it: hasBindings, bindingProtocols, hasBinding(name), binding(name), extensionKeys, extKeys, hasExtension, hasExt, tagNames, tag, hasTag, hasDescriptionMuch better API documentation. In the past, it was not only missing functions that were not available but also functions that were not documented because of the wrong usage of JSDocs. Now see on your own how significant is the change by looking just on the list of functions available for ChannelParameter model:ChannelParameter Docs before release.ChannelParameter Docs after release.Hacktoberfest PreparationHacktoberfestis a great event for people to start contributing to open source. It runs throughout October, and we want AsyncAPI Initiative to join the event. Why?Enable different communities to jump into the AsyncAPI projects with simple tasks, so they can get familiar with what we have, where to find things, and how easy it is to kick off with the first contributionShow to the community something that might not be so obvious, that the AsyncAPI Initiative is not only working on the specification but also a lot of great tools to make it easy to work with the specificationIf you are interested in how we plan to join the Hacktoberfest, look at ourplan.The Highlight of Interesting DiscussionsWAMP Protocol BindingsThere are community efforts to define bindings forWeb Application Messaging Protocol (WAMP). In case you are experienced with the protocol, please join and supporthere.Go Code GenerationThere are community efforts to create a template for generating Go code using the AsyncAPI generator. The initial pull request is opened. You can help even if you are not familiar with AsyncAPI, as you can help with just the review of the generated code. Please join and supporthere.AsyncAPI Special Interest Group (SIG) open meetingThe last meeting took place on Tuesday, 15th of September, 4PM UTC. Meeting notes and recording are availablehere.The next meeting is scheduled for nextTuesday, 29th of September, 8AM UTC.We work on the agenda for the next meetinghere. At the moment, there is nothing in the agenda so you can sneak in your topic easily.We host the meeting onZoom. Do not forget about future meetings and always have up to date invitations in your calendar by adding your email tothismailing list.Cover photo byNeil ThomasonUnsplash
"""
--------------------------------------------------------------------------------


Post 108
ID: https://www.asyncapi.com/blog/status-update-37-20?utm_source=rss
Title: AsyncAPI Initiative Status Update (week 37, 2020)
Link: https://www.asyncapi.com/blog/status-update-37-20?utm_source=rss
Summary: We canceled the previous status update due to the vacation cucumber season, so this status update covers the last four and not two weeks. Please familiarize yourself with many things we worked on and
Content:
"""
We canceled the previous status update due to the vacation cucumber season, so this status update covers the last four and not two weeks. Please familiarize yourself with many things we worked on and the exciting discussions we had.Template for templates developmentWe’ve spent a lot of time recently on tooling development. Now it is time to start working on some docs! Last few weeks, we worked on a template, a boilerplate that one can use to create a new repository to start writing their template for the AsyncAPI Generator.The work is still in progress and will take a few weeks more, but you can already see a previewhere. All the Generator features are showcased there already. We are missing only example tests and readme there.The next steps are writing a set of interactive tutorials that can explain all the features step by step, help create a super basic template, and then a more complex one.In case you have some ideas, or maybe you want to help write those, please let us know.Avro 1.8.2 supportAvro schema parser now supportsAvro 1.8.2and not only 1.9.0. The AsyncAPI Generator and the Playground already support the new version of the parser.Parser v1.0.0-rc.4The latest release candidate includes few bug fixes, but most important is that it also introduces proper tests for the browser to make sure we avoid any future mistakes in the project that could cause browser-incompatible release.React component improvementsThe AsyncAPI React component for rendering documentation on the client-side just reached release v0.12.1. Among all the other improvements, the most important are:Custom schema parsers for RAML, OpenAPI, and Avro are now also used by this componentBetter handling and rendering ofadditionalPropertiesSchemas are not presented in the tables anymoreThe Highlight of Interesting DiscussionsProposal for more formal examplesAsyncAPI 2.0 specs allow you to specify an example of the message. You can have many examples stored in an array of maps, where the key is the name of the example, and value can be of any type.Laurent BroudouxfromMicrocksproject created a proposal for better representation of examples where you can provide an example of the message payload and the headers. It means we will end up with more formal Examples object in the spec.Please have a look atthisproposal and share your opinion. At the moment, it is a part of our AsyncAPI 2.1 milestone.Native support for projects like CloudEventsCloudEventsis a specification for commonly describing event data. AsyncAPI is a specification for describing an application's API related to asynchronous communication. In the end, users should not decide which spec is better cause they serve a different purpose. Through discussions with the community, we learned that many want to use AsyncAPI + CloudEvents + Avro.Before AsyncAPI 2.0.0 we releasedan articlewhere we discussed how CloudEvent could be used in an AsyncAPI document. Long story short, it was about presenting a payload of messages wrapped with CloudEvents in AsyncAPI Payload object, and how to leverage AsyncAPI custom schema format. Such an approach can lead to a lot of duplications.CloudEvents is like an envelope for your letter. The message may include some non-business related data instead of having them separated in the headers. You do not want to mix this technical information with business information in the AsyncAPI document under one Payload field, even if this is possible.One possible option could be to reuse AsyncAPI bindings functionality, but so far, they were used only for describing information related to specific protocols.Please have a look atthisissue or talk to us on Slack. In short, we discuss there an option to introduce an object called Envelope.AsyncAPI Special Interest Group (SIG) open meetingThe last meeting took place on Tuesday, 1st of September, 8AM UTC. Meeting notes and recording are availablehere.The next meeting is scheduled for nextTuesday, 15th of September, 4PM UTC.We work on the agenda for the next meetinghere. At the moment, there is nothing in the agenda so you can sneak in your topic easily.We host the meeting onZoom. Do not forget about future meetings and always have up to date invitations in your calendar by adding your email tothismailing list.Curated ContentMicrocks 1.0.0 release with AsyncAPI supportbyLaurent BroudouxEvent-Streaming: An Additional Architectural Style to Supplement API DesignbyJames HigginbothamChoosing Between Web APIs and Message StreamingbyJames Higginbotham
"""
--------------------------------------------------------------------------------


Post 109
ID: https://www.asyncapi.com/blog/status-update-33-20?utm_source=rss
Title: AsyncAPI Initiative Status Update (week 33, 2020)
Link: https://www.asyncapi.com/blog/status-update-33-20?utm_source=rss
Summary: Parser First Release Candidate is Alive

Since the last update, we jumped from release 0.28.0 to 0.33.1. In the last two weeks we fixed a few bugs, in the parser and in the AsyncAPI JSON Schema that t
Content:
"""
Parser First Release Candidate is AliveSince the last update, we jumped from release 0.28.0 to 0.33.1. In the last two weeks we fixed a few bugs, in the parser and in theAsyncAPI JSON Schemathat the parser is using for most of the validations. In case you have a Node.js application, you can also easily access the schema througha dedicated dependency. It was important not only to fix all those bugs but also to stop relying on our fork of thejson-schema-ref-parser. Now we use the latest version of the upstream so it will be easier to bump into the latest versions.Because of all those recent fixes, now was the moment to release our first release candidate for the parser. Give it a try and let us know what is missing!Generator release candidateWe just released another release candidate for theGenerator. The only new thing is the latest Parser release candidate to make it available to a broader audience. Say hello the release candidate number 8. Any bets we won’t go higher than 10?AsyncAPI React ImprovementsOur React component for rendering AsyncAPI files on a client-side has some improvements:Regex pattern of a given property is not displayedDisplayed information that payload can or cannot have additional propertiesThis component also uses the latest parser release candidate. Try it out withthispreview.The Highlight of Interesting DiscussionsHTML Generator vs React Component aka How to Stay DRYAt the moment, AsyncAPI organization has two components for rendering HTML out of the AsyncAPI document:HTML Templateis based on theGeneratorand therefore, can be used only on a server.  You can use it through its CLI in your CI/CD pipelines or host them as a Node.js application,AsyncAPI Reactis a component that can be used in a client-side application without an application server. Its limitation at the moment is that it can be used only with React.js as a dependency.None of the above solutions is perfect, yet we still have to maintain both to support as many use cases as possible. That is why we want to make a change here and stay DRY. Join the discussion inthisissue. We would like to replace current HTML template logic entirely and reuse the React component. There are two possible solutions we see:We could produce a kind of a bundle that would contain the React component, and there would be a simple index.html that would use it.We could try the approach of projects like Gatsby or Next.js that already use React to generate static sites.AsyncAPI Special Interest Group (SIG) open meetingThe last meeting was canceled. It felt like the center of the holiday season.The next meeting is scheduled for nextTuesday, 18th of August, 4PM UTC.We work on the agenda for the next meetinghere. At the moment, there is nothing in the agenda so you can sneak in your topic easily.We host the meeting onZoom. Do not forget about future meetings and always have up to date invitations in your calendar by adding your email tothismailing list.Curated ContentHow CloudEvents and AsyncAPI can help enable Event Driven Architecture- byPaul TaylorOpenAPI is the HTTP Binding in AsyncAPI- byKin LaneAvro Schema Parser and others in AsyncAPI Initiative Status Update (week 31, 2020)- our last update where we discuss Avro schema parser.
"""
--------------------------------------------------------------------------------


Post 110
ID: https://www.asyncapi.com/blog/status-update-31-20?utm_source=rss
Title: Avro Schema Parser and others in AsyncAPI Initiative Status Update (week 31, 2020)
Link: https://www.asyncapi.com/blog/status-update-31-20?utm_source=rss
Summary: Avro Schema Parser

Short Intro to Schema Types in AsyncAPI

There are many different schema formats that one might use to describe the message payload. Not everyone uses JSON Schema. There are multip
Content:
"""
Avro Schema ParserShort Intro to Schema Types in AsyncAPIThere are many different schema formats that one might use to describe the message payload. Not everyone uses JSON Schema. There are multiple formats out there, like RAML 1.0 Data Types, Avro, or even OpenAPI 3.0. When you write your AsyncAPI file, you should not manually convert schemas that you already store somewhere in a format different from AsyncAPI Schema. The best practice is to reuse existing schemas by referring to them in your AsyncAPI file and making sure that the Message object has information about the schema format within the schemaFormat parameter.AsyncAPIlists schema typesthat are a MUST but is not limited to this list only. RAML Data Types is not a MUST HAVE, yet we already have a custom parser for it.From the AsyncAPI tooling perspective, we have abasic JavaScript Parsercapable of parsing schema of the payload provided with AsyncAPI schema format or JSON schema format. Other schema parsers are plugins that you can register with a parser, likeOpenAPI 3.0orRAML 1.0 Data Types. You could provide such plugins as well for your custom formats.Avro ParserThe 3rd plugin that we now officially support is related to Avro schema type. The first minor version is already out there, and you can give it a try, even if your schemas are in the Confluent Schema Registry. Have a look at the docs ofthe Avro schema parser. The Avro parser is also part of the latest release candidate ofthe Generator. Please help us make it work for you.Circular References in AsyncAPINow JavaScript Parser can handle circular references that you might have in your AsyncAPI files. The current implementation fully dereferences circular references, and you cannot change this behavior. We also extended the API to help you out to deal with circular references:The core AsyncAPI model now contains the hasCircular() function that you can use to determine at the very beginning if a given AsyncAPI document contains some circular references or not. An example use case for it is to throw a proper error message to the user with a clear message that circular references are not supported by your tool at the moment,The Schema model contains isCircular() function to check if a given schema is circular, so you do not have to detect it on your own and adequately reactHave a look atthispull request for implementation details. The work is still in progress as nice features in the Parser do not mean now all the Generator’s templates will support it. Have a look atthiscomment if you need more details.TypeScript Support in ParserSince Parser 0.27 we will now always generateTypeScript typesto make it much easier for TypeScript developers to use Parser in their tools.Generator Release Candidate 7 is outWe just released another release candidate that contains a lot of improvements that we added to the Parser. It also includes the above mentionedavro-schema-parserso it is easier for you to test it out. Give it a try.The Highlight of Interesting DiscussionsPublish vs Subscribe Discussion ContinuesWe noticed that people that interact with AsyncAPI for the first time are confused about the meaning of those two words, publish and subscribe. Without going much into detail and oversimplifying things, we can say that this is the part of the community that considers using AsyncAPI to describe their internal broker-centric architecture. In such cases, you want to describe the application's behavior and not what others can do with it. You want to use the Publish verb to specify that your application publishes to a given channel. What if your application is exposed to the outside world where others can interact with it? You want Publish to mean something different, like it is now, that it means your application is subscribed to a given channel, so that you can publish to it, and the application will receive a message.Event-driven architectures are complex beasts with many patterns, and we should try to make AsyncAPI a single home for all of them. Please engage in this discussion, share your thoughts, and help us out to find the best solution:Proposalto solve the above challenge with a view property that will not require 3.0 release. There is also an idea to introduce more verbs.Recordingof the last open SIG meeting where there was a discussion about publish/subscribe confusion.AsyncAPI Special Interest Group (SIG) open meetingThe last meeting took place on Tuesday, 21st of July, 4PM UTC. Meeting notes and recording are availablehere.The next meeting is scheduled for nextTuesday, 4th of August, 8AM UTC.We work on the agenda for the next meetinghere. At the moment, there is nothing in the agenda so you can sneak in your topic easily.We host the meeting onZoom. Do not forget about future meetings and always have up to date invitations in your calendar by adding your email tothismailing list.Curated ContentPulsar vs. Kafka — Part 1 — A More Accurate Perspective on Performance, Architecture, and Features-StreamNativeview on Apache Pulsar vs Apache KafkaKafka vs. Pulsar vs. RabbitMQ: Performance, Architecture, and Features Compared-Confluentview on Apache Kafka vs Apache PulsarHow to Write Your First AsyncAPI Specification- byThomas Bush
"""
--------------------------------------------------------------------------------


Post 111
ID: https://www.asyncapi.com/blog/status-update-29-20?utm_source=rss
Title: AsyncAPI Initiative Status Update (week 29, 2020)
Link: https://www.asyncapi.com/blog/status-update-29-20?utm_source=rss
Summary: Increasing the quality of tools with SonarCloud

We enabled SonarCloud for the most critical AsyncAPI tools that are reaching or already reached 1.0.0 release. Luckily this amazing software is availab
Content:
"""
Increasing the quality of tools with SonarCloudWe enabledSonarCloudfor the most critical AsyncAPI tools that are reaching or already reached 1.0.0 release. Luckily this amazing software is available for free for open-source projects.1.0.0 release is something serious, and we wanted to make sure that we have an automated way of checking the code quality and security. Now every pull request is validated for the following projects:GeneratorParserCustom schema parsers for OpenAPI schema and RAML data typesThe quality of those projects is visiblehere. We additionally validate code withESLint plugin from SonarCloud.With the Parser we went even one step further, and we now statically check the security of the code also with theESLint security plugin.Looking at the quality of SonarCloud we will roll it out to the rest of the project under AsyncAPI GitHub organization.Parser 1.0.0 right behind the cornerRecent releases in the JavaScript Parser, brought many new features to the parser:Server variables validation. Parser throws an error if you forgot to specify a Variable object for a variable used in the server URL likeurl: api.streetlights.smartylighting.com:{port}where{port}is a variable.Channel parameters validation. Parser throws an error if you forgot to specify a Parameter object for a parameter used in the channel name likeevent/{streetlightId}/lighting/measuredwhere{streetlightId}is a parameter.We added missing validation of the payload provided with the AsyncAPI schema format. In the past, when you provided a message payload information in Components object, it was correctly validated, but not if you provided this information directly under the channel.Parser throws an error if OperationId is duplicated across the whole AsyncAPI document. This is an essential property for code generation, and specification is precise that duplicates of this information are not allowed.Parser throws an error if you provided server security information in a wrong format and has a corresponding Security Schema object.For today, except forhandling circular references issueI mentioned in my last update, there are no other serious tasks we want to solve before the 1.0.0 release. Keep your fingers crossed.The Highlight of Interesting DiscussionsThere are some interesting discussions/topics where it would be great to hear your opinion.Add view property in the specificationThis proposal addresses the confusion around the semantics of Publish and Subscribe channel operations. At the moment, the specification should be used to describe how users can interact with an application. In other words, if the AsyncAPI document of the application says that ithas a publish channel, it means that this application issubscribed to this channel, and application users can publish an event to this application by publishing an event to this channel. Community proposal behind theviewproperty is to enable you to decide if you want the specification to tell you how you can interact with an application, or how the application behaves. You could say that publish means that the application published events to the channel and not the other way around.Please have a look atthe corresponding issueand share your opinion.Allow $schema property in the specificationWith$schemaproperty you can specify a location of the JSON Schema file and most of the IDEs will make your life much easier by adding auto-completion and other super useful functionalities. In the issue we discuss how we could allow maybe not only$schemabut any property starting with$, and also we talk about the opportunity to measure the adoption of the specification.Please have a look atthe corresponding issueand share your opinion.AsyncAPI Special Interest Group (SIG) open meetingThe last meeting took place on Tuesday, 7th of July, 8AM UTC. Meeting notes and recording are availablehere.The next meeting is scheduled for next Tuesday, 21st of July, 4PM UTC.We work on the agenda for the next meetinghere. At the moment, there is nothing in the agenda so you can sneak in your topic easily.We host the meeting onZoom. Do not forget about future meetings and always have up to date invitations in your calendar by adding your email tothismailing list.Curated ContentSome articles you might want to read to learn something new:Event-Streaming: An Additional Architectural Style to Supplement API DesignbyJames HigginbothamHow to mitigate unhappy paths with an event-driven architecture at scaleby Paul TaylorUnderstanding Event Driven ArchitecturebyCraig Godden-Payne
"""
--------------------------------------------------------------------------------


Post 112
ID: https://www.asyncapi.com/blog/event-streaming-an-additional-architectural-style-to-suplement-api-design?utm_source=rss
Title: Event-Streaming: An Additional Architectural Style to Supplement API Design
Link: https://www.asyncapi.com/blog/event-streaming-an-additional-architectural-style-to-suplement-api-design?utm_source=rss
Summary: This post originally appeared on Capital One Tech



The growth and adoption of web-based APIs is key to the transformational technology journey of any enterprise. Those APIs, whether they are RESTful
Content:
"""
This post originally appeared onCapital One TechThe growth and adoption of web-based APIs is key to the transformational technology journey of any enterprise. Those APIs, whether they are RESTful or not, remain synchronous. They, like the web, utilize the pattern of HTTP to implement a request-response interaction approach.To illustrate, assume we have a project management API with the following interactions:Create a project (e.g. POST /projects)Create a new task (e.g. POST /projects/{projectId}/tasks)Assign the task to someone on our team (e.g. POST /tasks/{taskId}/assignees)The assignee marks the task as complete (e.g. PUT /tasks/{taskId})An API following this design works if design of the user interface closely mirrors those endpoints. But suppose an additional application requirement is to ‘automatically’ update a task’s status when marked complete by another user. With a request/response web-API, an option is to incessantly poll a status API on the chance a status might have changed. This is both cumbersome and error-prone.
Instead of polling, we can introduce anevent-driven architecture.Introduction to Event-Driven ArchitectureIn an event-driven architecture (or EDA), an application is composed of independent components that react to events published by other components. EDA is popular for distributed applications, as new components may be introduced into a solution to solve emerging problems — without the knowledge of previously developed components. Message brokers are used as an intermediary for communication, producing a loosely coupled design by preventing components from directly communicating with one another.If you are familiar with service-oriented architecture (SOA), you have experienced EDA. Most service-oriented architectures used an enterprise service bus (ESB) for service communication rather than a message broker. Events were published to the ESB, where they were then routed to other services to integrate two or more software systems. However, ESBs proved problematic as they were used as “integration glue”, causing integration code to become scattered across services, apps, and the ESB; fragile systems were created. This fragility produced a greater need for coordination between teams, slowing software delivery.The Emergence of a Microservice and Event-Driven ArchitectureTo overcome this increased coordination, the microservice architecture was introduced as a replacement for traditional SOA. This newer distributed architecture, built on APIs and microservices, encourages “dumb pipes, smart endpoints.” Integration logic is pushed to the consumers and producers. Message brokers, rather than ESBs, are used for message routing, not integration logic. Services and APIs talk to one another while hiding implementation details. This loose coupling makes software more resilient to evolution as new requirements emerge.As enterprises shift to APIs backed by a microservice architecture, the number of published events has grown considerably. Message brokers are typically transactional in nature, ensuring once-and-only-once delivery of messages. While useful for traditional software development, the transactional nature of message brokers limits the scalability of service communication.Distributed streaming data platforms, such as Apache Kafka, now offer enterprises higher throughput than traditional message brokers. Kafka removes the need for transactional messaging found in message brokers, opting instead for turning events into message streams. These streams are accessible by any authorized subscriber and may be accessed real-time or processed sequentially from a predetermined location or at the start of the stream.API Design with Event StreamingEvent streams help software extend beyond the request-response approach common to web API styles such as REST, GraphQL, and gRPC. Software can communicate bi-directionally, removing the need for API consumers to continually poll for state changes. Instead, APIs publish events to an event stream for notification of data changes or important business events to any number of subscribed services for further processing.Let’s revisit our previous example. We needed to solve two separate requirements:Notification when a task is marked as completed. Our only option without a message-driven architecture is to require interested parties to constantly make API calls to see if the task has been completed (aka polling)Alerting a project owner when a task has been modified or marked as completed. Our only option is to mix our user interface concerns with our API by making the API send an email. The API is no longer responsible for managing projects and tasks — it is now responsible for the content and look-and-feel for email alertsIf we introduce a message-driven architecture to our solution, we can develop an API that delivers project and task resources that offer the necessary capabilities (create, read, update, delete, and mark as complete). Our API doesn’t need to know about how the task completion event notification will be used, including that an email will be sent. All it needs to do is publish event messages when those events occur and allow other services to take action as appropriate. Events this API may publish include:Interested parties can then subscribe to the event(s) they are interested in and safely ignore the rest. In our example, we may end up with three components:Projects API— Manages the Projects and Project Tasks resources via a REST-based API. The API may be comprised of one or more microservices that implement the capabilities offered by the REST API. When any event, from the list in the table above, occurs then the API publishes an event into the appropriate message stream for consumption by event subscribersTask Completed Email Microservice— Subscribes to the Task.Completed event, notifying project manager(s) via email when any task has been marked as completedTask Modified Email Microservice— Subscribes to the Task.Updated event, notifying all team members via email when any task has been editedThe API has no awareness of the two microservices subscribed to the specific events; it just publishes the events to the appropriate message stream. The solution is considered loosely coupled and therefore capable of evolving over time as new requirements emerge, perhaps with new types of notifications (e.g. SMS, web dashboard alerts) or integrations (e.g. synching to JIRA).ConclusionThe demand for more robust methods of software communication is pushing the limits of today’s interface solutions. Request/response-based APIs are essential. However, today’s technical problems are now demanding event-driven support — in addition to request/response — to improve an API’s capability offerings.As API designers, we must strive to use all available tools to offer a better developer experience. As you enhance your existing APIs and new APIs emerge, ask yourself:How can my solution architecture be improved by moving beyond standard REST APIs and into a loosely-coupled event-driven architecture?What events should my API publish that would benefit API consumers?How will my API consumers benefit from the addition of these events and how do they take advantage of them?Let’s shift our approach from strictly request-response to thinking in terms of how our APIs can not only offer endpoints for requests, but events that enable the API to push to other services. The result will be increased innovation and more transformative APIs both within and across our LOBs.
"""
--------------------------------------------------------------------------------


Post 113
ID: https://www.asyncapi.com/blog/status-update-27-20?utm_source=rss
Title: AsyncAPI Initiative Status Update (week 27, 2020)
Link: https://www.asyncapi.com/blog/status-update-27-20?utm_source=rss
Summary: AsyncAPI is innovation and you should assess it

ThoughtWorks and InfoQ clearly point out this is the best moment to have a closer look at AsyncAPI specification. Specification brings standardization
Content:
"""
AsyncAPI is innovation and you should assess itThoughtWorks and InfoQ clearly point out this is the best moment to have a closer look at AsyncAPI specification. Specification brings standardization into event-driven architectures and makes space for building great tools to solve problems like testing, documentation, code generation, and many others. Read more:ThoughtWorks Technology Radar - ToolsSoftware Architecture and Design InfoQ Trends Report—April 2020Generator and Parser 1.0 releasesWe are going in the right direction with the first major releases forthe Generatorandthe Parser. The lastrelease candidatewe produced for the Generator is pretty much stable, and all tasks were completed. We also tried it in ourGitHub ActionandAsyncAPI Studio, and it works like a charm.Then why are you not promoting the last release candidate to 1.0.0?Good question, I’m glad you asked :)Generator depends a lot on the Parser. Parser did not reach a major release yet. As you may have guessed, I'm now focused on the Parser 1.0.0 release, and the issues we want to complete before the release are listed inthis milestone. The good news is that most of the issues are either in progress, and some have pull requests already opened.What’s the plan then?Release the Parser with 1.0.0 and then Generator 1.0.0 as we already know that Parser 1.0.0 introduces some breaking changes.It is taking way too long.Fair point. We just need more hands on the board. If you are a JavaScript developer and you thought about joining AsyncAPI as a contributor, but you never knew the right moment, now is the time. I'm now entirely focused on the Parser and would be happy to onboard some more people. Just let me know, and I'll onboard you.New Website Right Behind The CornerThe time has come to do some refreshment of the AsyncAPI website. We also change the engine used to generate the website, from Hugo to Next.js. Have a look atthe previewof the work and feel free to share your feedback to Fran inthis pull request. Greatest things you can see there:Better exposure of community-related channels on the landing pageMore prominent promotion of AsyncAPI maintained tools, likethe GeneratorA more unobstructed view of theBlogsectionRight-hand side page navigation with scroll spy ondocumentation view.There are many other significant changes. You'll see them immediately on the main landing page.The Highlight of Interesting DiscussionsThere are some interesting discussions/topics where it would be great to hear your opinion.Circular ReferencesHow would you expect those are handled by the Parser and also by the Generator? Should such references be ignored or resolved, and if resolved, then how? Should generated docs indicate circular reference or ignore this info as irrelevant? These are all the questions we face now, and it would be awesome to get your inputhere.React Wrapper Redoc styleAsyncAPI Initiative provides two ways of generating docs from AsyncAPI specification:HTML templatefor the AsyncAPI generator. The classical server-side generation you perform in your CI pipelines or in an application with Node.js server.React componentthat you can use for dynamic docs rendering client-side. This one is great, but only if you want to use React in your application.We are thinking about how we could consolidate both into one project that is maintained just once. In the meantime, the community createdthis wrapperfor our React component inspired by ReDoc approach to OpenAPI. It would be great to know what you think about this and what are your expectations toward AsyncAPI Initiative. Join thediscussion.React for Template Engine for the GeneratorWe are getting a bit tired of Nunjucks and how hard it is to debug and read the templates. Fran came up with an idea to use React as a template engine for our docs and code generator. He got inspired by the emerging popularity of solutions like Gatsby or Next.js (supporting pre-rendering of React components). Before you say out loud "you are crazy" join the discussionhere.AsyncAPI Special Interest Group (SIG) open meetingThe last meeting took place on Tuesday, 23rd of June, 4PM UTC. Meeting notes are availablehere.The next meeting is scheduled for next Tuesday, 7th of July, 8AM UTC.The agenda for the meeting is builthere. There is nothing on the agenda, so you can easily sneak your topic in.The meeting is hosted onZoom. Do not forget about future meetings, and always have up to date invitations in your calendar. Add your email tothismailing list.Curated ContentSome articles you might want to read to learn something new:Choosing Between Web APIs and Message StreamingbyJames HigginbothamHow event-driven architecture solves modern web app problemsbyBogdan SucaciuWebSockets for fun and profitbyMax Pekarsky
"""
--------------------------------------------------------------------------------


Post 114
ID: https://www.asyncapi.com/blog/choosing_between_web_apis_and_message_streaming?utm_source=rss
Title: Choosing Between Web APIs and Message Streaming
Link: https://www.asyncapi.com/blog/choosing_between_web_apis_and_message_streaming?utm_source=rss
Summary: When faced with a variety of options, how are developers building APIs supposed to know which is the right one for their solution? In this article, I’m going to outline the common characteristics for both REST APIs and message streaming so developers can better understand when (and when not) to use each one.
Content:
"""
This post originally appeared onCapital One TechWhen faced with a variety of options, how are developers building APIs supposed to know which is the right one for their solution? In this article, I’m going to outline the common characteristics for both REST APIs and message streaming so developers can better understand when (and when not) to use each one.Characteristics of REST-Based Web APIsREST-based web APIs create a conversation between a client (the API consumer) and an API server (the backend). When we build REST-based APIs within Capital One, we use HTTP as our protocol. Our designs depend heavily on HTTP, from the methods (e.g. GET, POST, PUT, PATCH, DELETE) to the headers that help us communicate between client and server (e.g. Authorization, Accept, Content-Type).1GET/projects2Accept:application/json34200OK5Content-Type:application/json67[8{"projectId":"...","name":"..."},9{"projectId":"...","name":"..."},10{"projectId":"...","name":"..."},11...12]1POST/projects2Content-Type:application/json34{"name":"...",...}56201Created7Content-Type:application/json89{"projectId":"...","name":"...",...}10The client (or API consumer) is the app, which sends a message (i.e. an HTTP request) to the API whenever it needs something. The server then replies with the response, including a status code that indicates if the request was processed successfully (2xx error code), failed due to client error (4xx error code), or failed due to server error (5xx error code). All communication flows from the consumer to the API backend.When we add in hypermedia links, we extend the conversation with some additional information that may be helpful to the client:1GET/projects/123452Accept:application/json34200OK5Content-Type:application/json67{8"name":"...",...,9"_links":{10{"self":"/projects/1234"},11{"related_projects":[12{"4567":"/projects/4567"},13{"8901":"/projects/8901"},14{"9012":"/projects/9012"}15]},16{"members":[17{"1":"/users/1"},18{"2":"/users/2"},19{"3":"/users/3"},20{"4":"/users/4"},21{"5":"/users/5"}22]}23}REST-based APIs have a specific set of characteristics that are summarized below:Request/response model— API consumers send requests to an API server and receive a response.Pull-based interaction— API consumers send an API request when data or functionality is required (e.g. user interface, at a pre-scheduled time).Synchronous— API consumers receive the response after a request is sent.Multiple content types— since REST APIs are built upon HTTP, responses may be JSON, XML, or other content types as necessary to support consumer needs (e.g. CSV, PDF).Flexible interactions— Building upon the available HTTP verbs, consumers may interact with REST-based APIs through resources in a variety of ways: queries/search, creating new resources, modifying existing resources, and deleting resources. We can also build complex workflows by combining these interactions into higher-level processes.Caching and concurrency protocol support— HTTP has caching semantics built-in, allow for caching servers to be placed between the consumer and API server, as well as cache control of responses and eTags for concurrency control to prevent overwriting content.Internal and external access— REST APIs may be restricted for internal use or for external use by partners or public developers.For most solutions, offering a REST-based API is a great starting point, allowing any application or automation script to interact with your API over HTTP.Characteristics of Message StreamingUnlike REST APIs, message streaming is better at providing notifications when new messages arrive. Once subscribed, the client will be notified when new messages are available:1POST/subscriptions2Content-Type:application/json34{"callbackUrl":"https://my.callback/path",...}56201Created7Content-Type:application/json8Now that the client is subscribed to a topic, it will receive notifications when new messages are available. This may be the result of a REST API processing incoming requests from a web or mobile app, then adding messages into the message stream topic to notify anyone that is interested:1POSThttps://my.callback/path2<<projectcreatedevent>>34POSThttps://my.callback/path5<<projectarchivedevent>>67POSThttps://my.callback/path8<<projectupdatedevent>>Notice how our conversation became more interesting. We now can be notified when things change or critical business events occur; without needing to modify and redeploy the API to support a new integration that emerges in the future. This is called loose coupling, and it helps our systems be used in new ways without the originator of the messages even knowing about current and future subscribers.Those familiar with message brokers will realize that this is familiar. The difference between a message broker and message streaming is thatmessage streaming allows us to revisit past messages in sequence as well:1<<requestlast12messagesfromproject_messagestopic>>23<<retrieveandsendlast12messagesfromproject_messagestopic>>This feature is useful when we need to go aggregate values or perform a new calculation we previously didn’t realize we needed.Note — we can’t filter messages or perform other aggregate queries when requesting the messages — only the client can do this after requesting the messages from the topic. REST APIs are better suited for performing ad hoc queries than message streams.As you are discovering, message streaming is a different style of interaction than REST-based APIs. Additional characteristics of message streaming are summarized below:Publish/subscribe model— Apps or APIs publish messages to a topic which may have zero, one, or many subscribers rather than a request/response model.Subscriber notification interaction— Apps receive notification when a new message is available, such as when data is modified or new data is available.Asynchronous— Unlike REST APIs, apps cannot use message streams to submit a request and receive a response back without complex coordination between parties.Single content-type— At Capital One, our message streaming is built upon Avro, a compact binary format useful for data serialization. Unlike HTTP, Avro doesn’t support other content types (e.g. CSV, PDF).Replayability— At Capital One, our message streaming is built on Kafka, subscribers may revisit and replay previous messages sequentially.No caching or concurrency protocol support— Message streaming doesn’t offer caching semantics, cache-control, or concurrency control between publisher and subscriber.Internal access only— Subscribers must be internal to the organization, unlike HTTP which may be externalized to partner or public consumers.Message streaming offers some additional communication options that REST-based APIs do not — push-based notifications when new data or state changes occur, and the option of revisiting past messages in the stream to perform new calculations or re-execute logic that failed previously. When combined together, REST-APIs enable consuming apps to integrate easily with an HTTP API, while message streaming allow consumers to be notified of changes without needing to check with the REST API first. This can be a powerful combination that can satisfy use cases that exist today, while allowing emerging use cases to be handled in the future — all without modifying existing systems to accommodate new solutions.SummaryAs you may have realized, choosing between a web API and message streaming isn’t difficult, as long as you understand the characteristics of each one. REST APIs are best suited to request/response interactions where the client application sends a request to the API backend over HTTP. Message streaming is best suited to notification when new data or events occur that you may want to take action upon. Just be sure to match the needs of the consumer with one or more approaches to offer a robust interface to your solution’s capabilities.
"""
--------------------------------------------------------------------------------


Post 115
ID: https://www.asyncapi.com/blog/asyncapi_codegen_scst?utm_source=rss
Title: AsyncAPI Code Generation: Microservices Using Spring Cloud Stream
Link: https://www.asyncapi.com/blog/asyncapi_codegen_scst?utm_source=rss
Summary: Code generation is no simple feat. There are a lot of complexities when it comes to generating useful application code. In this post, I am going to walk you through generating your own microservices u
Content:
"""
Code generation is no simple feat. There are a lot of complexities when it comes to generating useful application code. In this post, I am going to walk you through generating your own microservices using Spring Cloud Stream and the AsyncAPI Code Generator. These tools should help to simplify things when defining and implementing your asynchronous applications. I explained the same idea in a video you canwatch here, and all of the artifacts areavailable in GitHub.This postAsyncAPI Code Generation: Microservices Using Spring Cloud Streamappeared first onSolace.AsyncAPI: What Is It?Before we dive into code generation let’s start with the basics – what is AsyncAPI? Over the past few years,AsyncAPIhas emerged as the industry standard for defining asynchronous, event-driven APIs; you can think of it as OpenAPI for the asynchronous world. It is an open source initiative that providesbotha specification to describe and document your asynchronous applications in a machine-readable format, and tooling (such as code generators) to make life easier for developers tasked with implementing them.I’m not going to go into great detail about the specification, but for context you should know that it defines metadata about your asynchronous API, the channels available for sending/receiving messages, and components – such as schemas – that define the messages that are being exchanged. For more information about the specification you can read about ithere.Defining the Application That You Want to Develop: The  AsyncAPI DocumentThe first step in doing code generation with AsyncAPI is obtaining an AsyncAPI document that defines the application that you want to develop. Per the specification, this document is represented as JSON objects and must conform to the JSON standards. YAML, being a superset of JSON, can also be used. There are two main ways of going about obtaining this document: manually create the document or use an event portal.If you decide to manually create the document after familiarizing yourself with the specification, don’t worry – you won’t be starting with a blank slate. The AsyncAPI initiative has provided a handy, interactive tool called theAsyncAPI Studioto make this easier. On the left side of the Studio you can familiarize yourself with the specification and make changes to a real AsyncAPI document, and as you do so the right side of the screen updates to show how the document is parsed into a more human-readable format.The second way is to use an event portal. Solace PubSub+ Event Portal, for example, allows for architects and developers to collaborate using a GUI to design your event-driven architecture. The team would define the applications that exist in the system, as well as the events that are exchanged and the schemas which define them. Having a catalog of well-organized channels and events for reuse will also save you both time and headaches while collaborating, instead of having to comb through a bunch of files in various locations.Once the design is in place, PubSub+ Event Portal allows the developer to choose the application they are responsible for developing and download the AsyncAPI document in JSON or YAML.Create Event-Driven Microservices Using Spring Cloud Stream Without Learning Messaging APIsNow that we have our AsyncAPI document that describes our application it’s time to develop the application. The AsyncAPICode Generatorsupports templates to generate code for a variety of different languages and protocols, but for this example we’re going to use theSpring Cloud Stream template. One should note that the template generates a Maven project.The Spring Cloud Stream framework provides an easy way to get started with event-driven microservices by providing binders that allow the developer to create their microservices without having to learn messaging APIs.Download and Run the AsyncAPI GeneratorThe first step is of course to install the AsyncAPI generator itself. If you have NodeJS installed this takes just one easynpmcommand as seen below. You can find the required versions in theCode Generatoron github.npm install -g @asyncapi/generatorOnce you have the generator installed you can run it using theagcommand. At a minimum you must specify the AsyncAPI document to run it against and the template to use as shown below.ag https://raw.githubusercontent.com/asyncapi/asyncapi/2.0.0/examples/2.0.0/streetlights.yml @asyncapi/java-spring-cloud-stream-templateIn most cases you’ll want to take advantage of the parameters and specification extensions that are specified by the template being used. For example, the Spring Cloud Stream template that I’m using in this example allows me toconfigure many options, including the Spring Cloud Stream binder I want to use – for example, the Solace binder.Other parameters include:Maven information:artifactIdandgroupIdJava package:javaPackageBroker connection Info:host,username,passwordandmsgVpnUsing these options, myagcommand might look something like this, where-ospecifies the output directory:ag -o ExpenseIntegration -pbinder=solace -pview=provider -pactuator=true-partifactId=ExpenseIntegration -pgroupId=acme.rideshare -pjavaPackage=acme.rideshare.expense -phost=localhost:55555 -pusername=default -ppassword=default -pmsgVpn=default ~/Downloads/ExpenseIntegration.yaml @asyncapi/java-spring-cloud-stream-templateAfter running, the output will look something like this:Add Your Business LogicAt this point the generator has created anExpenseIntegrationdirectory that contains the Maven project. We can use the IDE of choice and import the Maven project to add business logic.As seen in the image below, once imported, the project looks like a regular Spring Boot Java project with generated classes under thejavaPackagethat was defined earlier and anapplication.ymlfile for configuration. Generated classes underjavaPackageinclude Plain Old Java Objects (POJOs) defined from the schemas in the AsyncAPI document andApplication.javawhich contains the actual Spring Cloud Functions where we’ll add our business logic.The generated POJOs, likeRideReceiptin the image above, define your data model per the schemas included in the AsyncAPI document. These POJOs contains variables with getters and setters for each attribute defined to allow both for developers to get coding quickly without having to manually create the objects themselves, but also for Spring Cloud Stream to automatically convert messages directly to POJOs.Then we have theApplication.javaclass, which can be renamed using thejavaClassparameter. The generator will add functions to handle messages delivered on the channels defined in the AsyncAPI documentas described in the template.In the example below we can see a singlejava.util.function.Consumerbean since our AsyncAPI document describes our application as a subscriber to messages whose payload is defined by theRideReceiptschema. Note the comment that states // Add business logic here; this is where the developer can add their business logic.1@SpringBootApplication2publicclassApplication{3privatestaticfinalLogger logger = LoggerFactory.getLogger(Application.class);4publicstaticvoidmain(String[] args){5SpringApplication.run(Application.class);6}78@Bean9publicConsumer<RideReceipt>acmeRideshareBillingReceiptCreated001Consumer(){10// Add business logic here.11returnnull;12}13}You might say: “Marc, that’s great, but how the heck is that function actually binding to the messaging channels!?” This is where theapplication.ymlfile comes into play.The generatedapplication.ymlfile defines several things as specified in the AsyncAPI document or from the parameters passed into the generator. First, it defines the list of functions it wants Spring Cloud Stream aware of underspring.cloud.stream.function.definition. Second, it tells Spring Cloud Stream which channels to bind those functions to underspring.cloud.streams.bindings. Lastly, it contains connection information to the messaging system. The connection info is specified by different parameters depending on the binder you choose but, in this case, it’s defined undersolace.java.1spring:2cloud:3stream:4function:5definition:acmeRideshareBillingReceiptCreated001Consumer6bindings:7acmeRideshareBillingReceiptCreated001Consumer-in-0:8destination:acme/rideshare/billing/receipt/created/0.0.1910solace:11java:12host:'localhost:55555'13msgVpn:default14clientUsername:default15clientPassword:default1617logging:18level:19root:info20org:21springframework:infoNote that all of this was done for the developer so they didn’t have to track down which SCSt parameters needed to be set, map the functions to the bindings, etc. They just have to add their business logic in place of the project and hit run! In this case since it’s a Spring Boot project you can “run as a Spring Boot app” in your IDE or even run from the command line usingmvn spring-boot:run.Helpful Parameters and Specification Extensions for Creating Microservices Using the AsyncAPI Spring Cloud Stream TemplateAs I mentioned, there are a lot of complexities when it comes to generating useful application code from a microservice. Because of these complexities, I thought I’d call out some tips, tricks, and painpoints of using the AsyncAPI Spring Cloud Stream template.There are a bunch of different parameters and specification extensions that you should consider when generating your code. All of them can be foundhere, but I’ll go over a few of the parameters that I use quite often:Thebinderparameter allows you to specify the Spring Cloud Stream binder that you’d like to use. Currently the generator supportskafka,rabbitandsolace.Theinfo.x-viewspecification extension can be set at the info level in your AsyncAPI document. This extension allows for you to define how the document should be viewed from an application perspective. By default an AsyncAPI specification takes aclientview where operations (publish/subscribe) defined in a document represent what an application accepts (or how you would communicate with that application). However, for code generation you may want to  generate what an application actually does. This is where setting theviewparameter comes in. If you setviewto a value ofproviderthe operations defined in the document will be treated as what an application actually does. Note that this extension can also be set using theviewparameter on some generator templates, such as the Java Spring Cloud Stream one.Theoperation.x-scs-function-namespecification extension can be set on yourpublishorsubscribeoperations in the AsyncAPI document, allowing you not only to name the generated function, but also tie two operations together to form a function that subscribes to one channel and publishes to another when the same name is used. For example, if your AsyncAPI document looked like the image below ajava.util.function.Functionbean called “calculatePercentage” would be generated which subscribes to the input channel and publishes to the output channel.1channels:2'input':3subscribe:4x-scs-function-name:calculatePercentage5message:6$ref:'#/components/messages/CovidTracking_SingleStateCurrentDataUpdate'7'output':8publish:9x-scs-function-name:calculatePercentage10message:11$ref:'#/components/messages/CovidTracking_SingleStateTestPercentagesUpdate'Thex-scs-destinationspecification extension can be specified on asubscribeoperation, allowing you to override the default destination value which usually matches the channel. This is useful when you are using the Solace binder and you are following the Solace pattern of publishing to topics and consuming from queues. In this case thex-scs-destinationvalue would be treated as the name of the queue which your microservice will consume from and the channel name in the AsyncAPI document will be added as a topic subscription to that queue.Thex-scs-groupspecification extension can also be specified on asubscribeoperation, allowing for the addition of agroupto the generated Spring Cloud Streambinding. This allows for the use of consumer groups and will end up in adurable queuebeing created when using the Solace binder.Tips For Using The Code Generator To Create Event-Driven Microservices Using Spring Cloud StreamBesides configuration options there are a few more things to keep in mind when using the generator to create event-driven microservices using Spring Cloud Stream.Make sure generated POJOs have the Java types you would expect for generated variables! For example, if your JSON schema defines an attribute type as anumberorintegerthose are being mapped to aDoubleorIntegerin Java respectively. If you would like another type, such as a float or long, you’ll want to make that change. It is also important to make sure you pay close attention to data that represents dates and/or times as those will likely end up just being represented by aStringby default.Dynamic topics are not yet supported by the AsyncAPI SCSt Code Generator. We’ll be looking to enhance them both to support dynamic topics in the future but for now you’ll want to remove dynamic pieces of the topic from your channels in the AsyncAPI document and add them into the code afterwards.When creating a Spring Cloud Stream microservice that doesnotcontain ajava.util.function.Supplierinclude a web server so the microservice continues running and listening for messages to process. This can be done by including the-p actuator=trueparameter to include Spring Actuator functionality which itself requires a web server, and also provides some cool management and monitoring capabilities. Alternatively, you can just add thespring-boot-starter-webstarter to your pom after it’s been generated. Note this is not an issue with the AsyncAPI generator template, but just a bug with the Solace Spring Cloud Stream binder which will be relevant to people using the generator.I hope those tips are helpful and save you some troubleshooting time!ConclusionI hope this post was useful and you’re able to quickly dive in to generating your own event-driven microservices using Spring Cloud Stream and the AsyncAPI Code Generator after exploring the example described above.You can get started right away and use the Solace PubSub+ Event Portal to generate your AsyncAPI document for FREE by signing up for anew cloud account!If you have more questions or want to share your experience with the tools, you can let us know in theSolace Community Forumor consider joining us in contributing directly to the AsyncAPI initiative.
"""
--------------------------------------------------------------------------------


Post 116
ID: https://www.asyncapi.com/blog/doc-event-driven-api?utm_source=rss
Title: API documentation in event-driven applications
Link: https://www.asyncapi.com/blog/doc-event-driven-api?utm_source=rss
Summary: We live in an era of distributed systems. Airlines and hotels communicate with each other to offer us a better experience in our travels; shops work with shipping companies, so we have our new product
Content:
"""
We live in an era of distributed systems. Airlines and hotels communicate with each other to offer us a better experience in our travels; shops work with shipping companies, so we have our new products in our homes in a matter of hours. All of these integrations across services are done using APIs. Those APIs must be well documented so the consumers can integrate with them easily. This is not only a technical matter but also a business-related one.Currently, the most used API protocols areRESTandGraphQL. You can document your REST API using theOpenAPIinitiative. In the case of GraphQL, you can use tools like GraphiQL, which makes supported operations visible throughintrospection query.Both protocols are essentially synchronous: you make a request against the API and wait for a response. But what happens when you are to design an asynchronous event-oriented API? OpenAPI has been designed to document request/response APIs, and GraphQL has its own specific mechanism, so they are not applicable in this case.AsyncAPIto the rescue.Let's imagine you work on a book shopping website calledSuperFunnyBooks. Your team is responsible for theCatalog Service. Book publishers can register new books to the platform through your service.SuperFunnyBooksproduct team needs a new feature to be added: when a new book is registered on the platform, it has to be recommended to users interested in that genre. To do this, a brand new service,Recommendation Service, is created and a new team is assigned to.The new service needs to know when a new book is registered in the platform, soCatalog Servicewill publish aBookRegisteredevent to a message queue every time this happens. This event will contain information about the new book. But, where is the message queue located? and what does exactly "information about the new book" mean? It sounds a little bit abstract and vague.Recommendation Serviceteam needs to know every single field that will be included in the event's payload, as well as how to connect to the message queue to start listening for new events. In other words, they need the API documentation.This is how this event-oriented API would look like with AsyncAPI:1asyncapi:2.0.02info:3title:CatalogService4version:'1.0.0'56servers:7production:8url:catalog.superfunnybooks.com:90929protocol:kafka10description:ProductionKafka1112channels:13book/registered:14description:BookRegisteredTopic15subscribe:16summary:Receiveinformationaboutnewbookregisteredincatalog17message:18name:BookRegistered19contentType:application/json20payload:21type:object22properties:23bookId:24type:string25title:26type:string27author:28type:string29genre:30type:string31publisherId:32type:string33registeredAt:34type:string35format:datetimeThe first part contains API metadata information. Then,serversinformation is declared; in this case, there is a Kafka server running oncatalog.superfunnybooks.comat port9092.channelsobject groups all the operations that the API supports. This one allows consumers to subscribe tobook/registeredchannel to be notified when a new book is registered. Also, the concrete event's payload schema is defined.With this document, API is properly defined and it provides a contract betweenCatalog Serviceand its consumers. Now,Recommendation Serviceknows where the message queue is located in the network and how exactly an event's payload looks like.To sum up, having nice API documentation improves communication between teams in a company as well as between external stakeholders. Also, using a machine-friendly format (like YAML) in API documentation enables it to be integrated into the development lifecycle and the possibility of taking advantage of techniques like server stubbing or automatic testing.This has been a simple example of how to use AsyncAPI specifications to document event-oriented APIs.AsyncAPI specprovides a lot of options that allow to define clearly many aspects of an API. It is worth keeping it in mind.I hope you enjoyed this post.(Original content fromhttps://hvalls.dev/posts/doc-event-driven-api)
"""
--------------------------------------------------------------------------------


Post 117
ID: https://www.asyncapi.com/blog/automated-releases-part-two?utm_source=rss
Title: (Part 2) Full automation of release with GitHub Actions and Conventional Commits for non-JS projects
Link: https://www.asyncapi.com/blog/automated-releases-part-two?utm_source=rss
Summary: This post and the previous one come from our experience we gained when working on full automation for all tools maintained by AsyncaPI Initiative.
Content:
"""
tl;drHereyou can find the first blog post about automated releasing. The purpose of this blog post is to show how you can do the same automation in non-JavaScript projects. Even if JavaScript community created tooling, you can still use it in other projects and don't freak out.This post and theprevious onecome from our experience we gained when working on full automation for all tools maintained byAsyncaPI Initiative.AsyncAPIis a specification that you use to create machine-readable definitions of your event-driven APIs.The previous post focused on JavaScript as the first library that we automated was ourgenerator. It covered publishing to NPM and usage of the JavaScript community ecosystem. Now we have automation rolled out to all our libraries, Go-written too.What I need to automate release?To automate a release efficiently, you need two things:Machine-readable information that allows you to identify if a given commit should trigger a release or not.Tooling that you can easily plug in and configure without the need to write everything from scratch.This automation is possible thanks to the following:TheConventional Commitsspecification. The purpose of Conventional Commits is to make commits machine-readable but also human-readable. It defines a set of commit prefixes that can be easily parsed and analyzed by tooling and looks good to the human eye too.TheSemantic Releasepackage and related plugins that support Conventional Commits and publishing to different channels like GitHub, NPM, Slack, and others.Where's the catch?This blog post is about the automation of releases for non-JavaScript projects. Let me be honest though, solutions I mentioned in the previous chapter come from the JavaScript community.The problem is, there are people whoHate JavaScript, they trulyhate itlike it is a living thing. Although, I'm personally proud to be an idiot that has a programming language that I can use.Conventional Commits specification is heavily inspired byAngular Commit Guidelines. The Semantic Release package and its plugins ecosystem are all Node.js packages.If you have Java or Go project, you can still use these tools. You do not have to keeppackage.jsonin your repository, so don't worry, you can keep your repository clean. The great folks from Semantic Release thought about you too.Using Semantic Release with GitHub Action in Go projectOne of the projects where we use this JavaScript tools is our parser for AsyncAPI documents. It is aGo parser.Semantic Release configurationThe Semantic Release package supports configuration files in different formats and file types. You are not bound topackage.json. We chose to use.releasercfile in YAML format but there areother optionstoo.1---2branches:3-master4plugins:5--"@semantic-release/commit-analyzer"6-preset:conventionalcommits7--"@semantic-release/release-notes-generator"8-preset:conventionalcommits9--"@semantic-release/github"10-assets:11-path:asyncapi-parser.darwin.amd6412label:Binary-DarwinAMD6413-path:asyncapi-parser.linux.amd6414label:Binary-LinuxAMD6415-path:asyncapi-parser.windows.amd64.exe16label:Binary-WindowsAMD64Our configuration uses plugins to:Analyze Git commits with Conventional Commits specification.Create a Git tag and generate changelog for release notes.Publish a release with additional assets. We compile our parser as binaries that are compatible with many platforms and we want to have them easily accessible with each release.We place the configuration under.github/workflows/, next to our GitHub Action release workflow file:release.yml. It indicates that it is for release only, nothing else.Release workflowLet us have a look at the differences between this workflow and the workflow I described for a typical JavaScript projecthere.First, you define atestjob with the Go environment to trigger tests with different versions of Go.1test:2name:'Testing'3runs-on:ubuntu-latest4strategy:5matrix:6go:7-'1.14'8-'1.13'9-'1.12'10steps:11-name:Checkoutrepo12uses:actions/checkout@v213-name:SetupGo14uses:actions/setup-go@v1.1.215with:16go-version:'${{ matrix.go }}'17-name:Invokinggotest18run:gotest./...The next step is thereleasejob, where you can differentiate two core steps. The first part is the generation of the binaries that you want to expose in the GitHub release.1-name:SetupGo2uses:actions/setup-go@v1.1.23with:4go-version:'1.14'5-name:Invokinggovetandbinariesgeneration6run:|7go vet ./...8GOOS=darwin GOARCH=amd64 go build -o=.github/workflows/asyncapi-parser.darwin.amd64 ./cmd/api-parser/main.go9GOOS=linux GOARCH=amd64 go build -o=.github/workflows/asyncapi-parser.linux.amd64 ./cmd/api-parser/main.go10GOOS=windows GOARCH=amd64 go build -o=.github/workflows/asyncapi-parser.windows.amd64.exe ./cmd/api-parser/main.goSo far, it is all Go-related operations. How about the release? For the release, you need to set up a Node.js environment to run Semantic Release. Node.js community has this excellent package,npx, that allows you to run a package without installing it, and this is what you can do here in the workflow.1-name:SetupNode.js2uses:actions/setup-node@v13with:4node-version:135-name:Addpluginforconventionalcommits6run:npminstallconventional-changelog-conventionalcommits7working-directory:./.github/workflows8-name:ReleasetoGitHub9working-directory:./.github/workflows10env:11GITHUB_TOKEN:${{secrets.GH_TOKEN}}12GIT_AUTHOR_NAME:asyncapi-bot13GIT_AUTHOR_EMAIL:info@asyncapi.io14GIT_COMMITTER_NAME:asyncapi-bot15GIT_COMMITTER_EMAIL:info@asyncapi.io16run:npxsemantic-releaseYou only have to installconventional-changelog-conventionalcommitsexplicitly if you want to useconventionalcommitspreset when analyzing Git commits and generating the changelog:1plugins:2--"@semantic-release/commit-analyzer"3-preset:conventionalcommits4--"@semantic-release/release-notes-generator"5-preset:conventionalcommitsTake a look at full release workflow for reference:1name:Release23on:4push:5branches:6-master78jobs:9test:10name:'Testing'11runs-on:ubuntu-latest12strategy:13matrix:14go:15-'1.14'16-'1.13'17-'1.12'18steps:19-name:Checkoutrepo20uses:actions/checkout@v221-name:SetupGo22uses:actions/setup-go@v1.1.223with:24go-version:'${{ matrix.go }}'25-name:Invokinggotest26run:gotest./...2728release:29name:'Release to GitHub'30runs-on:ubuntu-latest31needs:32-test33steps:34-name:Checkoutrepo35uses:actions/checkout@v236-name:SetupGo37uses:actions/setup-go@v1.1.238with:39go-version:'1.14'40-name:Invokinggovetandbinariesgeneration41run:|42go vet ./...43GOOS=darwin GOARCH=amd64 go build -o=.github/workflows/asyncapi-parser.darwin.amd64 ./cmd/api-parser/main.go44GOOS=linux GOARCH=amd64 go build -o=.github/workflows/asyncapi-parser.linux.amd64 ./cmd/api-parser/main.go45GOOS=windows GOARCH=amd64 go build -o=.github/workflows/asyncapi-parser.windows.amd64.exe ./cmd/api-parser/main.go46-name:SetupNode.js47uses:actions/setup-node@v148with:49node-version:1350-name:Addpluginforconventionalcommits51run:npminstallconventional-changelog-conventionalcommits52working-directory:./.github/workflows53-name:ReleasetoGitHub54working-directory:./.github/workflows55env:56GITHUB_TOKEN:${{secrets.GH_TOKEN}}57GIT_AUTHOR_NAME:asyncapi-bot58GIT_AUTHOR_EMAIL:info@asyncapi.io59GIT_COMMITTER_NAME:asyncapi-bot60GIT_COMMITTER_EMAIL:info@asyncapi.io61run:npxsemantic-releaseYou see, you can still have your project "clean" from any JavaScript-specific files and references. Everything you need for running your release with the JavaScript community tooling is only in the release-related configuration.ConclusionI don't think I can ever understand this "hate" towards JavaScript. I think, though, that you can "hate" the language, but if you see some amazing tooling built with it, that can increase your productivity, grit your teeth, put bias aside, and enjoy life. Especially, if in exchange you get this excellent feature, notification about release under the Issue and Pull Request:In case you want to have more explanation on the release automation subject, I recommend readingthe first part of the automation story. You can alsojoin our Slackfor further discussion.* Cover photo byRock'n Roll Monkeyon Unsplash
"""
--------------------------------------------------------------------------------


Post 118
ID: https://www.asyncapi.com/blog/asyncapi-conference-kick-off?utm_source=rss
Title: AsyncAPI Online Conference scheduled for 22.04 11 AM UTC
Link: https://www.asyncapi.com/blog/asyncapi-conference-kick-off?utm_source=rss
Summary: It is happening, a first-ever AsyncAPI Online conference. We start on 22 of April, at 11 AM UTC. The event is going to take 7 hours with 12 talks from all over the world. We start in sunny Sydney and finish in cloudy Vancouver. The event is for free, online, in your favorite quarantine room.
Content:
"""
It is happening, a first-ever AsyncAPI Online conference. We start on 22 of April, at11 AM UTC. The event is going to take 7 hours with 12 talks from all over the world. We start in sunny Sydney and finish in cloudy Vancouver. The event is for free, online, in your favorite quarantine room.How do you organize an event like this in such a short timeThere are two requirements you should fulfill behind you start organizing a conference:Gather a few people that like to walk off the beaten tracks. Best would be to involve your whole core team, as we did in AsyncAPI. All three of us got involvedFran Méndez- Project Director.Eva Morcillo Rodríguez- Marketing and Video Content Manager.Łukasz Górnicki- Maintainer and Dev Community Keeper.Make sure you have a fantastic community behind your back that supports your effortsFirst baby steps to kick off the eventConsult your community if what you plan to do makes senseSet a conference date and call for proposals deadlineGet your community involvedWe decided on a tight schedule. Our community had only three days to submit proposals. Oh boy, they exceeded our expectations. In total, we got 18! proposals. We were happy and proud but also afraid that we can't accept all talks.Talks selectionWe wanted to establish as many fair rules as possible in such a short timeframe. We decided to form a committee of people that could join Fran and vote for talks that they found most interesting:They could give 1-10 points per talk.They had no idea who is behind the talk. They knew only a title and an abstract of every proposal.After voting, we applied the following additional rules:We did not accept more than one talk from the same company. We choose the one that was most popular among voters.We did not accept talks that were either not related to the theme or other talks accepted for the conference.In other words, we did not want to favor any company and wanted to have a schedule with talks around a similar area.As a result, we accepted11 talksfrom the community. We did it thanks to the support of this amazing group of people:Waleed AshrafMike RalphsonJonas LagoniAndrzej JarzynaSponsoringWe decided toenable companies and individualsto support the event financially.How to collect money? Do it transparently with tools that you already know. We decided to use Open Collective because we use it already tocollect money for AsyncAPIWe created a dedicatedeventusingOpen Collective events. This approach allows us to collect money and share expenses explicitly for the event only. The sponsors in exchange get much more than just being listed in ourconference sponsors list, and it is clearly described under our event page.What is the money for? We want to spend it mainly on:Prizes for the community involved in the event.Paid event marketing. We are doing our best to promote eventon our own, but we know that we could do much better using paid channels too. More people know about the event and indirectly about AsyncAPI, better profits for the community, and the sponsors.Logistics aka connectivity issues can kill your eventThese are coronavirus times. ISPs are having stress tests. Netflix is probably hitting view records. Kids are running around the house all the time. We took it all into account, and this is how we want to solve those challenges:First of all, we asked our presenters to record their sessions upfront and send them to us. We want to stream them live to YouTube, and we are exploring platforms that might make it easy to stream not only to YouTube but also Twitter and others. Presenters still join their sessions, and they are going to engage with the audience in conference chat in real-time during the whole presentation. What is so great about it?The audience doesn't have to wait until the end of the presentation with questions as it works in traditional conferencesPresenters have much more time to engage with their audience, to exchange thoughts, and get more questions. They can also ask their teammates, organization members, or experts in their field to provide support during the talk.ConclusionDon't be afraid to organize your event; just find some freaks that follow you to organize it. I'm a proud freak that bought the idea immediately. It is worth it, even if you do not know the outcome yet, the experience you always gain profits in the future.In the name of the whole AsyncAPI community and the core team, I'd like to invite you to join our event on 22 of April, at11 AM UTC. The conference line-up suggests that the AsyncAPI Online conference is going to be epic!#stayhome #staysafe #staycurious
"""
--------------------------------------------------------------------------------


Post 119
ID: https://www.asyncapi.com/blog/asyncapi-github-actions?utm_source=rss
Title: Automate AsyncAPI workflows with GitHub Actions
Link: https://www.asyncapi.com/blog/asyncapi-github-actions?utm_source=rss
Summary: AsyncAPI community got rich with two GitHub Actions that you can use for validation and generation.
Content:
"""
tl;dr
AsyncAPI community got rich with two GitHub Actions that you can use forvalidationandgeneration.GitHub organized ahackathon for GitHub Actions. There is no better reason to work on a solution if there is a bag of swags waiting for youThe hackathon was only a trigger, the right moment to decide that we should engage. The primary motivation was to write a GitHub Action that can help the AsyncAPI community in specification adoption.Two AsyncAPI related actions we crafted in March are:Our community member,Waleed Ashrafcreatedan actionto validate AsyncAPI documents with ourparserWe also createdofficial AsyncAPI actionfor ourgenerator.Writing a GitHub ActionOur actions are bothwritten in JavaScript. The other way of writing action is to do aDocker container action. The best way to start writing your action is to:Followthistutorial to create a simple action to understand its components.Get familiar with theofficial toolkitthat you can use to simplify writing an action.Create your custom action withthis templatethat has many things plugged in already, like eslint, testing, and most important, distro generation, so you do not have to commitnode_modulesdirectory to your repository.These are all the resources I used to write my first action, and to master it, I only had to read the official docs, like thereference docs for the "action.yml" file. Well done GitHub!What I can do today with AsyncAPI GitHub ActionsThose two actions can help you a lot already, together or separately. I present in this post only two possible workflows, and you can take it from here and think about your ideas.Validation of AsyncAPI files in a Pull RequestYou can make sure that whenever someone makes a Pull Request to propose a change in the AsyncAPI document, you can validate it automatically usingWaleed'sactionWaleedAshraf/asyncapi-github-action@v0.0.3.Actions can be triggered bymultiple types of events. In this example, we will trigger the action on anypull_requestevent.1name:ValidateAsyncAPIdocument23on:4pull_request:56jobs:7validation:8runs-on:ubuntu-latest9-name:asyncapi-github-action10uses:WaleedAshraf/asyncapi-github-action@v0.0.311with:12filepath:'my-directory/asyncapi.yaml'Generating HTML and publishing it to GitHub PagesOne of the AsyncAPI use cases is to define your application and generate docs out of this definition, best in HTML. The typical workflow here would be to have a GitHub Action that your trigger on every push to themasterbranch.1name:AsyncAPIdocumentationpublishing23on:4push:5branches:[master]To generate HTML from your AsyncAPI definition, you need to useasyncapi/github-action-for-generator@v0.2.0action. You also need to specify a few more things:The template you want to use for generation. In this example, you can see the officialAsyncAPI HTML Template. You can also write your custom template but hosting it on npm is not mandatory.Path to the AsyncAPI file, in case it is not in the root of the working directory and its name is notasyncapi.ymlThe template specific parameters. The crucial part here is thebaseHrefparameter. When enablingGitHub Pagesfor a regular repository, the URL of the Web page ishttps://{GITHUB_PROFILE}.github.io/{REPO_NAME}/. SpecifyingbaseHrefparameter helps the browser to properly resolve the URLs of relative links to resources like CSS and JS files. You do not have to hardcode the name of the repo in workflow configuration. Your workflow has access to information about the repository it is running in. You could do this:${baseHref=/{github.repository}}/The output directory where the generator creates files. You might access those files in other steps of the workflow.1-name:GeneratingHTMLfrommyAsyncAPIdocument2uses:asyncapi/github-action-for-generator@v0.2.03with:4template:'@asyncapi/html-template@0.3.0'#In case of template from npm, because of @ it must be in quotes5filepath:docs/api/my-asyncapi.yml6parameters:baseHref=/test-experiment/sidebarOrganization=byTags#space separated list of key/values7output:generated-htmlNow you have a trigger and you can generate a Web page. The next step is to publish the generated HTML documentation to GitHub Pages. For this, you can use one of the actions created by the community, likeJamesIves/github-pages-deploy-action@3.4.2. You can also use other hosting solutions than GitHub Pages, like, for example, Netlify andone of their actions.1-name:DeployGHpage2uses:JamesIves/github-pages-deploy-action@3.4.23with:4ACCESS_TOKEN:${{secrets.GITHUB_TOKEN}}5BRANCH:gh-pages6FOLDER:generated-htmlHere is how a full workflow, with embedded validation, could look like:1name:AsyncAPIdocumentationpublishing23on:4push:5branches:[master]67jobs:8generate:9runs-on:ubuntu-latest10steps:11#"standard step" where repo needs to be checked-out first12-name:Checkoutrepo13uses:actions/checkout@v21415#Using another action for AsyncAPI for validation16-name:ValidatingAsyncAPIdocument17uses:WaleedAshraf/asyncapi-github-action@v0.0.318with:19filepath:docs/api/my-asyncapi.yml2021#In case you do not want to use defaults, you, for example, want to use a different template22-name:GeneratingHTMLfrommyAsyncAPIdocument23uses:asyncapi/github-action-for-generator@v0.2.024with:25template:'@asyncapi/html-template@0.3.0'#In case of template from npm, because of @ it must be in quotes26filepath:docs/api/my-asyncapi.yml27parameters:baseHref=/test-experiment/sidebarOrganization=byTags#space separated list of key/values28output:generated-html2930#Using another action that takes generated HTML and pushes it to GH Pages31-name:DeployGHpage32uses:JamesIves/github-pages-deploy-action@3.4.233with:34ACCESS_TOKEN:${{secrets.GITHUB_TOKEN}}35BRANCH:gh-pages36FOLDER:generated-htmlConclusionFirst of all, huge thank you toWaleed Ashraffor creating an action to validate AsyncAPI documents.Please try out the above-described actions and let us know what you think. Feel free to leave an issue to suggest improvements or ideas for other actions.In case you are interested with other GitHub Actions related posts you might have a look at:Full automation of release to NPM and Docker Hub with GitHub Actions and Conventional CommitsGitHub Actions - When Fascination Turns Into Disappointment
"""
--------------------------------------------------------------------------------


Post 120
ID: https://www.asyncapi.com/blog/automated-releases?utm_source=rss
Title: Full automation of release to NPM and Docker Hub with GitHub Actions and Conventional Commits
Link: https://www.asyncapi.com/blog/automated-releases?utm_source=rss
Summary: Repetitive tasks are tedious. If what you do manually can be automated, then what are you waiting for!
Content:
"""
tl;dr
from now on, we releasegeneratorin an automated way. We roll-out this setup to the rest when we see it is needed.Repetitive tasks are tedious. If what you do manually can be automated, then what are you waiting for!But these tasks take only a couple of minutes from time to time, gimme a breakA couple of minutes here, a couple of minutes there and all of a sudden you do not have time on more important things, on innovation. Automation makes it easier to scale and eliminates errors. Distractions consume time and make you less productive.We kick ass atAsyncAPI Initiativeat the moment. We started to improve our tooling regularly. We are now periodically sharing project status in ournewsletter, and hostbi-weekly open meetings, but most important is that we just recently updated our roadmap.Am I just showing off? It sounds like, but that is not my intention. I wish to point out we are productive, and we want to continue this trend and automation helps here a lot. If you have libraries that you want to release regularly and you plan additional ones to come, you need to focus on release automation.What full automation meansFull automation means that the release process if fully automated with no manual steps. What else did you think?Your responsibility is just to merge a pull request. The automation handles the rest.You might say:but I do not want to release on every merge, sometimes I merge changes that are not related to the functionality of the library.This is a valid point. You need a way to recognize if the given commit should trigger the release and what kind of version, PATCH, or MINOR. The way to do it is to introduce in your projectConventional Commitsspecification.Conventional CommitsAtAsyncAPI Initiativewe useSemantic Versioning. This is why choosingConventional Commitsspecification was a natural decision.Purpose of Conventional Commits is to make commits not only human-readable but also machine-readable. It defines a set of commit prefixes that can be easily parsed and analyzed by tooling.This is how the version of the library looks like when it follows semantic versioning:MAJOR.MINOR.PATCH. How does the machine know what release you want to bump because of a given commit? Simplest mapping looks like in the following list:Commit message prefixfix:indicatesPATCHrelease,Commit message prefixfeat:indicatesMINORrelease,Commit message prefix{ANY_PREFIX}!:so for examplefeat!:or evenrefactor!:indicateMAJORrelease.It other words, assume your version was 1.0.0, and you made a commit likefeat: add a new parameter to test endpoint. You can have a script that picks upfeat:and triggers release that eventually bumps to version 1.1.0.Workflow designAtAsyncAPI Initiativewhere we introduced the release pipeline for the very first time, we had to do the following automatically:Tag Git repository with a new versionCreate GitHub ReleasePush new version of the package toNPMPush new version of Docker image toDocker HubBump the version of the package inpackage.jsonfile and commit the change to the repositoryThis is how the design looks like:There are two workflows designed here.The first workflow reacts to changes in the release branch (masterin this case), decides if release should be triggered, and triggers it. The last step of the workflow is a pull request creation with changes inpackage.jsonandpackage-lock.json. Why are changes not committed directly to the release branch? Because we use branch protection rules and do not allow direct commits to release branches.You can extend this workflow with additional steps, like:Integration testingDeploymentNotificationsThe second workflow is just for handling changes inpackage.json. To fulfill branch protection settings, we had to auto-approve the pull request so we can automatically merge it.GitHub ActionsEven though I havemy opinion about GitHub Actions, I still think it is worth investing in it, especially for the release workflows.We used the GitHub-provided actions and the following awesome actions built by the community:Create Pull RequestAuto ApproveMerge Pull RequestRelease workflowRelease workflow triggers every time there is something new happening in the release branch. In our case, it is themasterbranch:1on:2push:3branches:4-masterGitHub and NPMFor releases to GitHub and NPM, the most convenient solution is to integratesemantic releasepackage and related plugins that support Conventional Commits. You can configure plugins in yourpackage.jsonin the order they should be invoked:1"plugins": [2[3"@semantic-release/commit-analyzer",4{5"preset":"conventionalcommits"6}7],8[9"@semantic-release/release-notes-generator",10{11"preset":"conventionalcommits"12}13],14"@semantic-release/npm",15"@semantic-release/github"16]Conveniently, functional automation uses atechnical bot rather than a real user. GitHub actions allow you to encrypt the credentials of different systems at the repository level. Referring to them in actions looks as follows:1-name:ReleasetoNPMandGitHub2id:release3env:4GITHUB_TOKEN:${{secrets.GH_TOKEN}}5NPM_TOKEN:${{secrets.NPM_TOKEN}}6GIT_AUTHOR_NAME:asyncapi-bot7GIT_AUTHOR_EMAIL:info@asyncapi.io8GIT_COMMITTER_NAME:asyncapi-bot9GIT_COMMITTER_EMAIL:info@asyncapi.io10run:npmrunreleaseAside from automation, the bot also comments on every pull request and issue included in the release notifying subscribed participants that the given topic is part of the release. Isn't it awesome?DockerFor handling Docker, you can use some community-provided GitHub action that abstracts Docker CLI. I don't think it is needed if you know Docker. You might also want to reuse some commands during local development, like image building, and have them behind an npm script likenpm run docker-build.1-name:ReleasetoDocker2if:steps.initversion.outputs.version!=steps.extractver.outputs.version3run:|4echo ${{secrets.DOCKER_PASSWORD}} | docker login -u ${{secrets.DOCKER_USERNAME}} --password-stdin5npm run docker-build6docker tag asyncapi/generator:latest asyncapi/generator:${{ steps.extractver.outputs.version }}7docker push asyncapi/generator:${{ steps.extractver.outputs.version }}8docker push asyncapi/generator:latestBump version in package.jsonA common practice is to bump the package version inpackage.jsonon every release. You should also push the modified file to the release branch. Be aware though that good practices in the project are:Do not commit directly to the release branch. All changes should go through pull requests with proper peer review.Branches should have basic protection enabled. There should be simple rules that block pull requests before the merge.Release workflow, instead of pushing directly to the release branch, should commit to a new branch and create a pull request. Seems like an overhead? No, you can also automate it. Just keep on reading.1-name:CreatePullRequestwithupdatedpackagefiles2if:steps.initversion.outputs.version!=steps.extractver.outputs.version3uses:peter-evans/create-pull-request@v2.4.44with:5token:${{secrets.GH_TOKEN}}6commit-message:'chore(release): ${{ steps.extractver.outputs.version }}'7committer:asyncapi-bot<info@asyncapi.io>8author:asyncapi-bot<info@asyncapi.io>9title:'chore(release): ${{ steps.extractver.outputs.version }}'10body:'Version bump in package.json and package-lock.json for release [${{ steps.extractver.outputs.version }}](https://github.com/${{github.repository}}/releases/tag/v${{ steps.extractver.outputs.version }})'11branch:version-bump/${{steps.extractver.outputs.version}}Conditions and sharing outputsGitHub Actions has two excellent features:You can set conditions for specific stepsYou can share the output of one step with anotherThese features are used in the release workflow to check the version of the package, before and after the GitHub/NPM release step.To share the output, you must assign anidto the step and declare a variable and assign any value to it.1-name:Getversionfrompackage.jsonafterreleasestep2id:extractver3run:|4version=$(npm run get-version --silent)5echo "version=$version" >> $GITHUB_OUTPUTYou can access the shared value by theidand a variable name likesteps.extractver.outputs.version. We use it, for example, in the condition that specifies if further steps of the workflow should be triggered or not. If the version inpackage.jsonchanged after GitHub and NPM step, this means we should proceed with Docker publishing and pull request creation:if:steps.initversion.outputs.version!=steps.extractver.outputs.versionFull workflowBelow you can find the entire workflow file:1name:Release23on:4push:5branches:6-master78jobs:9release:10name:'Release NPM, GitHub, Docker'11runs-on:ubuntu-latest12steps:13-name:Checkoutrepo14uses:actions/checkout@v215-name:SetupNode.js16uses:actions/setup-node@v117with:18node-version:1319-name:Installdependencies20run:npmci2122-name:Getversionfrompackage.jsonbeforereleasestep23id:initversion24run:npmrunget-version--silent2526-name:Setoutput27run:echo"version=$(npm run get-version --silent)">>$GITHUB_OUTPUT2829-name:ReleasetoNPMandGitHub30id:release31env:32GITHUB_TOKEN:${{secrets.GH_TOKEN}}33NPM_TOKEN:${{secrets.NPM_TOKEN}}34GIT_AUTHOR_NAME:asyncapi-bot35GIT_AUTHOR_EMAIL:info@asyncapi.io36GIT_COMMITTER_NAME:asyncapi-bot37GIT_COMMITTER_EMAIL:info@asyncapi.io38run:npmrunrelease39-name:Getversionfrompackage.jsonafterreleasestep40id:extractver41run:echo"::set-output name=version::$(npm run get-version --silent)"42-name:ReleasetoDocker43if:steps.initversion.outputs.version!=steps.extractver.outputs.version44run:|45echo ${{secrets.DOCKER_PASSWORD}} | docker login -u ${{secrets.DOCKER_USERNAME}} --password-stdin46npm run docker-build47docker tag asyncapi/generator:latest asyncapi/generator:${{ steps.extractver.outputs.version }}48docker push asyncapi/generator:${{ steps.extractver.outputs.version }}49docker push asyncapi/generator:latest50-name:CreatePullRequestwithupdatedpackagefiles51if:steps.initversion.outputs.version!=steps.extractver.outputs.version52uses:peter-evans/create-pull-request@v2.4.453with:54token:${{secrets.GH_TOKEN}}55commit-message:'chore(release): ${{ steps.extractver.outputs.version }}'56committer:asyncapi-bot<info@asyncapi.io>57author:asyncapi-bot<info@asyncapi.io>58title:'chore(release): ${{ steps.extractver.outputs.version }}'59body:'Version bump in package.json and package-lock.json for release [${{ steps.extractver.outputs.version }}](https://github.com/${{github.repository}}/releases/tag/v${{ steps.extractver.outputs.version }})'60branch:version-bump/${{steps.extractver.outputs.version}}Automated merging workflowYou may be asking yourself:Why automated approving and merging is handled in a separate workflow and not as part of release workflowOne reason is that the time between pull request creation and its readiness to be merged is hard to define. Pull requests always include some automated checks, like testing, linting, and others. These are long-running checks. You should not make such an asynchronous step a part of your synchronous release workflow.Another reason is that you can also extend such an automated merging flow to handle not only pull requests coming from the release-handling bot but also other bots, that, for example, update your dependencies for security reasons.You should divide automation into separate jobs that enable you to define their dependencies. There is no point to run theautomergejob until theautoapproveone ends. GitHub Actions allows you to express this withneeds: [autoapprove]Below you can find the entire workflow file:1name:AutomergereleasebumpPR23on:4pull_request:5types:6-labeled7-unlabeled8-synchronize9-opened10-edited11-ready_for_review12-reopened13-unlocked14pull_request_review:15types:16-submitted17check_suite:18types:19-completed20status:{}2122jobs:23autoapprove:24runs-on:ubuntu-latest25steps:26-name:Autoapproving27uses:hmarr/auto-approve-action@v2.0.028if:github.actor=='asyncapi-bot'29with:30github-token:'${{ secrets.GITHUB_TOKEN }}'3132automerge:33needs:[autoapprove]34runs-on:ubuntu-latest35steps:36-name:Automerging37uses:pascalgn/automerge-action@v0.7.538if:github.actor=='asyncapi-bot'39env:40GITHUB_TOKEN:'${{ secrets.GH_TOKEN }}'41GITHUB_LOGIN:asyncapi-bot42MERGE_LABELS:''43MERGE_METHOD:'squash'44MERGE_COMMIT_MESSAGE:'pull-request-title'45MERGE_RETRIES:'10'46MERGE_RETRY_SLEEP:'10000'For a detailed reference, you can look intothis pull requestthat introduces the above-described workflow in thegenerator.ConclusionsAutomate all the things, don't waste time. Automate releases, even if you are a purist that for years followed a rule of usingimperative moodin commit subject and now, after looking on prefixes from Conventional Commits you feel pure disgust.In the end, you can always use something different, custom approach, like reacting to merges from pull requests with the specific label only. If you have time to reinvent the wheel, go for it.Cover photo byFranck V.taken from Unsplash.
"""
--------------------------------------------------------------------------------


Post 121
ID: https://www.asyncapi.com/blog/using-nunjucks-with-asyncapi?utm_source=rss
Title: Nunjucks templating explained on the basis of AsyncAPI specification
Link: https://www.asyncapi.com/blog/using-nunjucks-with-asyncapi?utm_source=rss
Summary: Edit 14.04.2021



In this post, I explain how you can use Nunjucks to template information extracted from an AsyncAPI file. I also write how you can make it even easier using Nunjucks inside the Asyn
Content:
"""
Edit 14.04.2021In this post, I explain how you can use Nunjucks to template information extracted from an AsyncAPI file. I also write how you can make it even easier using Nunjucks inside the AsyncAPI Generator. Now, we also have aReact-basedrender engine inside the generator, and it is far more developer-friendly. I encourage you to try it out.Specifications exist for a reason. Among other things, they help to bring quality, consistency, and standardize a given area. They are a great use case for templating engines. You can prepare a template that generates something from any document that follows a particular specification. You can generate whatever you want, docs, code, and diagrams. The sky is the limit.Templating is a vast topic that is impossible to cover in a single post. In JavaScript alone, there is a zoo of differenttemplating engines. This is why I focus here only on one engine for JavaScript, which isNunjucks. Why? Soon you'll figure that out.tl;drIn case you don't want to read and prefer to jump right into code. Go to this CodeSandbox project, but keep in mind you'll miss the important context and explanation.What is AsyncAPI?AsyncAPIis a specification that you use to create machine-readable definitions of your event-driven APIs:It focuses on the application from the API user perspective. You describe what the user can do with the API, subscribe or publish to it.It is protocol-agnostic so that you can use it for APIs using Kafka or MQTT, and many others.It supports many different schema formats, so you can describe messages payload schema in a format that you already use like, for example, Avro.What is Nunjucks?Nunjucksis a templating engine for JavaScript, inspired byJinja. It has many nifty features that make templating really nice:Variables declarationBuilt-in filtersWay to create custom filtersChaining filtersIncludesMacrosNunjucks basics by exampleAll examples shown in this post can be explored in action in below CodeSandbox project.In this learning project, I created a simple Express app that handles super short documentation generated from the AsyncAPI file. It is just a small sample of things that you can get from AsyncAPI using Nunjucks.I picked Nunjucks here for a reason. AsyncAPI community maintainsa tool for generatingdifferent things from the specification document, and it is using Nunjucks as a templating engine. This basically means, use my CodeSandbox to experiment with Nunjucks, but if you plan to build some serious template for AsyncAPI, do it with thegeneratoror reuse existing templates.Variables declarationYou can declare inside the template a variable, that helps you in cases like loops. Their great use case is the same as in programming. If you have a value that you use more than once, assign it to a variable.I used it to keep the name of the API:{%setapiName = asyncapi.info().title() %}Then I could use it multiple times, for example in these sentences:1{/* Sentence 1 */}2The{{apiName}}is licensed under{{asyncapi.info().license().name() }}.34{/* Sentence 2 */}5<p>6Here you can find a list of channels to which you can publish and7<strong>{{apiName}}</strong>is subscribed to:8</p>Built-in filtersUnlike other engines, Nunjucks comes with many built-in helpers, called filters. There are around 40 different. You can for example easily make a value all uppercase:1{/* server.protocol() value comes as all lowercase */}2using {{ server.protocol() | upper }} protocolCreating custom filtersBuilt-in filters are awesome, but sometimes you need to create your filters. In my example, I had to build a filter that helps me to modify theserver.url()value.In the AsyncAPI document, you can specify a server that the application uses to publish and consume messages from. In the URL, you are allowed to use variables like this:test.mosquitto.org:{port}. Such a variable can be described with different levels of detail. You can provide a default value and even an enum of values.In my example, instead of a URL liketest.mosquitto.org:{port}, I wanted to get a fixed URL with a proper port number taken from the document:1//replace is performed only if there are variables in the URL and they are declared for a server2function replaceVariablesWithValues(url, serverVariables) {3const urlVariables = getVariablesNamesFromUrl(url);4const declaredVariables = urlVariables.filter((el) =>5serverVariables.hasOwnProperty(el[1])6);78if (urlVariables.length!==0&& declaredVariables.length !==0) {9let value;10let newUrl = url;1112urlVariables.forEach((el) => {13value = getVariableValue(serverVariables, el[1]);1415if (value) {16newUrl = newUrl.replace(el[0], value);17}18});19return newUrl;20}21return url;22}2324function getVariablesNamesFromUrl(url) {25let result = [],26array;27const regEx = /{([^}]+)}/g;2829while ((array= regEx.exec(url)) !== null) {30result.push([array[0], array[1]]);31}3233return result;34}3536function getVariableValue(object, variable) {37const keyValue = object[variable]._json;3839if (keyValue) return keyValue.default || (keyValue.enum&& keyValue.enum[0]);40}Such a filter is very handy to use, the same as the built-in filters. You can additionally enrich its context. Take a look below where you can see that my filter gets not onlyserver.url()value as a context but alsoserver.variables():{{server.url() | replaceVariablesWithValues(server.variables()) }}Chaining filtersBuilt-in filters, custom filters...that is not all. Chaining of the filters is like an icing on the cake.The same case with URL. The URL after replacing variables with values, I want to transform it into a clickable element and make it part of the DOM. All of it made easy thanks to chaining:1{{server.url() | replaceVariablesWithValues(server.variables()) | urlize | safe2}}IncludesYou can share static parts of the template. This allows you to decrease the size of templates and make maintenance easier. My example here is not very complex, and I've added it to the template to make the point that it is possible:1{/*contentof space.html file */}2<hr/>3<br/>I can include it as many times as I want across the templates like this:{%include"space.html" %}MacrosYou can share not only static but also dynamic parts of the template. What does it mean? Let's take an HTML list as an example. From the syntax/structure perspective, it always looks the same, but the displayed values of the list are different. Macros are here to help you out to define a list element once. It is like a mixture of the include and a filter.In the AsyncAPI document, I have a case where I want to list all the channels that the application uses. Actually, I want to have two lists: one list that has channels where the application is subscribed (publishoperation) to receive messages and the other one where the application publishes (subscribeoperation) messages to.First you define a macro:1{%macrolistEl(value) %}2<li><strong>{{ value }}</strong></li>3{%endmacro%}Then you can import macros in your template:{%import"macros.html"ashelpers %}You call macros like you typically call functions:{{helpers.listEl(channelName) }}ConclusionDon't build tools from scratch if there are others already available, and they are open for contributions. Trying something from scratch, as I did with the templating CodeSandbox for AsyncAPI, makes sense only for learning purposes.Keep in mind thatAsyncAPIis an open community. We do not work on the specification only, but tools too. Join us onSlackand help us build awesome tools ordonate.Take time to look into theparser-js. I used it in my CodeSandbox to parse the AsyncAPI document to pass it to templates as a context.
"""
--------------------------------------------------------------------------------


Post 122
ID: https://www.asyncapi.com/blog/v2-important-dates?utm_source=rss
Title: AsyncAPI 2.0.0 important dates
Link: https://www.asyncapi.com/blog/v2-important-dates?utm_source=rss
Summary: Hey folks! After some time thinking about it, I've decided it's time to define some important dates for AsyncAPI 2.0.0. So here we go!
Content:
"""
Hey folks! After some time thinking about it, I've decided it's time to define some important dates for AsyncAPI 2.0.0. So here we go!End of review period (July 1, 2019)After some time, many people have reviewed the specification and they've identified someissues that need to be addressedbefore we launch the version 2.0.0. Actually, this process will never finish but we have to decide on a date to stop reviewing and move forward. This date is July 1. After this day, reviews are still welcome but they will not make into version 2.0.0, and will have to wait for the next version.Beta testing program (July-September)Right after we're clear on what's going to be the final version 2.0.0, we'll start working on improving all the tooling and make sure they support version 2.0.0 well. Tools are going to be open source as always so feel free to test them with your own use cases and let us know how it works! Either it sucks or it's amazing :)I'll personally track some of these tests to make sure everything is smooth. If you want to participate in the Beta testing program, feel free to reach out to me on ourSlack channelor send me an email tofmvilas@gmail.com.Official announcement (Late September-Early October)We'll announce the final version of AsyncAPI 2.0.0 during September-October timeframe. This doesn't mean you'll have to wait until then to use it. Remember everything is open source.We're planning on announcing it in a great conference. Stay tuned!Hope this helps clarify the roadmap a little bit. I'll update the exact dates here as we decide on them. Thanks for reading!Until next time!👋
"""
--------------------------------------------------------------------------------


Post 123
ID: https://www.asyncapi.com/blog/an-api-strategist-explores-event-driven-apis?utm_source=rss
Title: An API Strategist Explores Event-Driven APIs
Link: https://www.asyncapi.com/blog/an-api-strategist-explores-event-driven-apis?utm_source=rss
Summary: If you’re like me and have experience with web services and the paradigm of RESTful, web services, and SOAP APIs, but curious about event-driven, message based, or streaming APIs, this article is for you.
Content:
"""
An API Strategist Explores Event-Driven APIsIf you’re like me and have experience with web services and the paradigm of RESTful, web services, and SOAP APIs, but curious about event-driven, message based, or streaming APIs, this article is for you.I virtually sat down with these experts:Fran Mendez, Founder ofAsyncAPIJonathan Schabowsky, Chief Architect,SolaceDavid McKenna, SVP, Research & Development,AxwayEric Horesnyi, General Manager, APIs & Integration, Axway (CEO ofStreamdata.io acquired by Axway)Question 1:What do you think is the most important value proposition of event-driven architecture and event-driven/messaging APIs?Question 2:What is the consumption experience of messaging APIs and how much does it differ from RESTful APIs?For example, at the time of writing can’t just mock up the API and run it in a Postman collection and transform it (convert the technical specification to the version I want such as YAML to RAML or JSON, for example) and consume it.Tryhttp://editor.asyncapi.orgto understand the sister spec to OpenAPI (OAS).Question 3:Today, how can I test drive event-driven APIs out in the wild?My frame of reference with REST APIs: I can inspect HTTP calls in a browser and mock up the API. I can run the API calls in API Builder or Stoplight or Postman and get an InVision conceptual app to consume the API, for example. I can use Stoplight to lint or APIMatic to create starter SDKs to test drive.Question 4:How do you measure event-driven APIs?I was thinking about how you measure theeffectsof event-driven APIs. For example, how can various types of calls live within dashboards for the sake of analytics and measurement? Future Trend: Is there a way to get wholistic data from webhooks, RESTful/JSON, SOAP/WSDL/WADL/XML, GraphQL, gRPC, etc.?POV: The future of APIs is the unified catalog having a matching data-driven view.lifewingmateFor the greater API CommunityRecommendations are the most important piece of the event-driven architecture value proposition. Business leaders only care about event-driven architecture as much as the end result produces the business-driving experience that specifically this type of architecture can produce.Technology and consulting organizations need to know when and how to recommend event-driven architecture, APIs and microservices, and corresponding methods of implementation.
How they impact my current product engine? What business results justify the spend? —lifewingmateHere we go!Question 1: What do you think is the most important value proposition of event-driven architecture?Fran: I’d say most interesting for me are:loose coupling between services (if a downstream service breaks the others just work fine),they’re fault-tolerant since events are queued or stored somewhere, and processed once the service is up and running again, andthey allow you to build real-time products easily.Jonathan: 1)Loose Coupling— As Fran states, apps do not have to know how many different apps they are consuming data from. Rather they just care about what data they are consuming. This [scenario] is extremely powerful.Also, data today is RARELY consumed only once, rather, it goes into big data and analytics platforms. The loose coupling described allows you to have this for free.Reactive to Change— Instead of polling, consumers can register their their interest (subscribe) and react to changes in real-time. The producer just sends events, and does not care if anyone is interested… fire and forget… Meanwhile clients that are subscribed get the data in realtime and can react. This is useful where you want to service customers in real-time.Scale— Want to be able to consume events, in order, across millions of devices? How about do 500k messages per second guaranteed of capital market trades?Asynchronous interactions enable enterprises to do things which are nearly impossible to do synchronously.
—JSchabowskyDavid, Eric: Event-driven architecture brings comfort to end users and efficiency to the web at individual component level and at system level:UX in FrontendsNetworkAPIsBackendsBehind the API: Application languages, data plane, and DevOpsEntire SystemUX in FrontendsThemost popularreactive frameworks (AngularJS, ReactJS, VueJS) react to streams of events presented to theirobservables, a data plane presenting events to the UI.Why is that? Because, we -mobile and desktop human users- want to be presented data in real-time:Where is my cab?
What is the price of my favorite share, now?At what time will my train arrive at destination ?Yes, our life is real-time: we do not want to waste any time and we do not want to miss anything that happens in the world (FOMO— Fear Of Missing Out).Good news: Events improve latency of the UI by factor x20 according to ourbenchmark, and avoids for users to have to refresh their UI to get the latest from their newsfeed, stocks or favorite transportation, as ourreptilian brainis naturally used to [understanding].NetworkSince 2011, with the advent of social networks and to support reactive UI, the web has RFCed protocols for low-volume bidirectional/peer-to-peer traffic (Websockets) and server to client push over HTTP (SSE). For lower volume of events, typically for alerts,webhookshave become popular.APIsMost API calls are useless: up to 98.5% according toZapierwho created the concept of Polling Madness. That is because the API client does not know when data will change, so would keep polling an API to make sure it does not miss any update. Event-Driven Architecture in APIs reverses the paradigm: why don’t we have the component who know when data change to take charge, instead of answering to useless calls?This [situation] leads to the API server pushing streams of events to the API client who have subscribed to a topic. Traffic hence goes north-south only when necessary, rather than south-north-south to hit updates randomly. Augmenting a REST API with a streaming API typically brings90% efficiencyin CPU and network use for most demanding traffic.BackendsIn some industries, backends have been using evented architecture for a while.Behind the API: Application Languages, data plane, and DevOpsBackend architectures have relied on events for a while, before REST was created. In my Flashboy days inHigh Frequency Trading, we were pushing events from exchanges to hedge funds to allow them to stay in front of the market (making big money at low risk, I’m repentant), using IP-based tweaks (IP multicast and their famous storms), and proprietary middleware.Since then, message buses have evolved to open standards adopted outside finance (thanks Linkedin forKafka), and -as already noted- the web has made it possible to transport events over HTTP. Additionally, and almost at the same time, people -likemyself- having advocated microservices for years without seeing convergence of best practices are now contented:Kubernetesis here, and has instantly been adopted by all architects and DevOps to prepare their ideal microservices architecture.And when you dig into Kubernetes and associated frameworks Istio and Envoy, what do you find? REST APIs of course, but that was expected by definition of microservices. What you also find is Async APIs for each microservice. Kaboom! Backends now have a blueprint for quite a few years: Kafka and Kubernetes to orchestrate data flows, control and scale them. And this blueprint is entirely event-driven.To top it all and not surprisingly, languages traditionally used to create application layers linked to databases have also gone through their event revolution with reactive extensions such asRxJavawidely adopted by the Java community. Now the entire backend dev, DevOps, and IT community can focus on what will make them able to compete with agility over the web.Entire SystemIf we take a helicopter view to look at the entire system, what does the event-driven revolution?The entire chain from data plane, app, API, network down to the frontends are event-driven: Event flow between IoT devices (eg GPS), mobile apps, and ML without any barrier, people can all align thinking in terms of data streams of events rather than databases, considering intensity and relevance of feeds rather than states and calls.As all components have embraced the EDA revolution (I prefer evolution -revolution is always violent- as this is happening with live clients to be supported at the same time, hence slowly, but based on a Darwinian selection of design). This newend-to-end chain of eventsbrings simplicity and efficiency to components individually and collectively.Question 2: What is the consumption experience of event-driven APIs? How much does it differ from RESTful APIs?Fran: You usually connect to a broker to start sending and/or receiving messages. Examples of brokers are RabbitMQ, Kafka, Solace, etc. The difference with synchronous patterns like REST, gRPC, and GraphQL is that you don’t ask for information. You don’t make requests.Just connect to the broker and subscribe to a channel of your interest. Eventually (no pun intended), you’ll get this information, such as when the events occur. Similarly, you’ll send events to the broker whenever they occur to you. (replace you with your service)Jonathan: Today, the consumption experience generally sucks! This is a gap in the market AsyncAPI is solving and Solace [and several other companies, organizations, and individuals] is looking to help solve too… help make the experience as pleasant as with RESTful APIs.David, Eric: There are many different technologies for providing event driven APIsServer-Sent Events (SSE) for pushing data to the client to provide reactive user experienceWebhooks for making HTTP callbacks on state changeHTML5 Websockets providing full-duplex communication channels over a single TCP connection between client and server.MQTT and AMQP for IoT use casesQuestion 3: Today, how can I test drive event-driven APIs out in the wild?Fran: You can’t or is not easy. Part of the reason for the existence of AsyncAPI is precisely to enable that.Jonathan: Check outcloud.solace.com… Sign up for an account (free) and play around. Create an event broker (think of that like an API gateway) and look at our runnable code pen examples. This is all more infrastructure based…. Now imagine AsyncAPI and you layer that on top, it becomes more like API management. Also, check out this bloghttps://solace.com/blog/api-management-event-management/(Emmelyn) I can inspect HTTP calls in a browser and mock up the API and run it in Postman and get an InVision conceptual app to consume the API, for example.You can kind of do this atcloud.solace.com… Again its more how do you send/receive messages… with no app context, but its a start and the most useful I have ever found.(Emmelyn) I can use Stoplight to lint or APIMatic to create starter SDKs to “try it”See previous comment and try it out and give me feedback!David, Eric: Many of the traditional testing tools do not natively support event- driven protocols and are built for standard HTTP request/response found in REST based services. In order to help support the testing of SSE a client SDK is provided to help build automated clients to test both functional and non-functional aspects of SSE services.Question 4: How do you measure event-driven APIs?Fran: You don’t have “calls” because you don’t ask for anything. You just show your interest in certain types of events and wait for them to happen. That’s a subscriber/consumer. If you’re building a publisher/producer then you’ll send events to the broker when certain events occur. The consumers interested in your type of event will receive them.Jonathan: I think effectiveness is a direct correlation between consumption. An event that is consumed 0 times was actually worth 0… an event consumed 100 times is valuable. Yes, you do this via dashboards. Today, nobody deals with BOTH events and synchronous apis in one platform.David, Eric: The enhanced user experience in the client can be tracked by NPS of the service.Traditional monitoring tools are optimized for request-response scenario, asynchronous scenarios bring in additional complexity where by a single request could result in N number of responses been relayed to the client. Adoption of OpenTracing can help to see the spans of distributed transactions.Value Proposition of Event-Driven ArchitectureBusiness leaders only care about event-driven architecture as much as the end result produces the business-driving experience that specifically this type of architecture can produce. What would you explain to this type of audience?Fran’s takeReal-time experiences are built with event-driven architectures. You can’t build something real-time with REST APIs or any of the aforementioned styles.Solace has an interesting concept called “event mesh” andJonathanSchabowsky can explain better and point to existing documentation.And then you have the cool thing about event-driven microservices, which allows you to build products faster. It allows you to spend less time worrying about the systems and more about your business logic.Eric’s takeAs a CEO myself, I do not invest in any feature of any technology until I can see proven track records and numbers. Well, EDA actually brings sizeable benefits in terms of topline, customer satisfaction, cost base, competitive differentiation and even HR attractiveness and retention:ToplineCustomer SatisfactionOutsmart your Competitors with Machine Learning MLIT Cost Base ReductionHRToplineThe main benefits of the EDA mindset is to optimize the time it takes between the occurrence of an event in the universe, and the reaction by the company to that event. Each industry has its own metrics for assessing such benefit. In capital markets, 1 millisecond is worth$8m(!)In marketplace/ecommerce/retail/logistics business where players make as much money as they can reduce the time between an order is placed to them, and such order is shipped to the end user, each second count. I did a quick calculation of how much a second is worth for Amazon, by dividing revenue by the number of seconds in a year:$50m(!)Customer SatisfactionAs already noted, reactive interfaces are not only the coolest but also the most natural for our human brain. Well, we can put a number on this:100 ms is worth 1%additional revenue on any mobile or desktop app, from mobile banking to eCommerce.For developers using your API, when you can provide your most important customer the ability to consume your API without limit, they are happy to pay a premium for it as it means they have more data to make decision upon, and it helps streamlining their data ingestion chain.Outsmart your Competitors with MLA major way for technology to bring value to customer interactions (chatbots), optimize processes and make best-possible decisions in an ever-changing world is Machine Learning. And Machine Learning thrives on data. In the past, data architectures were based on tables and data lakes. Well, for practitioners, data lakes actually became data swamps.With some experience, the key is to master data ingestion so that data sources are consumed upstream, as close as possible to the source, and turned into value as soon as possible by Machine Learning. Machine Learning consumes streams of data conveyed by Kafka from third party streaming APIs, such asXignite Cloudstreaming, learn from them as they come and learns from its errors against what it had predicted.And the closer you are from data sources (acting as senses for the ML brain), the smarter your ML brain will be, faster than your competition. There is even a family of ML updating their model for each, calledMassive Online Analysisor Streaming Algorithms. EDA has even invaded ML.IT Cost Base ReductionWith the 90%+ gains in efficiency that we have mentioned earlier, an API vendor servicing clients with events can not only make them happier, but also reduce its cloud bill on CPU and network by 90% on these use cases. As cloud bills have become so high and critical to become visible to executive desks, they should understand the impact.HRI believe we would agree that developers and DevOps like new and efficient [tools]. And events are fun while bringing efficiency. Working with events makes your organization more attractive to new developers, and help keeping them happy while working on cutting-edge technology. As developers cannot meet the demand while “software is eating the world” this [circumstance] alone could be a driver for considering and EDA and API and Microservices first approach in your organization.Question: How and when should companies actively choose event-driven architecture?For example, how is discovery performed? Which APIM catalogs can showcase event-driven APIs so that companies can decide to consume rather than build it themselves? What kind of guidance and best practices can we provide?David and Eric adviseIoT— Many companies are looking to leverage IoT in their offering such as car insurance (pay as you drive), healthcare (health monitoring).A vast variety of low-price devices (sensors, thermostats, robots, etc.) with internet connectivity is flooding the market. Their value does not lie in the hardware but in the services that are/will be attached to it. The infrastructure that support these services must have a real-time processing capability to provide real value back to the consumer.MQTTis becoming the de-facto standard to exchange data with IoT devices because it is simple and efficient on low memory devices. It is also based on a Publish/Subscribe model that will force the companies to adopt an EDA in order to process all the generated events.Cloud— Adaption of cloud-based services in Enterprise adds more integration patterns (Cloud-to-cloud, Cloud-to-ground, Ground-to-Cloud, ..) thus more complexity. The different systems needs to exchange data to keep a coherent state across the applications. Using a point-to-point integration strategy can quickly become a trap because of the exponential complexity and tight coupling between the different systems.EDA enables a loose coupling between the components/apps in order regain agility, increases innovation pace and reduces time-to-market for new features/services.In general, I’m studying API Design Patterns and how various kinds of APIs expedite R&D adoption. What business results are accelerated from these kinds of patterns?Thanks for suggesting topics and connecting with feedback. You can also reach me via Twitter @lifewingmate DM or via the AsyncAPI community via ourGitHuborSlack channel.Disclaimer: The professional opinions of those interviewed do not necessarily reflect the organizations they represent. These interviewees volunteered their time and contributions to support the AsyncAPI initiative and community.
"""
--------------------------------------------------------------------------------


Post 124
ID: https://www.asyncapi.com/blog/asyncapi-cloud-events?utm_source=rss
Title: AsyncAPI and CloudEvents
Link: https://www.asyncapi.com/blog/asyncapi-cloud-events?utm_source=rss
Summary: There is the belief by many people that AsyncAPI and CloudEvents are competing for the same thing. This can't be less true, and I'd like to explain you why. Read on!
Content:
"""
I've been receiving the same question for a long time now: Should I use CloudEvents or AsyncAPI? — And my response has always been the same: it depends!There is the belief by many people that AsyncAPI and CloudEvents are competing for the same thing. This can't be less true, and I'd like to explain you why. Read on!What is CloudEvents?Fromcloudevents.io:Enter CloudEvents, a specification fordescribing event data in a common way. CloudEvents seeks to ease event declaration and delivery across services, platforms and beyond!The purpose of CloudEvents is to establish a common format for event data description. And it makes a lot of sense when you realize they are part of theCNCF’s Serverless Working Group.If you are doing serverless or FaaS (Function as a Service), then CloudEvents is your best friend because the event is the only information you will have in your function during runtime. No topics or channels, no servers, no subscribers. Just the event and some extra information you may need to make your function work.CloudEvents is focused on the eventand defines an envelope for your application's data. See an example from their repo:1{2"specversion":"0.2",3"type":"com.github.pull.create",4"source":"https://github.com/cloudevents/spec/pull/123",5"id":"A234-1234-1234",6"time":"2018-04-05T17:31:00Z",7"comexampleextension1":"value",8"comexampleextension2": {9"othervalue":510},11"contenttype":"text/xml",12"data":"<much wow=\"xml\"/>"13}Here your event is actually<much wow=\"xml\"/>and the rest is meta information about your event. This envelope is what CloudEvents defines with the purpose of making event declaration reusable across services and platforms.What is AsyncAPI?From theAsyncAPI repo:Create machine-readable definitions of your event-driven APIs.The purpose of AsyncAPI is to provide a way for you to define how your event-driven applications (or APIs) communicate with the rest of the world.AsyncAPI is focused on the application and the channels it uses to communicate. Similar to whatOpenAPIandRAMLdo for REST APIs. Unlike CloudEvents —who focuses on the message— AsyncAPI does not impose how your event must look like but, instead, allows you to strictly define its shape. See an example:1asyncapi:2.0.0-rc12id:urn:com.asyncapi.examples.user3info:4title:Userservice5version:1.6.36channels:7user/signedup:8publish:9message:10payload:11type:object12properties:13fullName:14type:string15email:16type:string17format:emailLooking at the example above, one can rapidly say this is the AsyncAPI definition of a User service, which its API version is 1.6.3 and it publishes to theuser/signedupchannel an event that is an object containing two properties:fullNameandemail.We can define the event payload but its structure is totally free and user-defined. And that's what makes AsyncAPI so powerful! Since our event payload can be anything, it can also be a CloudEvents event.AsyncAPI + CloudEventsLet's see an example of the two combined:1asyncapi:2.0.0-rc12id:urn:com.asyncapi.examples.user3info:4title:Userservice5version:1.6.36channels:7user/signedup:8publish:9message:10payload:11type:object12properties:13specversion:14type:string15enum:['0.2']16type:17type:string18example:com.github.pull.create19source:20type:string21format:uri22example:urn:com.asyncapi.examples.user23id:24type:string25example:'A234-1234-1234'26time:27type:string28format:date-time29example:2018-04-05T17:31:00Z30contenttype:31type:string32example:'application/json'33data:34type:object35properties:36fullName:37type:string38email:39type:string40format:emailLooking at the example above, one can say this is the AsyncAPI definition of a User service, which its API version is 1.6.3 and it publishes to theuser/signedupchannel a CloudEvents event whose data is a JSON object containing two properties:fullNameandemail.Leveraging AsyncAPI Custom Schema FormatsThere's only one concern with the approach above: every single CloudEvents definition is going to be exactly the same from line 11 to 33 — except for the examples that were added in this blog for clarity.The default format for defining events (messages) in AsyncAPI 2.0 is JSON Schema. Thankfully, AsyncAPI provides a way to define events in your own custom format —like Avro and Protobuf — or a hypothetical CloudEvents one in this case. See example:1asyncapi:2.0.0-rc12id:urn:com.asyncapi.examples.user3info:4title:Userservice5version:1.6.36channels:7user/signedup:8publish:9message:10schemaFormat:'application/cloudevents+json; version=0.2; charset=utf-8'11payload:12type:object13properties:14fullName:15type:string16email:17type:string18format:emailThis results in a much shorter and nicer way of defining the usage of CloudEvents inside an AsyncAPI document.Ok, it's possible but, does it makes sense?It really depends on your use case but it makes sense in scenarios where some kind of FaaS is involved. Consider the following example:Reading the diagram from the bottom up, we see an overly simplified diagram of a sign up process. Theuser/signedupevent flows from the REST API to the monitoring service and the FaaS API through the broker. The event could have the CloudEvents format so that both, the FaaS API and the monitoring service, understand it. Obviously, one may argue that the Faas API could be wrapping the event data in CloudEvents format and leave the rest of the events untouched, in plain JSON. Fair.So, does it really makes sense? It certainly does in some situations. Do you have to use AsyncAPI and CloudEvents together? As always that's up to you.You have the tools. Choose them wisely.ConclusionWe've learned how AsyncAPI differs from CloudEvents. Before I finish these lines, I'd like to make something clear again: AsyncAPI focuses on the application and how it is connected; and CloudEvents focuses on the message. Both things are compatible and complementary. Evaluate what are your needs and decide which one suits them better. There's no one-size-fits-all solution.I hope you learned something new, if so, please consider donating to theAsyncAPI Initiative.Until next time!👋
"""
--------------------------------------------------------------------------------


Post 125
ID: https://www.asyncapi.com/blog/status-update-week-17-2019?utm_source=rss
Title: Status update (week 17, 2019)
Link: https://www.asyncapi.com/blog/status-update-week-17-2019?utm_source=rss
Summary: Alas güenas tardis! This week we've made significant progress on the documentation and the parser. The goal is to make AsyncAPI 2.0.0 easy and quick to learn at the same time we provide you the necessary tools to start playing with it.
Content:
"""
Alas güenas tardis! This week we've made significant progress on the documentation and the parser. The goal is to make AsyncAPI 2.0.0 easy and quick to learn at the same time we provide you the necessary tools to start playing with it. Check out the progress so far:The parserCompile for all platforms: One of the hardest things to solve, before we continue moving forward, was the compilation process. We had to make sure we can compile the Go parser to C shared objects for Linux, Mac, and Windows. To make thing easier, we moved the compilation process to Travis CI, so now we don't have to configure our computers for cross-compilation.JSON Schema dereferencing: When we decided to choose Go as our main language for the parser development we knew there were less libraries than in the Node.js universe. One of the missing pieces was a JSON Schema dereferencer, i.e., a library that takes a JSON Schema document and replaces all the appearances of$refwith the value they point to.Rubéncame up with an initial solution and he's now working on polishing it, extracting the code to a separate library so the Go community can benefit from it, and adding support for circular references.The documentationNew Getting Started guide: This week we just launched our new getting started guide for AsyncAPI 2.0.0. The guide targets new users of AsyncAPI and event-driven architectures. Also, if you're coming from OpenAPI (Swagger), don't miss the comparative chart.New blog: Enough with Medium. There's no point on hosting the blog on a service that puts very low limits on how much you can read for free. We'll keep posting there as a distribution channel but the full articles will live in our self-hosted blog, powered byHugo.TalksJoin us tomorrow forAPI days Madridif you're in the city. I'll be talking all things AsyncAPI, past, present, and future. And also having some beers and tapas🍻. Let's connect!DonateAnd last but not least, we’re running a sponsorship campaign. We’ve got different tiers so that everybody can show their love!❤️Donate here. Help Open Source projects.“Victorious warriors win first and then go to war, while defeated warriors go to war first and then seek to win.”
— Sun TzuSee you next week, folks!👋
"""
--------------------------------------------------------------------------------


Post 126
ID: https://www.asyncapi.com/blog/getting-started-with-event-driven-architectures?utm_source=rss
Title: Getting started with event-driven architectures
Link: https://www.asyncapi.com/blog/getting-started-with-event-driven-architectures?utm_source=rss
Summary: All developers, architects, and product managers are used to REST APIs and the synchronous paradigm of communication. You make a request and wait for the response. This is exactly how the web works. Y
Content:
"""
All developers, architects, and product managers are used to REST APIs and the synchronous paradigm of communication. You make a request and wait for the response. This is exactly how the web works. You enter a URL (e.g., google.com) in the address bar of your favorite browser and it sends a request to the server. Following, the server sends the response with the content of the website.The web is the greatest implementation of a REST API.However, there are certain situations when you don't really need a response from the server. At least no other than the confirmation the request has been received. This is also called"fire and forget", and it's really useful when you just want to communicate or inform that "something happened." It is, you're not requesting or asking for anything, thus you don't need a response.  Examples of this are:A user just signed up.You have a new follower.Your fridge is getting empty.Along with the event, you may also want to sendextra information. For instance:A user just signed up: here's the user information (e.g., name, email, age, etc.)You have a new follower: here are the details of the follower (e.g., username, name, picture, etc.)Your fridge is getting empty: here's the percentage of "emptiness" (e.g., 23%)This extra information is often referred to asevent payloadormessage payload.Core conceptsIn most cases, Event-Driven Architectures (EDAs) are broker-centric, like in the diagram above. In it you can find some new concepts, so let's go through them now.Message brokerA message broker (or"broker") is a piece of infrastructure in charge of receiving messages and delivering them to those who have shown interest. They often store messages until they are delivered, what makes EDAs very resilient to failures. Examples of brokers areRabbitMQ,Apache Kafka,Solace, etc.Publisher/SubscriberA publisher (a.k.a.producer) is an application that sends messages to thebroker.A subscriber (a.k.a.consumer) is an application that connects to thebroker, manifests interest in certain type of messages, and leaves the connection open so thebrokercan push messages to them.MessageA message is a piece of information that's sent by the publishers to the broker, and received by all the interested subscribers. The content of the message can be anything but they are frequently catalogued aseventsandcommands. As we saw above,eventscommunicate a fact that occurred. Instead,commandsare very much likerequestsin REST APIs: they tell the subscribers "do this".Technically speaking,eventsandcommandsare the same. The only difference is in their semantics.ChannelsOne detail that might pass unnoticed from the diagram above is the existence ofchannels. All thebrokerssupport communication through multiple channels. The industry doesn't have a common term though so you may find them astopics,routing keys,event types, and probably other ones I'm missing.They're usually assigned a name or identifier (e.g.,user_signed_up) and it's often a good practice to send a single type of message through them. Think about TV or radio channels: the BBC only broadcasts its information through an assigned channel. If the broadcasters (publishers) didn't respect that rule you (the subscriber) would only see and hear interferences.Why "event-driven" and not "message-driven"?You will find both used interchangeably, although they are not exactly the same. You will even find"message-based"and"event-based". In practice, chances are they all refer to the same thing.Theoretically,"message-driven"is the most generic term, meaning you may use events and commands, whileevent-drivenmeans that it's purely about events. However, that's not always the case, as Martin Fowler explains in his talk"the many meanings of event-driven architecture":ConclusionWe've seen what an event-driven architecture is, how it works, and what are their components. AsyncAPI is all about defining and documenting each of these components.Check out ourgetting started guideto learn more.
"""
--------------------------------------------------------------------------------


Post 127
ID: https://www.asyncapi.com/blog/status-update-week-15-2019?utm_source=rss
Title: Status update (week 15, 2019)
Link: https://www.asyncapi.com/blog/status-update-week-15-2019?utm_source=rss
Summary: Kaixo lagunak! This week we continued working on the parser as it’s a top priority for us. We made significant progress and plan to release a simple but functional version soon.

Building the parser
Content:
"""
Kaixo lagunak! This week we continued working on the parser as it’s a top priority for us. We made significant progress and plan to release a simple but functional version soon.Building the parserWe’ve added support for AsyncAPI 1.x/OpenAPI schemas. This is the first step before we dive into Avro and Protobuf support.Updated the Node.js to automatically test itself on Linux, Mac, and Windows. We’re still struggling to debug some failures on Windows so we encourage people who work on this operating system to join and help us test.TalksI’ll be speaking about AsyncAPI and event-driven architectures in a few conferences. Let’s connect!API Days Madrid (April 26):http://apidaysmad.apiaddicts.org/schedule/#session-2Gartner AADI (May 20–21):https://www.gartner.com/en/conferences/emea/applications-ukKubeCon Europe (Barcelona, May 22–23). Not speaking but let’s meet there!REST Fest Europe (Wrocław, May 31):http://2019.restfest.org/eu/scheduleAPI Days Finland (Helsinki, June 4–5):https://www.apidays.fi/DonateAnd last but not least, we’re running a sponsorship campaign. We’ve got different tiers so that everybody can show their love!❤️Donate here. Help Open Source projects.“People who think they know everything are a great annoyance to those of us who do.”
— Isaac Asimov😄See you next week, folks!👋
"""
--------------------------------------------------------------------------------


Post 128
ID: https://www.asyncapi.com/blog/replicating-success-rest-event-driven-architecture?utm_source=rss
Title: Replicating the Success of REST in Event-Driven Architecture
Link: https://www.asyncapi.com/blog/replicating-success-rest-event-driven-architecture?utm_source=rss
Summary: Jonathan explained in his last blog post how the loose coupling of applications associated with event-driven architecture and publish/subscribe messaging is both a strength and a weakness.
Content:
"""
This post is a collaboration betweenFran Méndezof AsyncAPI and Solace’sJonathan Schabowsky. It was originally published atSolace’s blog.Jonathan explained in hislast blog posthow the loose coupling of applications associated with event-driven architecture and publish/subscribe messaging is both a strength and a weakness. As part of that, he touched on the fact that request/reply interactions using RESTful APIs are still the dominant application integration paradigm, even in hybrid cloud, machine learning and IoT use cases that benefit from event-driven interactions. There’s still tons of use cases for which RESTful request/reply interactions are perfect, but it’s important to be able to mix and match the right exchange pattern (Command, Query and Event) for the job especially where event-driven would be best suited.In many cases, exploring why one thing has established or maintained popularity can help you understand why something else isn’t quite as hot, even though it seems like it should be. With this post I’ll investigate why the use of RESTful APIs is still so prevalent, and see if the reasons for its persistent popularity might act as a blueprint for making event-driven popular and mainstream. So, how did REST come to be the most popular way to connect applications? And why does everyone think it’s so easy?How did REST get to be so hot?REST’s popularity arose out of the need for data exchange and interactions between the web browser and backend services. In that context it became a de facto standard because it integrated so well with JavaScript and was so much easier than SOAP (a decent protocol that became bloated and complicated over time). From there, developers started using REST to connect internal enterprise applications, IoT devices and even microservices. It might not have been the best fit for all those use cases, but it got the job done.AsMatt McLartymentions in his blog postOvercoming RESTlessness, a complete examination about why REST started to be used in places that it’s not ideal for “would ignore the power that comes from REST’s universality.” He’s referring to the fact that REST has become universal because developers “get it” and it’s surrounded by a thriving ecosystem of complementary technology and tools. Without this ecosystem that REST inherited from the web world, that universal adoption simply would not have happened.The Building Blocks of REST’s SuccessIf you look closely at this ecosystem (foreshadowing) you can see that it’s composed of some foundational components upon which the open source and vendor community have built what I’ll call “enablement tooling.” Here’s what I mean:Foundational ComponentsWeb serverswere the workhorse of the web for years before REST came into existence. They were much simpler than the application servers of the time and optimized to deal with large numbers of lightweight request/reply communications interactions like serving up a web page that somebody requests.Development frameworkslike Spring, JAX-RS, Restlet and Node.js reflect the fact that people invested time and energy to make the developer experience easy, i.e. keeping them from having to write boilerplate connection code so they could focus on the hard part of developing and refining business logic.Security frameworkslike OAUTH for authentication and authorization, and TLS for encryption, established the means by which interactions and information can be made secure.Enablement ToolingAPI Management: Companies like Apigee and MuleSoft built platforms that provide an API portal so developers can describe and discover APIs in design-time, API gateways to ensure security, management and API mediation, and finally usage analytics which inform which APIs are most and least used. These API management solutions are used increasingly for sophisticated API creation and design, and to act as API marketplaces.Runtime API Discovery: As APIs and applications have become increasingly dynamic and distributed due to continuous delivery, containerization, cloud-bursting, discovery tooling such as Netflix Eureka and Istio/Envoy (service mesh) have been created to reduce the complexity of API clients and enable them to connect to services anywhere.Specification for API Description: OpenAPI was created as a machine-readable metadata specification in order to document, design and consume APIs. This is incredibly valuable for use by testing tools, clients and document generation.Code Generation Tools: Swagger and its associated code generation tooling lets developers easily take an OpenAPI definition and generate either client or server code, drastically reducing the amount of work it takes development teams to use APIs.Without the foundational components, not only would the enablement tooling not have been possible, there wouldn’t have been any need or demand for it. This ecosystem of tools has facilitated REST’s ascension to its position as the de facto standard for application interactions today. While I lament the fact that event-driven hasn’t achieved this same level of adoption and devotion, I understand why, and know that without similar tooling it never will.How Event-Driven is Following in REST’s FootstepsThere is no reason why the event-driven world can’t learn from the RESTful API world by leveraging and developing similar foundational components and enablement tools. In fact, some very exciting initiatives are underway and picking up steam in the industry and within Solace:Foundational ComponentsEvent Brokers: This one is easy as many simple (RabbitMQ, ActiveMQ) and advanced event brokers (Solace PubSub+, Kafka) exist today. Many of them are battle-tested and used widely in organizations that are event-driven.Development Frameworks: Spring Cloud Stream makes writing event-driven microservices easy, and Paho for MQTT makes it easy to create event-driven IoT sensors in many programming languages.Security: Frameworks like OAuth enable authentication and authorization in the event-driven world along with TLS for encryption for confidentiality/integrity.Enablement ToolingEvent Management: Whileadvanced event brokersperform many functions similar to those of an API Gateway, no vendor offers a platform that does everything for events that API management platforms do for RESTful API interactions. There are no “event portals” for developers to use, for example, in order to design, document and discover events.Runtime Event Discovery: In the Eventing world, the ability to deliver events to consumers is even more complicated than with APIs because of the combination of 1-many event distribution, guaranteed and in-order quality of services along with event producers and consumers being just as dynamic and distributed as what is found with APIs. This has challenged infrastructure and operations teams for years all while client applications should not be burdened with these complexities. Theevent meshis an emerging architectural concept that provides similar functionality to theservice meshbut is targeted towards asynchronous interaction patterns. This removes the complexities previously described by enabling producers and consumers to exchange events regardless of where they are physically deployed all while maintaining event delivery qualities of service.API Description Specification:AsyncAPIis on a mission to standardize event-driven API interactions and support the wide variety of messaging systems available. This is a corollary toOpenAPI— a universal language for all the different messaging protocols and event schema formats. The purpose of AsyncAPI is to enable architects and developers to specify the event payload definition, channel name, application/transport headers and protocol– thus fully specifying the application’s event-driven interface. This was previously not available but, thanks to Fran Méndez and the AsyncAPI Initiative, event-driven applications will receive the same love as RESTful APIs.Code Generation Tools: AsyncAPI is also working in this direction. For instance, the ability to take an AsyncAPI definition and generate event-driven applications is underway for Spring Cloud Stream. This will drastically reduce the effort to create new applications!ConclusionEDA’s popularity has started to drastically increase as many companies are realizing they MUST react in real-time to their customers, decouple their systems and transform into event-driven organizations. However, for event-driven interactions to achieve the same level of adoption as REST, the build-out of tooling for eventing must continue. Now is the time to transform and support all the patterns modern applications need for interaction, i.e. commands, queries… and events!Solace is committed to helping organizations realize the advantages of being event-driven. We’re active on all these fronts by continuing to advance the state of the art with our PubSub+ event broker andevent mesh, enthusiastically supportingSpring Cloud Streams, and actively contributing expertise and financial support toAsyncAPI. Stay tuned for more information around how event management and API management are similar, how it is a key capability that organizations need, and what Solace is doing about it!
"""
--------------------------------------------------------------------------------


Post 129
ID: https://www.asyncapi.com/blog/status-update-week-14-2019?utm_source=rss
Title: Status update (week 14, 2019)
Link: https://www.asyncapi.com/blog/status-update-week-14-2019?utm_source=rss
Summary: Hallo meine Freunde! This week we’ve done great progress on tooling and documentation. It will be our main focus for the next month. In the meantime, check out what we did last week. Read on!

Improve
Content:
"""
Hallo meine Freunde! This week we’ve done great progress on tooling and documentation. It will be our main focus for the next month. In the meantime, check out what we did last week. Read on!Improvements on documentationCheck out version 2.0.0 of the specification in our website:https://www.asyncapi.com/docs/specifications/2.0.0/.Added a “Hello world” article to our getting started guide:https://github.com/asyncapi/asyncapi.github.io/pull/3.Added a “Servers” article to our getting started guide, explaining how the “servers” section of AsyncAPI works:https://github.com/asyncapi/asyncapi.github.io/pull/4.Improvements on toolingWe managed to compileour Go parserto Linux, Mac, and Windows C shared objects. This sets the base for an automated building process.As a result of the previous point, we managed to create a Node.js wrapper for the Go parser, making use of the C shared objects.AsyncAPI SIG meetingWe had our bi-weekly SIG meeting this week where we talked about future plans and how to improve onboarding. And it’s now uploaded toour Youtube channel.DonateAnd last but not least, we’re running a sponsorship campaign. We’ve got different tiers so that everybody can show their love!❤️Donate here. Help Open Source projects.“Great things in business are never done by one person. They’re done by a team of people.”
— Steve JobsSee you next week, folks!👋
"""
--------------------------------------------------------------------------------


Post 130
ID: https://www.asyncapi.com/blog/organizing-asyncapi-documents?utm_source=rss
Title: Organizing your AsyncAPI documents
Link: https://www.asyncapi.com/blog/organizing-asyncapi-documents?utm_source=rss
Summary: A recurring question that I get very often is: “how do I organize my AsyncAPI documents?”. Also, the related one: “I have two services, a publisher and a consumer, should I define both in the same Asy
Content:
"""
A recurring question that I get very often is: “how do I organize my AsyncAPI documents?”. Also, the related one: “I have two services, a publisher and a consumer, should I define both in the same AsyncAPI document?”.Let’s break down some best practices and tips to avoid ending up in a hell of unmanageable documents.Organizing MicroservicesI’m using the term microservices here because it’s the most common type of distributed architecture that you can find nowadays.The best practice for organizing AsyncAPI files in your microservices architecture is to have a file per microservice. This way, you end up with multiple independent files that define your application.One publisher and one subscriber, both sharing the UserSignUp message.Microservices are meant to do a single thing and to do it well and, very importantly, they must be independently deployable. However, if you have a publisher and multiple consumers, you quickly end up having something like the following:One publisher and various subscribers. All of them sharing the UserSignUp message.It’s clear there’s a dependency between all of them: theUserSignedUpmessage. If at some point to want to change it, you’ll have to go through all of the files and change it. It’s a tedious task we want to avoid, so we can make use of the$refcapability of AsyncAPI to simplify things:The value of $ref should be “common/messages.json#UserSignedUp”.Now, if you have to add something to theUserSignedUpmessage, it’s just a matter of changing one file. Depending on your setup, you may have to restart your services to get the new definition. However, as simple and straightforward as it may seem, you must take care not to introduce breaking changes in the message definition. Otherwise, you’ll have inconsistent states while some services got the new message definition and some didn’t yet. Here comes the importance of versioning your messages, but that makes for another blog post alone.Common mistakesSince microservices tend to be small in scope, most probably their AsyncAPI document will not be very extensive too. And I found out this is one of the reasons people tend to re-use the same file for many services. They think the file is very small and because the publisher and the subscriber share the same message, why not putting everything there? It’s tempting at first, but the reason why you should avoid doing this is that you lose context and semantics, and it causes problems:If a single document contains publish and subscribe for the same channel (topic), how do you know which one is defining what your application does?Since your document may contain many channels, how do you know if your application is publishing or subscribing to each channel or just a subset of them? That itself causes more problems, for instance, when you want to generate the documentation for a single service but you have a single file defining your whole architecture and thus a single documentation page describing all the services without any clue which one is doing what.An AsyncAPI file is meant to define the behavior of a single application. You can obviously break the rules and use it to define the whole architecture but expect all sorts of problems to appear because you’re using a hammer to saw a piece of wood. The same way you don’t use a single OpenAPI (Swagger) file to define many of your REST APIs, you shouldn’t use a single AsyncAPI document to define many of your message-driven APIs.Organizing Client-ServerSay, for instance, you have a WebSockets API and front-end application using it. The paradigm is very similar to the one we’re used to with HTTP APIs, with the subtle difference that the communication isfull duplex, i.e., the client can send and receive messages over the same channel, at any time.This case is not very different from the microservices one. If you think about it, we can look at it as a small distributed architecture, where you only have two services: the client and the server. So the recommended best practice is to follow the same approach and have one document for each of the applications — one for the server and another for the client or front-end.SummaryI want to reinforce the point that an AsyncAPI file is meant to definethe behavior of a single application. Keep this always in mind, and everything will make sense to you.Happy coding!✌️AsyncAPI is an open source project running on donations sopleaseconsider donating🙌
"""
--------------------------------------------------------------------------------


